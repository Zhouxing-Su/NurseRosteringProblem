%-----------------------------------------------------------------------
% 中国科学: 信息科学 中文模板, 请用 CCT & LaTeX 编译
% 请作者注意: 在整篇文章中, 不要使用任何改变文章版式的命令, 谢谢.
%-----------------------------------------------------------------------

\documentclass{SCIS2015cnauthor}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% 作者附加的定义
%%% 常用环境已经加载好, 不需要重复加载
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage{etex}
\usepackage{pgfplots}
\usepackage{multirow}

\renewcommand{\algorithmicrequire}{\textbf{Input:}}
\renewcommand{\algorithmicensure}{\textbf{Output:}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% 开始
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{document}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Authors do not modify the information below
%%% 作者不需要修改此处信息
\ArticleType{20truemm}{论~~~文}{}
\Year{2014}
\Vol{44}
\No{1}
\BeginPage{1}
\EndPage{?}
\DOI{xxxxxxxx}
\ReceiveDate{xxxxxxxx}
\AcceptDate{xxxxxxxx}
\OnlineDate{}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% 标题部分
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%% 标题 \title{正文标题}{引用的标题}
\title{用于求解多阶段护士排班问题的带权禁忌搜索}{}

%%% 英文题目, 只有第一个单词的首字母大写, 其余单词非专有名词全部小写
\entitle{Weighted tabu search for multistage nurse rostering problem}


%%% 通信作者 \author[number]{姓名}{{abc@xxxx.xxx}}
%%% 一般作者 \author[number]{姓名}{}
%%% 使用带圈标号 \ding{172},\ding{173},\ding{174},\ding{175},\ding{176}
\author[\ding{172}\ding{173}]{姓名}{{abc@xxxx.xxx}}
\author[\ding{173}]{姓名}{}

%%% 英文作者, 每行一个, []中写地址编号(1,2,3等), 与中文对应
%%% 姓的拼音字母全部大写, 名的拼音首字母大写
%%% 通信作者 \enauthor[number]{AAA BbbCcc}{{abc@xxxx.xxx}}
%%% 一般作者 \enauthor[number]{AAA BbbCcc}{}
\enauthor[1,2]{AAA BbbCcc}{{abc@xxxx.xxx}}
\enauthor[2]{AAA BbbCcc}{}


%%% 地址 \address[number]{地址, 城市 邮编}
\address[\ding{172}]{地址, 武汉 430074}
\address[\ding{173}]{地址, 武汉 430074}

%%% 英文地址, 每行一个, []中写地址编号(1,2,3等), 与中文对应, 需要写国家
%%% \enaddress[number]{Address, City {\rm 000000}, Country}
\enaddress[1]{Address, City {\rm 000000}, Country}
\enaddress[2]{Address, City {\rm 000000}, Country}


%%% 项目资助信息
%%% 国家自然科学基金 (批准号: 0000000, 0000000, 00000000),
%%% 国家高技术研究发展计划 (863计划) (批准号: 0000000, 0000000, 00000000) 和
%%% 国家重点基础研究发展计划 (973计划) (批准号: 0000000, 0000000, 00000000) 资助项目
\Foundation{}

%%% 页眉中的作者信息 \AuthorMark{第一作者等}
%%% 若只有一个作者去掉"等"
\AuthorMark{姓名等}

%%% 引用中的作者信息 \AuthorCitation{第一作者, 第二作者, 第三作者, 等}
%%% 少于三个作者去掉"等"
\AuthorCitation{姓名, 姓名}

\maketitle

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% 摘要和关键词
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%% 中文摘要
\abstract{
	本文提出了一种用于求解第二届国际护士排班竞赛中提出的多阶段护士排班问题的带权禁忌搜索算法. 该算法使用了~$3$~种互斥的简单邻域结构与~$1$~种复合邻域结构, 并根据其适应性动态调整搜索各邻域的概率, 同时通过调整各护士的惩罚权重来实现搜索过程中集中性与疏散性的平衡. 为了应对各个独立的阶段缺乏全局信息的问题, 提出了一种对全局约束的近似评估策略. 算法还针对自适应的邻域选择策略, 以减少多种邻域的整体计算开销为目标设计了邻域评估的缓存策略, 进一步提升了算法的执行效率. 算法在竞赛使用的~$60$~个算例上的计算结果表明, 本算法生成合法解的频率为~$100\%$~, 证明了算法的可用性, 同时在绝大多数算例上求得的最优值与所有参赛者求得的最优值的差距低于~$15\%$~, 证明了算法的有效性. 此外, 本文对算法中的关键要素进行了对比分析, 证明了这些组成部分的方案选择和参数设置的合理性.
}

%%% 英文摘要
\enabstract{
	This paper proposes a weighted tabu search algorithm for solving multistage nurse rostering problem given by the Second International Nurse Rostering Competition. The algorithm employs $3$ simple neighborhood structure which are exclusive to each other and $1$ compound one. The possibilities of selecting each neighborhood to search are adjusted by their adaptiveness dynamically, as well as the weight of penalty on each nurse, which leads to the balance between intensification and diversification during the search procedure. To tackle the problem of lacking global information within each independent stages, we proposed an approximate evaluation strategy for spanning constraints. The algorithm employs cache for neighborhood move with the purpose of reducing overall cost of evaluation on every neighborhood aimming at the adaptive neighborhood selection strategy, which improves the efficiency of the algorithm even more. The benchmark result on $60$ instances of the algorithm from the competition indicates that, the frequency of generating feasible solution is $100\%$ which means high availability. Also, from the view of optima found, the gap between the best result of all participants and ours on almost all instances is less than $15\%$, which shows good solving quality. Furthermore, we compares and analyzes some key factors in the algorithm and proves their rationality.
}


%%% 中文关键词, \keywords{...\quad ...\quad ...\quad ...\quad ...}
%%% 多个关键词之间用\quad隔开
%%% 要求5-8个, 请尽量补充EI数据库中的受控词为关键词, 谢谢!
\keywords{护士排班\quad 禁忌搜索\quad 时刻表规划\quad 人员排班\quad 元启发式\quad 组合优化}

%%% 英文关键词, \enkeywords{..., ..., ..., ..., ...}
%%% 非专有名词全部小写, 与中文对应
\enkeywords{nurse rostering, tabu search, timetabling, personnel scheduling, metaheuristic, combinatorial optimization}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% 正文部分
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{引言}

随着医疗行业的发展, 医院拥有了越来越多的医务人员、医疗设备和病房, 同时也面临了更多的病人. 于是, 更合理地利用各种资源来为更多的病人提供更好的服务的重要性正日益凸显. 在众多资源当中, 医护人员起到了支配性作用, 无疑是优化资源利用率的关键因素. 所以, 合理的人员排班显得尤为重要. 适当的工作量可以保证病人的病情不被延误, 同时可以保证医务人员有足够的休息时间, 以保持较高的工作效率.

作为一个具体的人员排班问题, 护士排班问题需要给出每天每个班次有哪些护士需要上班, 即一个人员排班表. 该排班表必须满足多种硬约束, 如各班次各岗位的人数达到需求下限、避免不合理的排班模式以及一个护士在同一天只能排一个班次等. 同时, 排班表还应尽量满足工作量上限、连续工作天数上下限、周末工作天数上限以及护士的特殊需求等软约束~\upcite{cheang2003nurse,burke2004state,de2011categorisation}~.

由于每天每班次每岗位上班的护士可以从拥有该岗位所需技能的护士中任意挑选, 其人员选择已经具有组合数级别的复杂度, 同时对整个排班周期进行排班又需要指数级别的复杂度来完成. 此外, 众多的软约束之间相互作用, 此消彼涨. 因此, 护士排班问题无论是对医院的管理人员还是学者来说, 都是一个极其复杂的问题, 对其进行求解优化是一项艰巨的挑战.

护士排班问题在近几十年来得到了广泛的研究, 而最近十年研究尤为深入. 在众多求解算法中, 主要有精确算法和启发式算法两大类别. 精确算法有~Isken~等和~Glass~等分别在文献~\cite{isken2004implicit}~和~\cite{glass2010nurse}~中使用的整数规划方法, 以及~Beli{\"e}n~等在文献~\cite{belien2008branch}~中提出的分支定价方法. 此外, ~He~等在~\cite{he2012constraint}~中使用列生成算法对护士排班问题进行了建模与求解.

另一方面, 启发式算法也得到了众多研究者的关注.
Burke~等在~\cite{burke1999hybrid}~中提出了针对护士排班问题的混合禁忌搜索, 之后又相继提出了模因算法~\upcite{burke2001memetic}~、变邻域搜索~\upcite{burke2004variable,burke2008hybrid}~、分散搜索~\upcite{burke2010scatter}~和变深度搜索~\upcite{burke2013time}~来求解护士排班问题.
此外, 针对护士排班问题还有众多解决方案, 例如
~Bai~等在~\cite{bai2010hybrid}~中提出的混合进化算法、
~Anwar~等在~\cite{anwar2014hyper}~中提出的超启发式算法以及
~Huang~等在~\cite{huang2014evolutionary}~中提出的进化算法.

由于护士排班问题是从实际应用中提炼出来的问题, 不同医院的不同需求导致该问题长期以来没有统一的问题定义与算例, 因此难以比较各种算法的优劣. 于是, 由鲁汶大学的~CODeS~课题组主办的护士排班竞赛~\upcite{haspeslagh2014first,ceschia2015second}~应运而生. 在第一届护士排班竞赛\footnote{官方网站为 http://www.kuleuven-kulak.be/nrpcompetition . }中,
~Valouxis~等在~\cite{valouxis2012systematic}~中提出的整数规划与局部搜索相结合的混合算法、
~Burke~等在~\cite{burke2014new}~中提出的分支定价算法以及
~L{\"u}~等在~\cite{lu2012adaptive}~中提出的自适应邻域搜索算法分别证明了其有效性.

由于医院对医护人员的需求量具有不确定性, 周期较长的排班很容易因工作量的变化而需要重新调整. 因此, 第二届护士排班竞赛\footnote{官方网站为 http://mobiz.vives.be/inrc2/ . }除了保留了传统的约束之外, 还将整个排班周期划分成多个较短的阶段, 对当前阶段进行排班时无法得知后续阶段的人员需求, 同时无法更改先前阶段的排班计划. 在这种情况下, 仍然需要考虑平衡所有护士在整个排班周期中的工作量.

本文提出的算法为针对第二届护士排班竞赛而设计的多阶段、多邻域的带权禁忌搜索. 首先, 该算法在计算目标函数值时给每个护士设置了不同的权重, 该权重根据当前解的改进潜力动态调整. 在当前解还有改进空间时, 算法将提升集中性, 将所有护士设置成相同的权重, 对原始目标函数进行优化; 在一定迭代次数没有改进最优解时, 算法将增强疏散性, 调整权重对软约束违反较多的护士进行针对性优化. 其次, 算法使用了多种结构和复杂度均不相同的邻域动作, 并根据邻域动作的效果动态调整探索各邻域的概率. 此外, 算法对复杂邻域动作的增量评估结果进行了缓存, 有效减少了重复计算. 最后, 算法设计了辅助目标函数与全局约束的估算策略, 以实现对跨阶段约束的优化.

本文接下来的部分将按如下结构组织. 第二章对第二届护士排班竞赛的问题模型进行简要的描述. 第三章对带权禁忌搜索进行详细的介绍和分析. 第四章将带权禁忌搜索与其他方法进行比较, 证明其有效性. 第五章对算法计算结果和竞赛结果进行深入的分析和讨论. 最后一章对全文进行总结.


\section{问题定义}

本文讨论的护士排班问题的优化目标是在满足人员需求的情况下尽可能地平衡护士的工作强度, 以提升医院的效益. 每一天有若干时间段不同的班次, 如早班和夜班. 一个护士拥有若干技能, 如某一个护士掌握了护士长和普通护士两个技能. 为了表述的方便, 将一天中任意一个班次与任意一个技能的组合称作一个时间槽. 例如, 如果有早班和晚班两个班次, 以及护士长和普通护士两个技能, 那么每天就有~(早班, 护士长)~、~(晚班, 护士长)~、~(早班, 普通护士)~和~(晚班, 普通护士)~一共~$4$~个时间槽. 该问题将给出固定数量的护士、排班周期的长度以及每天每个时间槽的人数需求, 要求得出一个排班计划, 确定每天每个时间槽安排哪些护士上班, 即确定是否安排一个护士在某一天上班, 如上班, 该护士使用其掌握的哪个技能上哪一个班. 此外, 整个排班周期被划分为多个阶段, 依次对各阶段进行排班. 在对某一阶段进行排班时, 无法修改先前阶段的排班, 也无法获知后续阶段的需求信息, 只有特殊的边界信息（历史）能从前一个阶段传递到后一阶段. 该排班计划必须满足若干硬约束, 同时尽可能减少对各项软约束的违反.
每个护士有一份工作合同, 合同详细规定了工作强度的最佳范围. 工作强度包括总工作天数、周末工作天数、连续工作天数、连续相同班次数以及连续休息天数等指标. 此外, 每个护士可以请求在指定的日期不为其排班.

整个周期由~$t$~个长度相等的连续且不重叠的阶段组成.
令~$D$~为排班周期中各天组成的集合, ~$D_i$~为阶段~$i$~中各天的集合, ~$D = D_1 \cup D_2 \cup ... \cup D_t $~;
~$N$~为护士的集合;
~$H$~为班次的集合;
~$K$~为技能的集合;
~$X^H_i$~为一个~$ |D_i| \times |N|$~的矩阵, 用于表示各护士在阶段~$i$~中各天被安排至哪个班次, 其中, 休息（~ShiftOff~）可以看作一个特殊的班次;
~$X^K_i$~为一个~$ |D_i| \times |N|$~的矩阵, 用于表示各护士在阶段~$i$~中各天使用哪个技能上安排的班次;
~$X^H_i$~和~$X^K_i$~共同构成了阶段~$i$~的解向量~$X_i$~, 整个排班周期的解向量为~$X$~, ~$X = [X_1, X_2, ..., X_t]$~.

该问题一共有~4~个必须满足的硬约束：

\begin{itemize}
	\item $\mathbf{H_1.}$ \textbf{单一指派约束. } 每个护士每天最多只能被安排到一个时间槽. 在本文提出的解向量的表示方式下, 该硬约束将自动满足.
	
	\item $\mathbf{H_2.}$ \textbf{人数下限约束. } 每天每个时间槽的排班人数不能小于其人数需求的最小值.
	
	\item $\mathbf{H_3.}$ \textbf{后继约束. } 同一个护士连续两天的排班不能出现禁止的模式. 例如, 一个护士在某天上了夜班, 则第二天不能再安排上早班.
	
	\item $\mathbf{H_4.}$ \textbf{技能约束. } 安排到某个时间槽的护士必须具备对应的技能. 例如, 安排在~(早班, 护士长)~的护士必须具备护士长的技能.
\end{itemize}

此外, 还有~8~个应尽量避免违反的软约束：

\begin{itemize}
	\item $\mathbf{S_1.}$ \textbf{最优人数约束. } 每天每个时间槽安排的护士数量不得小于给定的最优值. 每缺少一个护士都要受到~1~个单位的惩罚.
	
	\item $\mathbf{S_2.}$ \textbf{连续工作日约束. } 每个护士的连续工作天数必须在给定的区间内, 每个超出或不足的工作日都要受到~1~个单位的惩罚.
	
	\item $\mathbf{S_3.}$ \textbf{连续相同班次约束. } 每个护士被连续安排到同一班次的天数必须在给定的区间内, 每个超出或不足的工作日都要受到~1~个单位的惩罚.
	
	\item $\mathbf{S_4.}$ \textbf{连续休息约束. } 每个护士的连续休息天数必须在给定的区间内, 每个超出或不足的休息日都要受到~1~个单位的惩罚.
	
	\item $\mathbf{S_5.}$ \textbf{工作偏好约束. } 如果一个护士请求不在某天某班次上班, 但仍然被安排在该天该班次上班, 将受到~1~个单位的惩罚.
	
	\item $\mathbf{S_6.}$ \textbf{完整周末约束. } 如果一个护士的合同规定其应有完整的周末, 则其在周末的排班必须是两天均上班或者两天均休息, 否则将受到~1~个单位的惩罚.
	
	\item $\mathbf{S_7.}$ \textbf{总排班数约束. } 每个护士在整个排班周期中的总工作天数必须在给定的区间内, 每个超出或不足的工作日都要受到~1~个单位的惩罚.
	
	\item $\mathbf{S_8.}$ \textbf{总周末排班数约束. } 每个护士在整个排班周期中被排班了的周末总数不得大于给定的最大值, 每超出一个周末都要受到~1~个单位的惩罚. 其中周六或周日任意一天被排班则本周周末排班数记为~$1$~, 否则为~$0$~.
\end{itemize}

其中~$\mathbf{S_7}$~与~$\mathbf{S_8}$~为横跨整个排班周期的约束, 而其他约束可以在各阶段完成计算. 另外, 除了~$\mathbf{H_2}$~与~$\mathbf{S_1}$~是与时间槽相关的约束, 其它约束只针对单个护士, 不同护士之间没有影响.
问题的求解目标为, 在整个排班周期结束时, 各阶段的解向量~$X$~满足硬约束~$\mathbf{H_1}$~到~$\mathbf{H_4}$~, 同时使违反软约束~$\mathbf{S_1}$~到~$\mathbf{S_8}$~受到的惩罚最小.
假设软约束~$\mathbf{S_i}$~的惩罚之和为~$f_i(X)$~, 权重系数为~$c_i$~, 则合法解~$X$~的目标函数~$f(X)$~如公式~\ref{eq1}~所示.
\begin{equation}
f(X) = \sum_{i=1}^{8} c_i \times f_i(X)
\label{eq1}
\end{equation}

已知数据主要包括场景、需求和历史~3~类.

场景信息为应用于所有阶段的共同数据, 其规定了排班周期的长度, 即阶段数, 可能出现的班次和技能, ~$\mathbf{H_3}$~中涉及的非法后继班次的模式, 不同种类的合同的内容, 以及有哪些可供调度的护士与他们签订的合同类型. 其中合同规定了~$\mathbf{S_2}$~到~$\mathbf{S_4}$~中涉及的连续天数的上下限、~$\mathbf{S_6}$~中涉及的是否要求有完整周末、~$\mathbf{S_7}$~中涉及的总排班数区间以及~$\mathbf{S_8}$~中涉及的总周末排班数上限.

需求信息仅作用于单个阶段, 其中包括用于判断~$\mathbf{H_2}$~和~$\mathbf{S_1}$~的违反程度的人数需求, 即一阶段中每天每个时间槽的最低和最优护士数量, 以及~$\mathbf{S_5}$~中描述的护士请假要求.

历史信息即从前一阶段传递给后一阶段的数据, 用于评估跨阶段约束的违反情况. 典型的历史信息包含各护士的累计排班数、累计周末排班数、上阶段最后一天的排班、上阶段最后的连续排班天数与连续休息天数等. 求解器的实现者也可以将任意可获取的数据以自定义格式保存供后续阶段使用.

具体数据格式以及各约束在边界情况下的处理请参考竞赛的问题描述文档~\upcite{ceschia2015second}~.


\section{带权禁忌搜索}
\label{sec:implement}

\subsection{算法流程概览}

护士排班问题的求解过程将按阶段依次执行, 直到覆盖整个排班周期. 如算法~\ref{alg1}~所示, 每个阶段以场景信息~$Scenario$~、上阶段的历史信息~$h_i$~与本阶段的需求信息~$Weekdata_i$~为输入, 调用带权禁忌搜索算法, 输出本阶段的解向量~$X_i$~与供下阶段使用的历史信息~$h_{i+1}$~. 在本次竞赛中, 排班周期以周为单位划分阶段, 通常为~4~周或~8~周, 且参赛者只需设计实现一周排班的求解算法, 由竞赛组织者重复调用该算法来完成整个周期所有阶段的排班.

\begin{algorithm}
	\footnotesize
	\caption{护士排班问题求解过程}
	\label{alg1}
	\begin{algorithmic}
		\REQUIRE $\textrm{算例数据}~Scenario, InitialHistory, Weekdata$;
		\ENSURE $\textrm{求得的最优排班计划}~X$;
		\STATE $h_0 \Leftarrow InitialHistory$;
		\STATE $i \Leftarrow 0$;
		\WHILE{$i < t$}
		\STATE $X_i \Leftarrow \textrm{WeightedTabuSearch}(Scenario, h_i, Weekdata_i)$;  // 见算法~\ref{alg2}
		\STATE $h_{i+1} \Leftarrow \textrm{GenerateHistory}(Scenario, h_i, X_i)$;
		\STATE $i \Leftarrow i+1$;
		\ENDWHILE
	\end{algorithmic}
\end{algorithm}

求解过程的核心是带权禁忌搜索算法, 其伪代码如算法~\ref{alg2}~所示. 其中~$w$~为对某个护士计算软约束违反情况时惩罚的权重系数. 算法首先产生一个合法的初始解作为当前解, 然后交替使用相同的权重和根据惩罚分布情况进行调整后的权重对当前解进行改进, 改进的过程使用了一种多邻域禁忌搜索. 接下来将详细介绍用于单个阶段求解的算法实现细节.

\begin{algorithm}
	\footnotesize
	\caption{求解护士排班问题的带权禁忌搜索算法框架}
	\label{alg2}
	\begin{algorithmic}
		\REQUIRE $\textrm{算例数据}~Scenario, History, Weekdata$;
		\ENSURE $\textrm{求得的本阶段的最优排班计划}~X_i$;
		\STATE $X_i \Leftarrow \textrm{GenerateInitialSolution}()$;  // 见 ~\ref{subsec:init}~节
		\REPEAT
			\STATE $\textrm{ResetWeight}(w)$;  // 见 ~\ref{subsec:weight}~节
			\STATE $s \Leftarrow \textrm{TabuSearch}(s, w)$;  // 见~\ref{sec:tabusearch}~节算法~\ref{alg3}
			\STATE $X_i \Leftarrow \textrm{min}\{ s, X_i \}$;
			\STATE $s \Leftarrow \textrm{SelectRandomly}(s, X_i)$; 	// 按概率随机选择一个
			\STATE $w \Leftarrow \textrm{AdjustWeightToBiasNurseWithGreaterPenalty}(s)$;  // 见 ~\ref{subsec:weight}~节
			\STATE $s \Leftarrow \textrm{TabuSearch}(s, w)$;  // 见~\ref{sec:tabusearch}~节算法~\ref{alg3}
		\UNTIL{满足停止条件}
	\end{algorithmic}
\end{algorithm}

\subsection{初始解生成}
\label{subsec:init}

初始解的生成使用了贪心构造的方法, 从阶段的第一天到最后一天依次确定排班计划. 对于每一天~$d$~, 统计每个技能~$k$~对护士的总最低需求量~$r_{d,k} = \sum_{h \in H} \textrm{MinDemand}(d, h, k)$~, 其中~MinDemand~函数表示第~$d$~天时间槽~$(h, j)$~的人数下限. 然后根据其与拥有该技能的护士数~$n$~的比例确定先排哪个技能的所有班次. 如果~$r/n$~小, 说明该技能的排班比较容易满足, 可以放到后面排; 反之说明拥有该技能的护士人手短缺, 应该优先考虑. 算法将从~$r/n$~比较小的技能开始, 按顺序确定当天各班次的人员安排. 对于每个时间槽, 在保证不违反硬约束的情况下, 优先挑选拥有技能数更少的护士, 这样做可以照顾到还未排班的技能.

由于本算法中的贪心构造方法比较简单, 可能出现生成了非法解的情况, 因此在贪心构造之后还需要对解进行修复. 该修复过程与算法~\ref{alg3}~的过程相同, 只是目标函数中所有软约束的权重~$c_i$~被设置为~0, 而硬约束变得可以违反, 并具有一定的权重.

\subsection{邻域结构}
\label{subsec:neighbor}

对于一个给定的解向量~$X$~, 可以通过对其施加一个动作得到一个新的解向量~$X'$, 这个新的解向量称为~$X$~的邻域解, 使~$X$~变为某个邻域解~$X'$~的变换称为邻域动作~$m$~,
令作用于~$X$~的邻域动作的集合为~$M(X)$~;
~C~为布尔表达式到整数的转换函数, 如果所给布尔表达式为真取~$1$~, 否则取~$0$~.
则对于护士排班问题可以定义如下邻域结构.

\begin{itemize}
	\item \textbf{增加排班. } 安排原本在第~$d$~天休息的护士~$n$~在第~$d$~天班次~$h$~技能~$k$~上班. 该邻域动作的集合为
	\begin{equation}
	M_1(X) = \{ m_1(d, n, h, k) | \forall d \in D, \forall n \in N, \forall h \in H, \forall k \in K, x^H\phantom{}_{d,n} = \textrm{ShiftOff} \wedge h \ne \textrm{ShiftOff} \}
	\label{eq2}
	\end{equation}
	
	\item \textbf{减少排班. } 安排原本在第~$d$~天上班的护士~$n$~在第~$d$~天休息. 该邻域动作的集合为
	\begin{equation}
	M_2(X) = \{ m_2(d, n) | \forall d \in D, \forall n \in N, x^H\phantom{}_{d,n} \ne \textrm{ShiftOff} \}
	\label{eq3}
	\end{equation}
	
	\item \textbf{变更排班. } 安排原本在第~$d$~天班次~$x^H\phantom{}_{d,n}$~技能~$x^K\phantom{}_{d,n}$~上班的护士~$n$~在第~$d$~天班次~$h$~技能~$k$~上班. 该邻域动作的集合为	
	\begin{align}
		M_3(X) = \{ m_3(d, n, h, k) | & \forall d \in D, \forall n \in N, \forall h \in H, \forall k \in K, x^H\phantom{}_{d,n} \ne \textrm{ShiftOff} \wedge h \ne \textrm{ShiftOff} \nonumber \\
		 & \wedge ( x^H\phantom{}_{d,n} \ne h \vee x^K\phantom{}_{d,n} \ne k ) \}
		\label{eq4}
	\end{align}
	
	\item \textbf{交换排班. } 即块交换. 交换两个护士~$n_1$~和~$n_2$~在第~$d_1$~到~$d_2$~天的排班. 该邻域动作的集合为
	\begin{equation}
	M_4(X) = \{ m_4(d_1, d_2, n_1, n_2) | \forall d_1, d_2 \in D, \forall n_1, n_2 \in N, d_1 \le d_2 \wedge ( \sum_{d=d_1}^{d_2} \textrm{C}( x^H\phantom{}_{d,n_1} \ne x^H\phantom{}_{d,n_2} ) ) > 0 \}
	\label{eq5}
	\end{equation}
\end{itemize}

四种邻域结构中, 增加、减少和变更排班的复杂度相对较小, 而交换排班的复杂度较大. 虽然多个前三种邻域动作的组合可以构成块交换的邻域动作, 但局部搜索每一步通常选择能够改进目标函数的邻域动作, 可能错过可以产生更大改进的组合动作. 例如, 交换两个护士在某一天的排班时, 可以等效成连续执行两个变更排班邻域动作. 考虑这个组合动作整体对目标函数值的改变, 可能是有较大改进的, 但是先单考虑其中一个护士的变更班次时, 会发现原班次的最优人数等约束的违反导致解的质量变差了, 于是该变更班次不会被执行, 从而导致组合动作不会被考虑. 另一方面, 如果将复杂的邻域动作分解为若干个简单的邻域动作, 其中间状态可能违反硬约束. 例如将交换两个护士在某一天的排班分解为先后变更两个护士的排班, 可能出现先变更一个护士的排班后原时间槽的人数小于最低需求的情况.
因此, 交换排班作为前三种邻域动作组合而成的复合邻域结构, 具有极其重要的意义.

\subsection{多邻域禁忌搜索}
\label{sec:tabusearch}

多邻域禁忌搜索是带权禁忌搜索算法的核心模块. 如算法~\ref{alg3}~所示, 该过程首先将选中各种邻域的概率初始化为相同值, 然后将禁忌表初始化为允许所有邻域动作执行的状态. 接下来循环执行邻域搜索过程. 在循环体中, 首先按概率在~$M_1$~到~$M_4$~中选择一个邻域~$n$~, 然后对~$n$~中的所有动作进行评估, 计算其对目标函数值的改变量. 选出最优的邻域动作~$m$~之后，更新相关的禁忌表项, 然后执行该邻域动作. 最后根据该邻域动作的优度更新下一次迭代中各邻域被选中的概率. 接下来将介绍上述过程的具体实现.

\begin{algorithm}
	\footnotesize
	\caption{多邻域禁忌搜索算法伪代码}
	\label{alg3}
	\begin{algorithmic}
		\REQUIRE $\textrm{初始解}~s^0, \textrm{各护士的惩罚权重}~w$;
		\ENSURE $\textrm{求得的当前权重下本阶段的最优排班计划}~s$;
		\STATE $s \Leftarrow s^0$
		\STATE $\textrm{InitializeNeighborhoodSelectionPossibility}(p)$;
		\STATE $\textrm{InitializeTabuList}(t)$;  // 见 ~\ref{subsec:tabu}~节
		\REPEAT
		\STATE $n \Leftarrow \textrm{SelectNeighborhood}(p)$;  // 见 ~\ref{subsec:select}~节
		\STATE $m \Leftarrow \textrm{FindBestNeighborhoodMove}(s, n, t)$;
		\STATE $\textrm{UpdateTabuList}(s, t)$;  // 见 ~\ref{subsec:tabu}~节
		\STATE $s \Leftarrow \textrm{ApplyNeighborhoodMove}(s, m)$;
		\STATE $\textrm{UpdateNeighborhoodSelectionPossibility}(p, n, m)$;  // 见 ~\ref{subsec:select}~节
		\UNTIL{满足停止条件}
	\end{algorithmic}
\end{algorithm}

\subsubsection{邻域选择策略}
\label{subsec:select}

由于存在~4~种结构不同的邻域, 局部搜索每一步选择邻域动作时都对所有邻域进行探索开销过大, 因此每次只选择一个邻域进行评估. 于是, 邻域的选择策略的设计对算法性能的提升起到了至关重要的作用.

本算法采用了轮盘赌的策略, 每种邻域~$M_i$~都有一定的概率~$p_i$~被选中, 所有邻域被选中的概率和满足~$\sum_{i=1}^4 p_i = 1$~. 在禁忌搜索的每一次迭代中, 都会在所有邻域中挑选一个邻域进行搜索, 寻找具有最大改进的邻域动作.

概率~$p_i$~由相应权重~$\omega_i$~来控制, ~$p_i = \omega_i / \sum_{i=1}^4 \omega_i$~. 在搜索过程中, 算法将根据邻域~$M_i$~的表现动态调整其权重~$\omega_i$~. 每一次搜索某一邻域寻找最优动作时, 会出现该最优动作改进了本轮搜索的最优解、改进了当前解、没有改进当前解以及不存在合法动作这~$4$~种情况之一. 这~$4$~种情况反映了该邻域对当前搜索过程的适应性, 表明了对解向量产生改进的程度. 很显然, 应该让更合适的邻域以更大的概率被选择, 因此本算法设置了~$4$~个基准值~$\Omega_1$~到~$\Omega_4$~, 分别与~$4$~种适应程度相对应, 每执行一个邻域动作都将根据其效果向对应的基准值趋近. 具体的调整策略为
\begin{equation}
\omega_i =
\begin{cases}
\omega_i + (\Omega_1 - \omega_i) / \lambda_1 & , m_i \textrm{改进了本轮搜索的最优解} \\
\omega_i + (\Omega_2 - \omega_i) / \lambda_2 & , m_i \textrm{改进了当前解} \\
\omega_i + (\Omega_3 - \omega_i) / \lambda_3 & , m_i \textrm{没有改进当前解但存在合法动作} \\
\omega_i + (\Omega_4 - \omega_i) / \lambda_4 & , m_i \textrm{不存在合法动作} \\
\end{cases}
\end{equation}
其中~$\lambda \in [1, +\infty )$~控制~$\omega$~向基准值趋近的速度. 在其定义域内, ~$\lambda$~越小收敛速度越快.

\subsubsection{禁忌策略}
\label{subsec:tabu}

本算法局部搜索中为避免搜索过程陷入局部最优陷阱采用了禁忌搜索. 禁忌策略的关键因素为禁忌表的设计和禁忌步长的设置, 由于禁忌步长的选取较为简单, 本节将详细介绍禁忌表的设计.

禁忌搜索的核心思想在于记录已搜索过的解的特征或已执行过的邻域动作的特征, 防止搜索路径在局部最优附近绕圈, 甚至原路返回落回局部最优.
本算法对排班情况进行了记录, 如果某一迭代步执一个在第~$d$~天休息的护士~$n$~被安排上班, 那么在接下来的若干迭代步数内, 将不能对护士~$n$~执行第~$d$~天的减少排班动作, 即不能在第~$d$~天被重新安排为休息;
如果某一迭代步一个在第~$d$~天班次~$h$~技能~$k$~上班的护士~$n$~被安排为休息或者在其他班次或技能上班, 那么在接下来的若干迭代步数内, 护士~$n$~将不能被重新安排在第~$d$~天的时间槽~$(h,k)$~上班.

具体来说, 本算法中使用了两个禁忌表. 禁忌表~$T^D$~是一个~$N \times D$~的矩阵, 如果~$T^D\phantom{}_{n,d}$~大于当前迭代步数表示禁止护士~$n$~在第~$d$~天被安排为休息. 禁忌表~$T^H$~是一个~$N \times D \times H \times K$~的矩阵, ~$T^H\phantom{}_{n,d,h,k}$~大于当前迭代步数表示禁止护士~$n$~被安排在第~$d$~天时间槽~$(h,k)$~上班.
对于~$M_4$~这种复合邻域结构, 需要将其分解为~$M_1$~至~$M_3$~的组合, 再针对每个动作查询或设置禁忌表. 在判断一个给定的块交换是否被禁忌时, 有~$4$~种策略, 它们分别为：总是允许、只要有一个非禁忌的子动作就允许、只要有一个子动作被禁忌则禁止以及被禁忌的子动作超过一定比例则禁止. 由于~$M_4$~邻域较大, 再加上多种动作交替选择, 其陷入局部最优的可能性相对较小, 同时为了方便增量评估缓存的设计（见~\ref{subsec:cache}~节）, 本算法总是认为~$M_4$~是非禁忌的.

\subsubsection{缓存策略}
\label{subsec:cache}

由于护士排班问题软约束众多, 目标函数计算过程十分复杂. 对于较大的邻域, 邻域评估的运算量更加庞大. 分析禁忌搜索算法每次只对当前解做小幅改动的特性, 可知每次执行一个邻域动作后, 大多数其他邻域动作对目标函数的影响并未发生变化. 因此, 本算法使用了缓存机制, 将邻域动作导致的目标函数的增量保存起来, 加速邻域评估过程.

本算法中有多种邻域结构, 而搜索过程中每次只挑选一个进行评估, 如果对所有邻域都进行缓存, 可能会导致较高的缓存失效率, 从而降低命中率, 并增加缓存维护的开销. 下面将分析各种缓存策略的利弊, 最终得出本算法使用的缓存策略.

对于~$M_1$~至~$M_3$~, ~$M_1$~至~$M_4$~中所涉及的护士的所有~$M_1$~至~$M_4$~缓存全部失效, 同时由于~$\mathbf{S_1}$~的存在, 动作添加或删除排班的时间槽中所有其他护士的~$M_1$~至~$M_4$~在该时间槽的缓存全部失效. 如果以时间槽为粒度对缓存有效性进行标记, 会导致每次邻域动作需要对该护士的所有时间槽进行设置, 时间复杂度为~$O(n)$~; 如果以护士为粒度, 每次邻域动作只需对一个标记位进行设置, 时间复杂度为~$O(1)$~, 仅考虑单个邻域时, 能带来一定的性能提升.

对于~$M_4$~, ~$M_1$~至~$M_4$~中所涉及的护士的所有~$M_1$~至~$M_4$~的缓存全部失效. 由于两个护士交换不会改变各时间槽的人数, 所以~$M_1$~至~$M_4$~并不会通过~$\mathbf{S_1}$~影响其他护士的~$M_4$~缓存. 如果以护士为粒度对缓存有效性进行标记, 则每次邻域动作的执行只会导致不超过~$2$~个缓存项失效, 即可以在~$O(1)$~的时间复杂度内更新标记位.

再对算法的性能瓶颈进行分析, 可知对~$M_1$~至~$M_3$~中单个邻域动作的增量评估虽然逻辑复杂, 但其时间复杂度仍为~$O(D)$~, 而对~$M_4$~中单个邻域动作进行评估的时间复杂度则为~$O(N^2 \times D^3)$~, 远大于其他邻域的复杂度, 对其进行缓存将极大地减少重复计算, 对该邻域进行缓存是非常有必要的. 但是由上面的分析可以看出, 所有邻域动作都会影响其他邻域动作的缓存, 随着缓存类型的增多, 相互影响将被放大. 会有更多缓存在被再次利用之前就已经失效, 让缓存的维护产生更多无用功.

因此, 经过对各种策略的开销与收益的综合分析, 本算法仅对~$M_4$~以护士为粒度对缓存有效性进行标记, 对两个护士的任意起止天的块交换中的最优值进行缓存.

\subsection{惩罚权重调整策略}
\label{subsec:weight}

禁忌搜索是一个集中性较强的算法, 为了增加算法的疏散性, 本算法引入了每个护士的惩罚权重. 由于问题中的连续工作和连续休息等软约束的存在, 打破当前的排班模式的代价往往很大, 很有可能在对解向量产生结构性改变之前就因为惩罚的急剧增长而落回原来的排班布局, 或者一直在相似的排班之间做小幅改进. 针对这种情况, 本算法通过降低惩罚较少的护士的权重, 削弱对次优排班模式进行大幅调整的惩罚, 防止搜索陷入局部最优而无法探索更广阔的解空间.

护士惩罚权重的具体调整过程为, 在全部护士中, 选择惩罚少的~$r_1 \times |N|$~个护士, 将其权重设为~$W_1$~, 然后再在剩余护士中, 随机选择~$r_2 \times |N|$~个护士, 将其权重设为~$W_2$~, 再将剩下的护士的权重设为~$W_3$~. 其中有~$0 < W_1 < W_2 < W_3, r_1, r_2 \in [0, 1], r_1 + r_2 < 1$~. 该调整过程的伪代码如算法~\ref{alg4}~所示. 由于~$\mathbf{S_1}$~是针对时间槽的约束, 无法针对单个护士计算其在该约束上的惩罚, 故统计护士的惩罚情况时未考虑该软约束.

\begin{algorithm}
	\footnotesize
	\caption{惩罚权重调整过程}
	\label{alg4}
	\begin{algorithmic}
		\REQUIRE $\textrm{护士集合}~N, \textrm{某个护士当前惩罚的计算函数}~f$;
		\ENSURE $\textrm{护士的惩罚权重}~w$;
		\STATE $n \Leftarrow \textrm{SortNurseByPenalty}(N, f)$;  // $n$ is the sequence of nurses sorted by their penalties in an ascending order
		\STATE $i \Leftarrow 1$;
		\WHILE{$i < |N| \times r_1$}
			\STATE $w_{n_i} \Leftarrow W_1$;
			\STATE $i \Leftarrow i + 1$;
		\ENDWHILE
		\WHILE{$i < |N|$}
			\STATE $w_{n_i} \Leftarrow W_3$;
			\STATE $i \Leftarrow i + 1$;
		\ENDWHILE
		\STATE $i \Leftarrow 1$;
		\WHILE{$i < |N| \times r_2$}
			\STATE $j \Leftarrow \textrm{SelectNurseRandomly}(N)$;
			\IF{$w_j = W_3$}
				\STATE $w_j \Leftarrow W_2$;
				\STATE $i \Leftarrow i + 1$;
			\ENDIF
		\ENDWHILE
	\end{algorithmic}
\end{algorithm}


\subsection{全局约束的近似评估}
\label{subsec:global}

软约束~$\mathbf{S_7}$~和~$\mathbf{S_8}$~属于评估整个排班周期的约束, 只有当求解最后一个阶段的排班时才能被准确计算, 但是如果先前阶段排班不考虑这些约束的话, 会严重影响最终全周期的排班效果, 甚至导致后续某阶段无法找到满足硬约束的排班计划. 因此, 在各阶段内部需要一个近似评估机制来估算本阶段的排班会对全局约束~$\mathbf{S_7}$~和~$\mathbf{S_8}$~造成多大的影响. 本算法在两个部分使用了近似评估策略, 其一是在计算本阶段的目标函数时, 根据各护士的总排班数上下限、历史排班数和本阶段人员需求等因素估算本阶段排班对~$\mathbf{S_7}$~和~$\mathbf{S_8}$~的贡献; 其二是在更新最优解时, 根据本阶段的排班情况设计辅助目标函数, 处理目标函数值相同的情况下最优解的取舍. 本节将对这两种策略进行详细介绍.

首先, 对于~$\mathbf{S_7}$~和~$\mathbf{S_8}$~的上限, 本算法采用了均匀分配剩余排班数的处理方案. 令~$A_n$~为护士~$n$~当前阶段之前的历史累积排班数, 总排班数下限为~$A^L_n$~, 上限为~$A^U_n$, 则可以按如下公式计算护士~$n$~在第~$i$~个阶段的排班数上限~$A^U\phantom{}_{n,i}$~
\begin{equation}
A^U\phantom{}_{n,i} = (A^U_n - A_n) \times \frac{i}{T}
\end{equation}
相比于绝对均匀分配各阶段的排班数, 该方法更具灵活性, 即如果前期需求不多, 则中后期会放松该约束, 剩余排班数较多的护士可以更多地排班; 如果前期需求过多, 则中后期会收紧该约束, 保证最终排班数不会超出上限太多.

其次, 本算法对~$\mathbf{S_7}$~中总排班数下限的处理为在整个排班周期的前期若干阶段忽略该约束. 由于合同规定的总排班数下限是针对整个排班周期的, 而在开始的几个阶段中累积需求并不多, 所以该约束很容易被违反. 另外, 因为连续性约束~$\mathbf{S_2}$~至~$\mathbf{S_4}$~的存在, 各护士的排班可能出现不均衡的状态, 即在最初的几个阶段里, 某些护士排班比较满, 另外一些护士休息比较多. 介于上述两种情况, 在排版周期的前期阶段就考虑~$\mathbf{S_7}$~的下限会鼓励算法增加总排班量, 这样易导致后期护士的总排班数大幅超出合同规定的上限. 因此, 本算法将根据~$A^L_n / A^U_n$~确定从第几个阶段开始考虑. 具体来说, 对于总共有~$T$~个阶段的排班周期, 将按如下规则计算护士~$n$~在第~$i$~个阶段的排班数下限~$A^L\phantom{}_{n,i}$~
\begin{equation}
A^L\phantom{}_{n,i} =
\begin{cases}
0 & , i < T \times \frac{A^L_n}{A^U_n} \\
(A^L_n - A_n) \times \frac{i}{T} & , i \ge T \times \frac{A^L_n}{A^U_n} \\
\end{cases}
\end{equation}

最后, 考虑到对护士的需求往往超过了合同规定的工作量上限, 本算法中辅助目标函数的设计以优先选择排班数较少的方案为目标, 保证在不影响本阶段求解质量的情况下, 尽可能地为后续阶段预留人力资源. 对于两个目标函数值相同的解向量, 可能因为其对违反约束的组成的不同而对后续阶段的排班产生不同的影响. 例如, 有的排班可能对总排班数上限违反较多, 而对主要在本阶段内部发生作用的连续性约束和覆盖性约束违反很少, 这种排班会对后续阶段产生较大的负面影响, 反之, 可以给后续阶段留出更多的调整空间. 因此, 本算法中辅助目标函数将更倾向于保留总排班数较少的解. 其具体的计算方法为
\begin{equation}
f'(X) = \sum_{n=1}^{N} \frac{\sum_{d=1}^{D} \textrm{C}(X^H\phantom{}_{d,n} \ne \textrm{ShiftOff})}{A^U_n - A_n}
\end{equation}
其中求和式的分子部分为本阶段排班的累计排班数. 由于不同护士的总排班数上限不同, 辅助目标函数并不是直接统计所有护士的总排班数, 而是统计各护士当前排班数占剩余排班数的比例之和, 保证排班的均衡性.

\section{计算结果}

\subsection{算例与运行环境}

第二届国际护士排班竞赛的算例包括初赛的~$14$~个数据集和决赛的~$6$~个数据集. 所有数据集均由~$1$~个场景信息文件、~$3$~个初始历史信息文件和~$10$~个阶段需求信息文件组成. 对于每个数据集, 数据规模主要与护士数相关, 而数据集中的护士数主要分布于~$30$~到~$120$~之间. 具体运行时从中选取~$1$~个场景信息文件、~$1$~个初始历史信息文件和~$4$~个或~$8$~个阶段需求信息文件构成一个算例, 这些文件按算法~\ref{alg1}~所示的流程依次输入求解程序. 求解护士排班问题得到的目标函数值越小说明解向量的质量越好. 本次竞赛使用的算例\footnote{数据集和算例可在 http://mobiz.vives.be/inrc2/?page\_id=20 下载. }与排名\footnote{决赛排名可在 http://mobiz.vives.be/inrc2/?page\_id=241 查看. }已公布于竞赛官方网站.

本算法使用~C++~编写, 由~Visual C++ 2013~编译. 程序的运行环境为~Windows Server 2012~操作系统, ~Intel Xeon E5-2609 2.5GHz CPU~, ~32GB~内存. 运行时间由竞赛官方网站提供的基准测试程序\footnote{基准测试程序可在 http://mobiz.vives.be/inrc2/?page\_id=245 下载}求得, 其给定的运行时间与护士数量成正比.

由于相同的数据集使用不同的文件序列可以构成大量算例, 而随意挑选的序列不便于进行对比, 本节将仅对决赛使用的算例进行测试. 为了防止启发式算法的求解过程的随机性使结果出现较大偏差, 竞赛组织者将每个算例独立重复运行了~$10$~次, 而本文讨论与分析中使用了每个算例独立重复运行~$32$~次的统计结果.

\subsection{第二届国际护士排班竞赛结果对比}

\begin{table}[!t]
	\footnotesize
	\cnentablecaption{小规模算例计算结果}{Computational result on small scale instances}
	\label{tab1}
	\tabcolsep 10pt %space between two columns. 用于调整列间距
	\begin{tabular*}{\textwidth}{c|ccc|cc}
		\toprule
		Instance & Known best & Our best & Winner's best & Our Average & Winner's Average \\\hline
		n035w4\_2\_8-8-7-5         & 1255 & 1335 & 1255 & 1370.5 & 1367.5 \\
		n035w4\_0\_1-7-1-8         & 1630 & 1685 & 1630 & 1756.5 & 1630 \\
		n035w4\_0\_4-2-1-6         & 1800 & 1970 & 1810 & 2021.5 & 1831.5 \\
		n035w4\_0\_5-9-5-6         & 1755 & 1760 & 1755 & 1834.5 & 1755 \\
		n035w4\_0\_9-8-7-7         & 1540 & 1660 & 1545 & 1723.5 & 1586 \\
		n035w4\_1\_0-6-9-2         & 1500 & 1650 & 1525 & 1737 & 1545 \\
		n035w4\_2\_8-6-7-1         & 1490 & 1600 & 1510 & 1644.5 & 1510 \\
		n035w4\_2\_9-2-2-6         & 1705 & 1895 & 1705 & 1947.5 & 1708 \\
		n035w4\_2\_9-7-2-2         & 1650 & 1940 & 1650 & 1970.5 & 1695 \\
		n035w4\_2\_9-9-2-1         & 1620 & 1880 & 1620 & 1927.5 & 1652 \\
		n035w8\_0\_6-2-9-8-7-7-9-8 & 3020 & 3505 & 99999 & 3628 & 99999 \\
		n035w8\_1\_0-8-1-6-1-7-2-0 & 2770 & 3405 & 2900 & 3653.5 & 12669.4 \\
		n035w8\_1\_0-8-4-0-9-1-3-2 & 2775 & 3190 & 2870 & 3378.5 & 80576.7 \\
		n035w8\_1\_1-4-4-9-3-5-3-2 & 2805 & 3180 & 2810 & 3325 & 2849.5 \\
		n035w8\_1\_7-0-6-2-1-1-1-6 & 2840 & 3440 & 2840 & 3548.5 & 2842 \\
		n035w8\_2\_2-1-7-1-8-7-4-2 & 2910 & 3445 & 3050 & 3672 & 90304.1 \\
		n035w8\_2\_7-1-4-9-2-2-6-7 & 2960 & 3540 & 2960 & 3632.5 & 3028.5 \\
		n035w8\_2\_8-8-7-5-0-0-6-9 & 2815 & 3385 & 2815 & 3603 & 2863 \\
		n035w8\_2\_9-5-6-3-9-9-2-1 & 3045 & 3350 & 3045 & 3533.5 & 3083.5 \\
		n035w8\_2\_9-7-2-2-5-7-4-3 & 2715 & 3295 & 2865 & 3488 & 2928 \\
		\bottomrule
	\end{tabular*}
\end{table}

\begin{table}[!t]
	\footnotesize
	\cnentablecaption{中等规模算例计算结果}{Computational result on medium scale instances}
	\label{tab2}
	\tabcolsep 10pt %space between two columns. 用于调整列间距
	\begin{tabular*}{\textwidth}{c|ccc|cc}
		\toprule
		Instance & Known best & Our best & Winner's best & Our Average & Winner's Average \\\hline
		n070w4\_0\_3-6-5-1         & 2700 & 3090 & 2705 & 3151 & 2723 \\
		n070w4\_0\_4-9-6-7         & 2430 & 2790 & 2430 & 2889 & 2446 \\
		n070w4\_0\_4-9-7-6         & 2475 & 2865 & 2475 & 2948 & 2557.5 \\
		n070w4\_0\_8-6-0-8         & 2435 & 2855 & 2435 & 3016 & 2477 \\
		n070w4\_0\_9-1-7-5         & 2320 & 2725 & 2320 & 2864 & 2323 \\
		n070w4\_1\_1-3-8-8         & 2700 & 3035 & 2700 & 3134.5 & 2728 \\
		n070w4\_2\_0-5-6-8         & 2520 & 2880 & 2520 & 3012 & 2533 \\
		n070w4\_2\_3-5-8-2         & 2615 & 3050 & 2615 & 3141.5 & 2635 \\
		n070w4\_2\_5-8-2-5         & 2540 & 2875 & 2540 & 3005.5 & 2544.5 \\
		n070w4\_2\_9-5-6-5         & 2615 & 2975 & 2615 & 3046 & 2652 \\
		n070w8\_0\_3-3-9-2-3-7-5-2 & 5115 & 6000 & 5115 & 6222 & 5164 \\
		n070w8\_0\_9-3-0-7-2-1-1-0 & 5390 & 6420 & 5390 & 6602 & 5478.5 \\
		n070w8\_1\_5-6-8-5-7-8-5-6 & 5475 & 6095 & 5475 & 6236.5 & 5549 \\
		n070w8\_1\_9-8-9-9-2-8-1-4 & 5100 & 5700 & 5100 & 6018.5 & 5167 \\
		n070w8\_2\_4-9-2-0-2-7-0-6 & 5410 & 5990 & 5410 & 6259 & 5581.5 \\
		n070w8\_2\_5-1-3-0-8-0-5-8 & 5280 & 5975 & 5280 & 6315 & 5359.5 \\
		n070w8\_2\_5-7-4-8-7-2-9-9 & 5505 & 6210 & 5505 & 6317.5 & 5531.5 \\
		n070w8\_2\_6-3-0-1-8-1-5-9 & 5120 & 5960 & 5120 & 6255 & 5240 \\
		n070w8\_2\_8-6-0-1-6-4-7-8 & 5350 & 6205 & 5350 & 6492.5 & 7138.5 \\
		n070w8\_2\_9-3-5-2-2-9-2-0 & 5320 & 5895 & 5320 & 6044.5 & 5374 \\
		\bottomrule
	\end{tabular*}
\end{table}

\begin{table}[!t]
	\footnotesize
	\cnentablecaption{大规模算例计算结果}{Computational result on large scale instances}
	\label{tab3}
	\tabcolsep 10pt %space between two columns. 用于调整列间距
	\begin{tabular*}{\textwidth}{c|ccc|cc}
		\toprule
		Instance & Known best & Our best & Winner's best & Our Average & Winner's Average \\\hline
		n110w4\_0\_1-4-2-8         & 2710 & 3395 & 2720 & 3539 & 2725 \\
		n110w4\_0\_1-9-3-5         & 2920 & 3475 & 2970 & 3663 & 3065 \\
		n110w4\_1\_0-1-6-4         & 2850 & 3685 & 2920 & 3769 & 12690.4 \\
		n110w4\_1\_0-5-8-8         & 2820 & 3440 & 2895 & 3569.5 & 3210 \\
		n110w4\_1\_2-9-2-0         & 3345 & 3995 & 3380 & 4092 & 3425 \\
		n110w4\_1\_4-8-7-2         & 2805 & 3515 & 2805 & 3661 & 2855.5 \\
		n110w4\_2\_0-2-7-0         & 3005 & 3795 & 3175 & 3903.5 & 51625.5 \\
		n110w4\_2\_5-1-3-0         & 2925 & 3520 & 3025 & 3637.5 & 3095 \\
		n110w4\_2\_8-9-9-2         & 3415 & 3895 & 3470 & 4025 & 3502.5 \\
		n110w4\_2\_9-8-4-9         & 3135 & 3640 & 3335 & 3769 & 3540 \\
		n110w8\_0\_2-1-1-7-2-6-4-7 & 5155 & 6420 & 5165 & 6596 & 5243 \\
		n110w8\_0\_3-2-4-9-4-1-3-7 & 4805 & 6015 & 4830 & 6172.5 & 4982.5 \\
		n110w8\_0\_5-5-2-2-5-3-4-7 & 4750 & 6065 & 4870 & 6227 & 4939 \\
		n110w8\_0\_7-8-7-5-9-7-8-1 & 4855 & 6105 & 5005 & 6251.5 & 5234 \\
		n110w8\_0\_8-8-0-2-3-4-6-3 & 4465 & 5920 & 4955 & 6146.5 & 5021.5 \\
		n110w8\_0\_8-8-2-2-3-2-0-8 & 4865 & 6310 & 5435 & 6469 & 5510.5 \\
		n110w8\_1\_0-6-1-0-3-2-9-1 & 5090 & 6330 & 5175 & 6514 & 5259.5 \\
		n110w8\_1\_4-1-3-6-8-8-1-3 & 4315 & 5925 & 4785 & 6115.5 & 4842.5 \\
		n110w8\_2\_2-9-5-5-1-8-4-0 & 4770 & 5840 & 5200 & 6222.5 & 5274 \\
		n110w8\_2\_8-5-7-3-9-8-8-5 & 4360 & 5540 & 4765 & 5809 & 5292 \\
		\bottomrule
	\end{tabular*}
\end{table}

本算法在决赛中取得了第四名的成绩. 相比于其他进入决赛的队伍, 前两名在大多数算例上保持了一定的优势, 但是都存在无法于给定时间内求得合法解的情况, 其中第一名的算法在组委会提供的环境下进行的~$600$~次运行中, 有~$34$~次产生了非法解, 而本算法均能产生合法解, 故本算法在稳定性上与前两名相比有一定的优势.
%由于本次竞赛的排名方案并未对产生非法解的情况施加严格的惩罚机制, 前两名凭借在大多数算例上积累的巨大优势保持了其领先地位.

决赛中一共使用了三种规模的数据集, 小规模、中等规模和大规模算例的计算结果分别如表~\ref{tab1}~、表~\ref{tab2}~和表~\ref{tab3}~所示, 表格的内容为目标函数值. 对于求出非法解的情况, 竞赛组委会将其目标函数值设为一个大于所有参赛者所求目标函数值的数值, 在本次竞赛中为~$99999$~. 从结果对比可以看出, 本算法的最优解质量离第一名均有一定差距, 但是本算法对不同算例的适应性更好, 而第一名的算法在算例~n035w8\_0\_6-2-9-8-7-7-9-8~上~$10$~次运行均没有求出合法解, 同时在多个算例上产生了非法解, 导致其在这些算例上的平均求解质量不如本算法.


\section{分析与讨论}

第~\ref{sec:implement}~节中描述了算法的关键模块和策略, 本节将对本算法使用的策略与其他可能的策略进行对比分析, 以阐明选择这些方案的原因.

\subsection{邻域结构效果对比分析}

\begin{figure}[!t]
	\centering
	\begin{minipage}[c]{0.48\textwidth}
		\centering
		\begin{tikzpicture}
		\begin{axis}[
		title={},
		xlabel={Iteration (~$\log_ai$~times)},
		ylabel={Best objective value found so far}, y label style={at={(0.05,0.5)}},
		xmin=0, xmax=100,
		ymin=0, ymax=25000,
		xtick={0,20,40,60,80,100},
		ytick={0,5000,10000,15000,20000,25000},
		legend pos=north east,
		ymajorgrids=true,
		grid style=dashed,
		width = \textwidth,% height = 3in,
		]
		
		\addplot[
		color=blue,
		style=solid,
		%mark=square, % triangle, diamond, o, *, x, +, asterisk
		]
		coordinates {
			(0,7285.75) (1,7184.19) (2,7099.34) (3,6979.97) (4,6864.81)
			(5,6767.94) (6,6676.22) (7,6579.97) (8,6473.47) (9,6345.66)
			(10,6250.34) (11,6133) (12,6049) (13,5963.22) (14,5858.69)
			(15,5776.81) (16,5697.28) (17,5592.03) (18,5517.22) (19,5428.03)
			(20,5355.31) (21,5294.63) (22,5224.47) (23,5147.78) (24,5086.38)
			(25,5032.69) (26,4964.09) (27,4893.31) (28,4821.44) (29,4764.72)
			(30,4710.03) (31,4642.06) (32,4577.28) (33,4514.94) (34,4470.56)
			(35,4417.28) (36,4351.66) (37,4299.94) (38,4253.53) (39,4198.34)
			(40,4150.44) (41,4112.38) (42,4073.84) (43,4046.97) (44,4012.56)
			(45,3977.72) (46,3936.78) (47,3880.84) (48,3833.75) (49,3795)
			(50,3754.47) (51,3717.28) (52,3598.66) (53,3405.53) (54,3262.47)
			(55,3115.06) (56,2952.09) (57,2800.22) (58,2640.53) (59,2470.38)
			(60,2245.41) (61,2095.56) (62,1963.69) (63,1819.97) (64,1684.88)
			(65,1577.56) (66,1511.38) (67,1457.41) (68,1394.13) (69,1360.63)
			(70,1330.94) (71,1298.06) (72,1268.69) (73,1252.16) (74,1230.31)
			(75,1217.97) (76,1197.16) (77,1175.44) (78,1164.66) (79,1152.88)
			(80,1132.78) (81,1124.59) (82,1116.69) (83,1100.91) (84,1090.13)
			(85,1075.38) (86,1063.19) (87,1054.38) (88,1041.31) (89,1026.16)
			(90,1017.88) (91,1001.63) (92,989.031) (93,970.219) (94,956.781)
			(95,945.906) (96,931.75) (97,920.938) (98,909.969) (99,901)
		};
		\addplot[
		color=black,
		style=solid,
		%mark=triangle,
		]
		coordinates {
			(0,16523.8) (1,16402) (2,16258.2) (3,16113.1) (4,15977.4)
			(5,15781) (6,15587.9) (7,15413.2) (8,15252.4) (9,15158.1)
			(10,15031) (11,14916.4) (12,14773.8) (13,14642.1) (14,14502.1)
			(15,14378.2) (16,14246.9) (17,14127.5) (18,14011.9) (19,13907.3)
			(20,13780.4) (21,13675.9) (22,13578.8) (23,13487.8) (24,13414.2)
			(25,13320.8) (26,13226.2) (27,13129.6) (28,13046.6) (29,12966.9)
			(30,12888.5) (31,12813.8) (32,12725.6) (33,12647.2) (34,12572.3)
			(35,12502.5) (36,12419.2) (37,12332.1) (38,12267.3) (39,12194.5)
			(40,12140.6) (41,12061.4) (42,11999.5) (43,11923) (44,11853.3)
			(45,11788.8) (46,11724.6) (47,11670.3) (48,11598.7) (49,11525.9)
			(50,11466.3) (51,11401.5) (52,11219.9) (53,10947.2) (54,10696.6)
			(55,10408.3) (56,10107.5) (57,9812.75) (58,9467.47) (59,9128.09)
			(60,8781.25) (61,8449.38) (62,8104.19) (63,7729.5) (64,7404.19)
			(65,7018.88) (66,6565.5) (67,6136.47) (68,5705) (69,5238.31)
			(70,4792.63) (71,4377.06) (72,4033.44) (73,3674.22) (74,3376.41)
			(75,3171.19) (76,3025.16) (77,2923.72) (78,2843.56) (79,2793.44)
			(80,2737.56) (81,2680.84) (82,2640.53) (83,2610.03) (84,2578.22)
			(85,2542.88) (86,2521.41) (87,2494.25) (88,2464.41) (89,2437.59)
			(90,2406.31) (91,2385.75) (92,2369.19) (93,2340.38) (94,2315.47)
			(95,2295.94) (96,2279.63) (97,2263.72) (98,2245.06) (99,2227.03)
		};
		\addplot[
		color=red,
		style=solid,
		%mark=triangle,
		]
		coordinates {
			(0,24220.7) (1,24106.3) (2,23968) (3,23864.7) (4,23734.6)
			(5,23564.9) (6,23428.8) (7,23304.7) (8,23159.4) (9,22996.9)
			(10,22828.8) (11,22651.6) (12,22491.3) (13,22318.6) (14,22157.8)
			(15,22046.6) (16,21907.3) (17,21792) (18,21675.7) (19,21527.5)
			(20,21393.6) (21,21256.1) (22,21149.6) (23,21039.5) (24,20918.7)
			(25,20786.8) (26,20657.9) (27,20543.3) (28,20429.7) (29,20315.3)
			(30,20193.7) (31,20088.4) (32,20011.1) (33,19899.4) (34,19788.6)
			(35,19675.6) (36,19576.9) (37,19490.3) (38,19395.6) (39,19317.9)
			(40,19239.9) (41,19137.7) (42,19058) (43,18958.1) (44,18866.7)
			(45,18760.3) (46,18675.7) (47,18597.1) (48,18509.3) (49,18418.5)
			(50,18315.3) (51,18226.2) (52,18010.2) (53,17640.3) (54,17353.8)
			(55,17017) (56,16621.8) (57,16237.3) (58,15869.9) (59,15459.5)
			(60,14961.9) (61,14565) (62,14107.9) (63,13632.7) (64,13154.5)
			(65,12648.9) (66,12154.1) (67,11565.1) (68,10944.9) (69,10265.6)
			(70,9655.25) (71,9044.38) (72,8372.78) (73,7658.25) (74,6958.56)
			(75,6241) (76,5643.75) (77,5051.34) (78,4483.91) (79,3928.69)
			(80,3522.34) (81,3196.59) (82,3035.59) (83,2934.28) (84,2863.41)
			(85,2799.59) (86,2741.97) (87,2704.19) (88,2666.41) (89,2626.81)
			(90,2609.97) (91,2571.59) (92,2543.13) (93,2522.56) (94,2498.53)
			(95,2473.63) (96,2459.38) (97,2442.13) (98,2431.5) (99,2418.09)
		};
		\addplot[
		color=blue,
		style=dashed,
		%mark=square, % triangle, diamond, o, *, x, +, asterisk
		]
		coordinates {
			(0,7122.88) (1,6973.25) (2,6795.75) (3,6629.28) (4,6498.66)
			(5,6321.63) (6,6149.09) (7,5970.31) (8,5816.06) (9,5658.41)
			(10,5509.28) (11,5388.09) (12,5246.97) (13,5111.19) (14,4987.16)
			(15,4857.53) (16,4745.88) (17,4631.72) (18,4513.47) (19,4415.91)
			(20,4313.06) (21,4226.03) (22,4115.78) (23,4012.41) (24,3912.91)
			(25,3841.78) (26,3776.63) (27,3690.28) (28,3613.81) (29,3536)
			(30,3473.75) (31,3411.44) (32,3341.91) (33,3272.13) (34,3202.38)
			(35,3151.59) (36,3086.81) (37,3032.38) (38,2977.5) (39,2920.31)
			(40,2866) (41,2807.91) (42,2755.41) (43,2704.19) (44,2650.91)
			(45,2598.28) (46,2547.5) (47,2505.19) (48,2462.94) (49,2419.75)
			(50,2377.25) (51,2331.78) (52,2209.03) (53,2005.88) (54,1861.53)
			(55,1713.84) (56,1552.56) (57,1401.66) (58,1282.75) (59,1151.25)
			(60,1030.06) (61,921.094) (62,839.219) (63,768.844) (64,728.281)
			(65,698.125) (66,676.594) (67,652.344) (68,639.438) (69,626.156)
			(70,614.063) (71,601.875) (72,592.156) (73,573.625) (74,560.313)
			(75,553.969) (76,545.719) (77,538.594) (78,534.063) (79,524.594)
			(80,517.781) (81,511.906) (82,502.938) (83,499.656) (84,492.375)
			(85,487.969) (86,482.188) (87,479.813) (88,477) (89,471.75)
			(90,469.188) (91,466.281) (92,463.625) (93,460.5) (94,458.094)
			(95,456.438) (96,453.219) (97,449.688) (98,447.188) (99,445.938)
		};
		\addplot[
		color=black,
		style=dashed,
		%mark=triangle,
		]
		coordinates {
			(0,16574) (1,16303.3) (2,16053.3) (3,15891.7) (4,15644.1)
			(5,15466.4) (6,15218.9) (7,14969.3) (8,14705.3) (9,14467.7)
			(10,14208.8) (11,13952.1) (12,13746.6) (13,13537.6) (14,13325.2)
			(15,13125.8) (16,12944.3) (17,12735.8) (18,12567) (19,12412.2)
			(20,12229.7) (21,12074.7) (22,11899.8) (23,11692) (24,11539.5)
			(25,11394) (26,11267.1) (27,11108.2) (28,10974.9) (29,10836.1)
			(30,10722.5) (31,10559.6) (32,10409.2) (33,10276.4) (34,10142)
			(35,10026.7) (36,9893.13) (37,9768.91) (38,9647.91) (39,9498.69)
			(40,9393.72) (41,9280.94) (42,9177.91) (43,9073) (44,8993.84)
			(45,8904.44) (46,8793.66) (47,8704.75) (48,8618.44) (49,8529.03)
			(50,8437.06) (51,8333.41) (52,8077.81) (53,7647.03) (54,7332.59)
			(55,6983.56) (56,6555.63) (57,6206.28) (58,5893.34) (59,5530.75)
			(60,5173.06) (61,4822.31) (62,4484.06) (63,4180.69) (64,3847.22)
			(65,3531.66) (66,3241.31) (67,2966.47) (68,2737.16) (69,2503.5)
			(70,2308.78) (71,2080.78) (72,1889.69) (73,1699.72) (74,1590.31)
			(75,1524.84) (76,1480.25) (77,1460.84) (78,1445.06) (79,1432.31)
			(80,1415.16) (81,1408.75) (82,1398.78) (83,1390.22) (84,1380.06)
			(85,1374.22) (86,1367.97) (87,1360.75) (88,1356) (89,1348.72)
			(90,1344.19) (91,1338.84) (92,1333.44) (93,1323.44) (94,1318.41)
			(95,1316.38) (96,1313.72) (97,1308.72) (98,1302.69) (99,1300.09)
		};
		\addplot[
		color=red,
		style=dashed,
		%mark=triangle,
		]
		coordinates {
			(0,24208.9) (1,23981.2) (2,23801.8) (3,23628.8) (4,23388.3)
			(5,23181) (6,22974.9) (7,22721.8) (8,22520.3) (9,22286)
			(10,22036.3) (11,21835) (12,21655.3) (13,21457.4) (14,21256)
			(15,21008.6) (16,20804.8) (17,20606.2) (18,20414.5) (19,20203.3)
			(20,20025.2) (21,19821.5) (22,19622.1) (23,19449.1) (24,19286.8)
			(25,19111.3) (26,18919.2) (27,18727.6) (28,18546.3) (29,18391.5)
			(30,18251) (31,18117.6) (32,17948.1) (33,17788.4) (34,17600.5)
			(35,17443.3) (36,17284.3) (37,17122.3) (38,16996.1) (39,16859.9)
			(40,16702.9) (41,16574.3) (42,16440.8) (43,16313.9) (44,16203.8)
			(45,16077.2) (46,15956.2) (47,15834.1) (48,15722.9) (49,15605.1)
			(50,15450.3) (51,15334.7) (52,15021) (53,14495.8) (54,14126.3)
			(55,13645.6) (56,13113.9) (57,12610.6) (58,12112.4) (59,11554.4)
			(60,10997.8) (61,10441.1) (62,9836.59) (63,9303.31) (64,8771.88)
			(65,8191.22) (66,7608.59) (67,7032.72) (68,6492.84) (69,6000.13)
			(70,5444.31) (71,4944.22) (72,4476.34) (73,3952.25) (74,3508.47)
			(75,3079.53) (76,2663.16) (77,2287.19) (78,1997.84) (79,1880.5)
			(80,1836.06) (81,1815.66) (82,1795.47) (83,1779.69) (84,1766.31)
			(85,1736.53) (86,1716.34) (87,1702.09) (88,1676.66) (89,1657.78)
			(90,1639.81) (91,1611.5) (92,1593.53) (93,1564.63) (94,1535.66)
			(95,1513.09) (96,1496.75) (97,1481.47) (98,1469.22) (99,1454.75)
		};
		\legend{S$-M_4$, M$-M_4$, L$-M_4$, S$+M_4$, M$+M_4$, L$+M_4$}
		
		\end{axis}
		\end{tikzpicture}
	\end{minipage}
	%\hspace{0.04\textwidth}
	\begin{minipage}[c]{0.48\textwidth}
		\centering
		\begin{tikzpicture}
		\begin{axis}[
		title={},
		xlabel={Time (~$\log_at$~seconds)},
		ylabel={Best objective value found so far}, y label style={at={(0.05,0.5)}},
		xmin=0, xmax=100,
		ymin=0, ymax=25000,
		xtick={0,20,40,60,80,100},
		ytick={0,5000,10000,15000,20000,25000},
		legend pos=north east,
		ymajorgrids=true,
		grid style=dashed,
		width = \textwidth,% height = 3in,
		]
		
		\addplot[
		color=blue,
		style=solid,
		%mark=square, % triangle, diamond, o, *, x, +, asterisk
		]
		coordinates {
			(0,7285.75) (1,7184.19) (2,7099.34) (3,6979.97) (4,6864.81)
			(5,6767.94) (6,6676.22) (7,6579.97) (8,6473.47) (9,6345.66)
			(10,6250.34) (11,6133) (12,6049) (13,5963.22) (14,5858.69)
			(15,5776.81) (16,5697.28) (17,5592.03) (18,5517.22) (19,5428.03)
			(20,5355.31) (21,5294.63) (22,5224.47) (23,5147.78) (24,5086.38)
			(25,5032.69) (26,4964.09) (27,4893.31) (28,4821.44) (29,4764.72)
			(30,4710.03) (31,4642.06) (32,4577.28) (33,4514.94) (34,4470.56)
			(35,4417.28) (36,4351.66) (37,4283.38) (38,4081.97) (39,3758.53)
			(40,3474.28) (41,3233.78) (42,2979.81) (43,2534.59) (44,2098.16)
			(45,1831.63) (46,1638.69) (47,1523.97) (48,1415.78) (49,1307.53)
			(50,1240.13) (51,1188.19) (52,1162.25) (53,1125.63) (54,1103.66)
			(55,1077.13) (56,1056.25) (57,1041.47) (58,1026) (59,1004.34)
			(60,987.625) (61,969.813) (62,952.906) (63,939.594) (64,931.938)
			(65,917.469) (66,905.125) (67,896.469) (68,886.813) (69,878.531)
			(70,864.844) (71,859.844) (72,854.75) (73,841.156) (74,829.656)
			(75,824.5) (76,808.406) (77,804.25) (78,796.25) (79,781.969)
			(80,771.281) (81,754.75) (82,739.188) (83,725.813) (84,716.594)
			(85,711) (86,708.75) (87,699.094) (88,691.969) (89,684.844)
			(90,681.875) (91,676.5) (92,670.031) (93,663.375) (94,659)
			(95,656.188) (96,653.375) (97,650.875) (98,646.656) (99,644.344)
		};
		\addplot[
		color=black,
		style=solid,
		%mark=triangle,
		]
		coordinates {
			(0,16523.8) (1,16402) (2,16258.2) (3,16113.1) (4,15977.4)
			(5,15781) (6,15587.9) (7,15413.2) (8,15252.4) (9,15158.1)
			(10,15031) (11,14916.4) (12,14773.8) (13,14642.1) (14,14502.1)
			(15,14378.2) (16,14246.9) (17,14127.5) (18,14011.9) (19,13907.3)
			(20,13780.4) (21,13675.9) (22,13578.8) (23,13487.8) (24,13414.2)
			(25,13320.8) (26,13226.2) (27,13129.6) (28,13046.6) (29,12966.9)
			(30,12888.5) (31,12813.8) (32,12725.6) (33,12647.2) (34,12572.3)
			(35,12502.5) (36,12419.2) (37,12332.1) (38,12267.3) (39,12194.5)
			(40,12079.2) (41,11864.5) (42,11508.2) (43,10739) (44,10019.3)
			(45,9286.47) (46,8663.28) (47,8075.22) (48,7555.16) (49,6779.81)
			(50,6081) (51,5422.16) (52,4663.63) (53,4059.47) (54,3588.28)
			(55,3193.44) (56,2968.5) (57,2842.66) (58,2757.38) (59,2667.84)
			(60,2603.78) (61,2558.22) (62,2513.06) (63,2472.44) (64,2429.28)
			(65,2397.25) (66,2366.38) (67,2333.66) (68,2311.88) (69,2289.25)
			(70,2268.81) (71,2248.91) (72,2226.19) (73,2210.84) (74,2192.56)
			(75,2174.69) (76,2158.88) (77,2135.75) (78,2120.25) (79,2099.5)
			(80,2083.09) (81,2072) (82,2064.16) (83,2037.66) (84,2025.22)
			(85,2013.97) (86,2001.75) (87,1982.75) (88,1970.97) (89,1954.91)
			(90,1941.84) (91,1925.22) (92,1911.91) (93,1887.91) (94,1874.41)
			(95,1856.41) (96,1838.16) (97,1831.38) (98,1824.94) (99,1816.5)
		};
		\addplot[
		color=red,
		style=solid,
		%mark=triangle,
		]
		coordinates {
			(0,24220.7) (1,24106.3) (2,23968) (3,23864.7) (4,23734.6)
			(5,23564.9) (6,23428.8) (7,23304.7) (8,23159.4) (9,22996.9)
			(10,22828.8) (11,22651.6) (12,22491.3) (13,22318.6) (14,22157.8)
			(15,22046.6) (16,21907.3) (17,21792) (18,21675.7) (19,21527.5)
			(20,21393.6) (21,21256.1) (22,21149.6) (23,21039.5) (24,20918.7)
			(25,20786.8) (26,20657.9) (27,20543.3) (28,20429.7) (29,20315.3)
			(30,20193.7) (31,20088.4) (32,20011.1) (33,19899.4) (34,19788.6)
			(35,19675.6) (36,19576.9) (37,19490.3) (38,19395.6) (39,19317.9)
			(40,19239.9) (41,19137.7) (42,19052.4) (43,18872.5) (44,18417.1)
			(45,17771.6) (46,17133.2) (47,16479) (48,15907.9) (49,15079.6)
			(50,14309) (51,13606.6) (52,12734.9) (53,11938.7) (54,11145.4)
			(55,10164.6) (56,9305.69) (57,8496.38) (58,7625.63) (59,6836.5)
			(60,6005.81) (61,5244.63) (62,4623.59) (63,3967.34) (64,3454.59)
			(65,3161.47) (66,3035.63) (67,2897.81) (68,2788.47) (69,2710.63)
			(70,2650) (71,2621.66) (72,2586) (73,2538.5) (74,2501.25)
			(75,2486.5) (76,2465.41) (77,2444.41) (78,2420.28) (79,2407.28)
			(80,2398.25) (81,2384.28) (82,2368.59) (83,2344.09) (84,2333.31)
			(85,2320.13) (86,2311.78) (87,2306.94) (88,2291.59) (89,2284.81)
			(90,2267.19) (91,2255.78) (92,2243.97) (93,2229.16) (94,2208.16)
			(95,2198.06) (96,2190.91) (97,2178.91) (98,2164.69) (99,2153.91)
		};
		\addplot[
		color=blue,
		style=dashed,
		%mark=square, % triangle, diamond, o, *, x, +, asterisk
		]
		coordinates {
			(0,7122.88) (1,6973.25) (2,6795.75) (3,6629.28) (4,6498.66)
			(5,6321.63) (6,6149.09) (7,5970.31) (8,5816.06) (9,5658.41)
			(10,5509.28) (11,5388.09) (12,5246.97) (13,5111.19) (14,4987.16)
			(15,4857.53) (16,4745.88) (17,4631.72) (18,4513.47) (19,4415.91)
			(20,4313.06) (21,4226.03) (22,4115.78) (23,4012.41) (24,3912.91)
			(25,3841.78) (26,3776.63) (27,3690.28) (28,3613.81) (29,3536)
			(30,3473.75) (31,3411.44) (32,3341.91) (33,3272.13) (34,3202.38)
			(35,3151.59) (36,3086.81) (37,3032.38) (38,2965) (39,2900.63)
			(40,2845.53) (41,2783.22) (42,2710.94) (43,2561.22) (44,2278.72)
			(45,2042.88) (46,1841.84) (47,1691.44) (48,1537.66) (49,1307.66)
			(50,1134.16) (51,1015.38) (52,921.594) (53,856) (54,790.125)
			(55,732.594) (56,674.156) (57,624.25) (58,598.469) (59,584.313)
			(60,559.906) (61,543.844) (62,529.406) (63,516.969) (64,506.75)
			(65,500.188) (66,489.469) (67,484.781) (68,481.344) (69,475.469)
			(70,472.406) (71,468.656) (72,464.75) (73,460.438) (74,457.063)
			(75,452.438) (76,450.25) (77,448) (78,446.625) (79,442.781)
			(80,441.844) (81,441.063) (82,438.531) (83,437.594) (84,436.813)
			(85,435.25) (86,433.531) (87,432) (88,430.938) (89,430.063)
			(90,429.75) (91,429.75) (92,429.125) (93,428.188) (94,428.031)
			(95,427.625) (96,426.531) (97,425.75) (98,425.344) (99,425.031)
		};
		\addplot[
		color=black,
		style=dashed,
		%mark=triangle,
		]
		coordinates {
			(0,16574) (1,16303.3) (2,16053.3) (3,15891.7) (4,15644.1)
			(5,15466.4) (6,15218.9) (7,14969.3) (8,14705.3) (9,14467.7)
			(10,14208.8) (11,13952.1) (12,13746.6) (13,13537.6) (14,13325.2)
			(15,13125.8) (16,12944.3) (17,12735.8) (18,12567) (19,12412.2)
			(20,12229.7) (21,12074.7) (22,11899.8) (23,11692) (24,11539.5)
			(25,11394) (26,11267.1) (27,11108.2) (28,10974.9) (29,10836.1)
			(30,10722.5) (31,10559.6) (32,10409.2) (33,10276.4) (34,10142)
			(35,10026.7) (36,9893.13) (37,9768.91) (38,9647.91) (39,9498.69)
			(40,9393.72) (41,9280.94) (42,9177.91) (43,9073) (44,8993.84)
			(45,8904.44) (46,8793.66) (47,8694.66) (48,8596) (49,8353.31)
			(50,7804.5) (51,7242.88) (52,6525.94) (53,5910.41) (54,5389.44)
			(55,4819.44) (56,4330.5) (57,3899.91) (58,3414.69) (59,3060.88)
			(60,2720.94) (61,2410.5) (62,2117.78) (63,1827.63) (64,1634.88)
			(65,1533.28) (66,1474.88) (67,1445.34) (68,1427.34) (69,1413.59)
			(70,1397.66) (71,1385.31) (72,1375.69) (73,1372.41) (74,1361.63)
			(75,1355.84) (76,1346.38) (77,1341.56) (78,1334.38) (79,1324.53)
			(80,1317.94) (81,1314.34) (82,1311.22) (83,1305.91) (84,1301.25)
			(85,1298.22) (86,1293.81) (87,1292.47) (88,1290.28) (89,1286.94)
			(90,1281.25) (91,1274.03) (92,1269.78) (93,1264.69) (94,1261.25)
			(95,1257.44) (96,1252.22) (97,1247.44) (98,1245.81) (99,1243.63)
		};
		\addplot[
		color=red,
		style=dashed,
		%mark=triangle,
		]
		coordinates {
			(0,24208.9) (1,23981.2) (2,23801.8) (3,23628.8) (4,23388.3)
			(5,23181) (6,22974.9) (7,22721.8) (8,22520.3) (9,22286)
			(10,22036.3) (11,21835) (12,21655.3) (13,21457.4) (14,21256)
			(15,21008.6) (16,20804.8) (17,20606.2) (18,20414.5) (19,20203.3)
			(20,20025.2) (21,19821.5) (22,19622.1) (23,19449.1) (24,19286.8)
			(25,19111.3) (26,18919.2) (27,18727.6) (28,18546.3) (29,18391.5)
			(30,18251) (31,18117.6) (32,17948.1) (33,17788.4) (34,17600.5)
			(35,17443.3) (36,17284.3) (37,17122.3) (38,16996.1) (39,16859.9)
			(40,16702.9) (41,16574.3) (42,16440.8) (43,16313.9) (44,16203.8)
			(45,16077.2) (46,15956.2) (47,15834.1) (48,15722.9) (49,15605.1)
			(50,15450.3) (51,15334.7) (52,15128.9) (53,14592.5) (54,13764.9)
			(55,12749.2) (56,11880.8) (57,11035.3) (58,10084.6) (59,9243.09)
			(60,8411.5) (61,7532.94) (62,6819.56) (63,6154.44) (64,5479.88)
			(65,4824.47) (66,4259.09) (67,3703.72) (68,3184.47) (69,2706.09)
			(70,2265.28) (71,2023.41) (72,1923.06) (73,1853.97) (74,1813.81)
			(75,1793.19) (76,1758.69) (77,1718.22) (78,1694.94) (79,1669.34)
			(80,1641.47) (81,1615.94) (82,1587.41) (83,1555.13) (84,1525.75)
			(85,1509.13) (86,1491.53) (87,1477.5) (88,1462.19) (89,1444.38)
			(90,1434.34) (91,1419.53) (92,1406.09) (93,1394.16) (94,1384.13)
			(95,1374.28) (96,1368.13) (97,1363.41) (98,1356.78) (99,1350.69)
		};
		\legend{S$-M_4$, M$-M_4$, L$-M_4$, S$+M_4$, M$+M_4$, L$+M_4$}
		
		\end{axis}
		\end{tikzpicture}
	\end{minipage}
	\cnenfigcaption{块交换邻域的重要性}{Significance of block swap neighborhood. (a) measursed by iteration; (b) measured by time}
	\label{fig1}
\end{figure}

虽然~$M_4$~理论上可以多个由~$M_1$~至~$M_3$~组合而成, 但是其在本算法中仍起到了至关重要的作用. 图~\ref{fig1}~分别从迭代次数和运行时间两个角度展示了有无~$M_4$~时算法的收敛速度, 所用数据来自于随机挑选的一个小规模算例（n035w4\_2\_8-8-7-5）一个中等规模算例（n070w4\_0\_3-6-5-1）和一个大规模算例（n110w4\_0\_1-4-2-8）的~$32$~次独立运行中对应时间刻度位置取样所得的平均值. 三种规模的算例在图例中从小到大分别用~S~、~M~和~L~表示, 而是否使用~$M_4$~邻域用~$+$~和~$-$~表示. 其横坐标为时间刻度, 纵坐标表示截止当前时间点算法所求得的第~$1$~阶段的最优目标函数值. 由于每次运行分为多个阶段, 所以无法对整个排班周期的目标函数值的收敛情况进行分析. 因此图~\ref{fig1}~中的目标函数值均为第一阶段的近似目标函数值（见~\ref{subsec:global}~节）. 另外, 因为算法初期收敛速度非常快, 而后期目标函数值变化幅度较小, 导致等间隔取样的结果不便于观察比较. 故图中横坐标为对时间刻度取对数的结果, 即~$x= \log_at$~, 其中~$a=1.08$~, ~$t$~为取样的时间点.

从图~\ref{fig1}~中可以看出, 以迭代次数为取样间隔时, 块交换对收敛速度的加速效果尤为明显. 但是由于其时间复杂度较高, 故以秒为取样间隔时加速效果没有那么显著, 但在搜索初期的快速改进阶段和后期的深度搜索阶段仍有较大优势, 且收敛的极限优于没有块交换的情况. 由此可见, 块交换邻域无论从短期的收敛速度来考虑, 还是从长期的目标函数值下限来考虑, 都发挥了重要的积极作用.

\subsection{疏散性搜索策略对比分析}

\begin{table}[!t]
	\footnotesize
	\cnentablecaption{疏散性策略的计算结果对比}{Comparison of computational results between diversification strategies}
	\label{tab4}
	\tabcolsep 3.4pt %space between two columns. 用于调整列间距
	\begin{tabular*}{\textwidth}{c|ccc|ccc}
		\toprule
		\multirow{2}{*}{Instance} & \multicolumn{3}{c|}{Best} & \multicolumn{3}{c}{Average} \\\cline{2-7}
		 & Random walk & Partial rebuild & Adjust weight & Random walk & Partial rebuild & Adjust weight \\\hline
		n035w4\_0\_1-7-1-8         & 1675 & 1705 & 1685 & 1788.91 & 1778.28 & 1747.19 \\
		n035w4\_1\_0-6-9-2         & 1675 & 1650 & 1655 & 1791.56 & 1774.38 & 1747.03 \\
		n035w4\_2\_8-6-7-1         & 1520 & 1575 & 1555 & 1628.28 & 1656.25 & 1635.47 \\
		n035w8\_0\_6-2-9-8-7-7-9-8 & 3410 & 3315 & 3420 & 3665.00 & 3597.03 & 3578.28 \\
		n035w8\_1\_0-8-1-6-1-7-2-0 & 3400 & 3350 & 3370 & 3602.03 & 3616.88 & 3601.88 \\
		n035w8\_2\_2-1-7-1-8-7-4-2 & 3495 & 3420 & 3460 & 3769.84 & 3703.13 & 3682.50 \\
		n070w4\_0\_3-6-5-1         & 3115 & 3025 & 3010 & 3243.44 & 3170.78 & 3154.38 \\
		n070w4\_1\_1-3-8-8         & 3050 & 3040 & 3020 & 3118.75 & 3136.25 & 3128.44 \\
		n070w4\_2\_0-5-6-8         & 2895 & 2815 & 2890 & 3034.69 & 3021.41 & 3015.78 \\
		n070w8\_0\_3-3-9-2-3-7-5-2 & 6140 & 6035 & 5945 & 6415.94 & 6289.53 & 6230.16 \\
		n070w8\_1\_5-6-8-5-7-8-5-6 & 6105 & 5910 & 5940 & 6325.63 & 6219.22 & 6214.22 \\
		n070w8\_2\_4-9-2-0-2-7-0-6 & 6050 & 5865 & 5880 & 6373.44 & 6280.63 & 6210.94 \\
		n110w4\_0\_1-4-2-8         & 3340 & 3400 & 3355 & 3516.72 & 3565.94 & 3527.81 \\
		n110w4\_1\_0-1-6-4         & 3630 & 3615 & 3670 & 3765.31 & 3768.44 & 3794.38 \\
		n110w4\_2\_0-2-7-0         & 3745 & 3720 & 3760 & 3893.13 & 3907.66 & 3925.00 \\
		n110w8\_0\_2-1-1-7-2-6-4-7 & 6255 & 6300 & 6235 & 6595.16 & 6578.59 & 6532.97 \\
		n110w8\_1\_0-6-1-0-3-2-9-1 & 6310 & 6280 & 6270 & 6608.13 & 6512.66 & 6469.69 \\
		n110w8\_2\_2-9-5-5-1-8-4-0 & 5855 & 6115 & 6045 & 6257.34 & 6316.25 & 6300.94 \\
		\bottomrule
	\end{tabular*}
\end{table}

观察目标函数值的组成可以发现, 不同护士的惩罚有一定的差异. 然而由于众多约束相互制约, 可能一旦找到了一个相对合理的排班就很难再进行结构性的调整, 因此~\ref{subsec:weight}~节所述权重调整策略很有可能可以打破既定的排班格局, 为算法提供一个有导向而非盲目的疏散性搜索过程. 为了验证这个猜想, 对随机游走（Random Walk）、使用了保留解向量的部分元素然后对其贪心构造和修复直至重新产生合法解的扰动策略的禁忌搜索（Partial rebuild）和使用了权重调整策略的禁忌搜索（Adjust Weight）三种扰动方式进行了对比测试. 测试对决赛使用的三种规模的算例和两种排班周期的长度各随机选择了~$3$~个算例分别进行了~$32$~次独立的重复计算, 并统计了多次计算得到的目标函数值中的最优值和平均值.

疏散性搜索与集中性搜索不同, 其作用在于提升算法的稳定性而不是提升算法搜索能力的上限. 从表~\ref{tab4}~可以看出, 比较~$32$~次计算求得的最优值, 不同疏散性搜索策略没有显著差异. 而对比平均值却可以发现使用了权重调整策略之后有比较明显的提升, 在~$75\%$~的算例上平均求解质量超过了另外两种扰动策略, 离算法所能求到的下限更加接近. 这说明本算法使用的权重调整策略是一种有效的疏散性搜索策略.

\subsection{全局约束近似评估策略对比分析}

\begin{table}[!t]
	\footnotesize
	\cnentablecaption{全局近似评估策略的计算结果对比}{Comparison of computational results between approximate global constraints evaluation strategies}
	\label{tab5}
	\tabcolsep 4.9pt %space between two columns. 用于调整列间距
	\begin{tabular*}{\textwidth}{c|ccc|ccc}
		\toprule
		\multirow{2}{*}{Instance} & \multicolumn{3}{c|}{Best} & \multicolumn{3}{c}{Average} \\\cline{2-7}
		& Ignore & Even allocation & EA on remainder & Ignore & Even allocation & EA on remainder \\\hline
		n035w4\_2\_8-6-7-1         & 2300 & 1610 & 1540 & 2505.31 & 1705.47 & 1642.81 \\
		n035w8\_0\_6-2-9-8-7-7-9-8 & 4700 & 3485 & 3410 & 5059.84 & 3695.47 & 3574.22 \\
		n070w8\_2\_8-6-0-1-6-4-7-8 & 8305 & 6390 & 6155 & 8725.31 & 6801.72 & 6502.03 \\
		n110w4\_1\_0-1-6-4         & 4930 & 3655 & 3630 & 5532.03 & 3837.50 & 3789.06 \\
		n110w4\_2\_0-2-7-0         & 5175 & 3685 & 3695 & 5693.59 & 3915.31 & 3931.88 \\
		n110w8\_2\_8-5-7-3-9-8-8-5 & 8810 & 5725 & 5565 & 9380.00 & 6047.34 & 5776.56 \\
		\bottomrule
	\end{tabular*}
\end{table}

为了分析全局约束的近似评估策略对算法的影响, 设计对照试验比较了忽略全局约束（Ignore）、采用均分各阶段排班数的策略（Even allocation）和~\ref{subsec:global}~节所述的均匀分配剩余排班数的策略（EA on  remainder）的求解质量. 试验针对了竞赛第一名出现了无法产生合法解的情况或者出现了不理想的计算结果的较难求解的算例分别进行了~$32$~次独立的测试.

从表~\ref{tab5}~可以看出, 完全忽略全局约束效果较差, 无论是从求得的最优解来看还是从多次运行的平均值来看都不如进行了适当考虑的方案. 在使用均匀分配各阶段的总排班数上限之后, 计算结果产生了明显的改进. 可以观察到均匀分配所求得目标函数的平均值已经高于忽略相关约束所能求得的最优值. 更进一步, 均匀分配剩余排班数上限, 使先前阶段的排班的紧凑程度能影响到后续阶段的总排班数合理性评估之后, 计算结果相比于机械地均匀分配又有~$3\%$~左右的改进. 由此可见本算法使用的近似评估策略对跨阶段约束的有效性.


\section{总结}

本文提出了一种用于求解多阶段护士排班问题的启发式算法. 在对第二届国际护士排班竞赛所涉及的问题进行了简要的介绍之后, 本文详细描述了带权禁忌搜索算法. 算法以禁忌搜索为核心, 通过调整护士的惩罚权重来实现搜索过程中集中性与疏散性的平衡. 算法使用了增加班次、减少班次、变更班次和交换班次~$4$~种邻域结构, 并使用了一种根据其适应性动态调整各邻域被选中的概率的策略. 为了解决全局约束无法在单个阶段计算的问题, 算法使用了一种近似评估方案来衡量各阶段的排班对全局约束产生的贡献.
此外, 本文通过对比试验展示了不同邻域结构对收敛速度产生的影响, 得出了权重调整策略对提升求解质量具有重要意义的结论, 证明了全局约束的近似评估策略的合理性.

第二届护士排班竞赛的计算结果充分证明了算法的有效性. 在决赛的~$60$~个算例上, 算法在保证结果合法性的同时, 求解质量也接近目前已知的最优解, 最终在第二届国际护士排班竞赛中获得了全球第~$4$~名的成绩.
但是, 由于算法使用的邻域变化模式比较简单, 对于约束众多的问题, 容易陷入局部最优, 或者难以跨过非法解以探索更广阔的解空间. 因此可以考虑增加更大的邻域, 对解空间进行更充分的探索. 与此同时, 对全局约束的近似评估策略也可以有更细致的考量, 让算法对多阶段问题的求解更接近掌握了整个排班周期的完整信息的理想状态.

值得注意的是, 带权禁忌搜索的思想并不局限于护士排班问题的求解, 其对解向量产生有潜力的结构性改变的能力, 可以在很多组合优化问题中得到应用, 为算法提供有导向的疏散性搜索. 而算法对多阶段问题的求解能力, 更接近大多数问题的现实情况. 对不确定因素和易变因素进行考虑, 将使理论问题更具有实际意义和应用价值.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% 致谢, 非必选
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\Acknowledgements{}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% 补充材料说明, 非必选
%%% 有补充材料时请添加补充材料说明, 例如图S1~S5
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\Supplements{图S1$\sim$S5.}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% 参考文献, {}为引用的标签, 数字/字母均可
%%% 文中上标引用: \upcite{1,2}
%%% 文中正常引用: \cite{1,2}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\bibliography{bib}{}
%\bibliographystyle{plain}
\begin{thebibliography}{99}
	\bibitem{cheang2003nurse}
	Cheang B, Li H B, Lim A, et al.
	 Nurse rostering problems----a bibliographic survey.
	 European Journal of Operational Research, 2003, 151: 447--460
	
	\bibitem{burke2004state}
	Burke E K, De Causmaecker P, Berghe G V, et al.
	 The state of the art of nurse rostering.
	 Journal of scheduling, 2004, 7: 441--499
	
	\bibitem{de2011categorisation}
	De Causmaecker P, Berghe G V.
	 A categorisation of nurse rostering problems.
	 Journal of Scheduling, 2011, 14: 3--16
	
	\bibitem{isken2004implicit}
	Isken M W.
	 An implicit tour scheduling model with applications in healthcare.
	 Annals of Operations Research, 2004, 128: 91--109
	
	\bibitem{glass2010nurse}
	Glass C A, Knight R A.
	 The nurse rostering problem: A critical appraisal of the problem
	structure.
	 European Journal of Operational Research, 2010, 202: 379--389
	
	\bibitem{belien2008branch}
	Beli{\"e}n J, Demeulemeester E.
	 A branch-and-price approach for integrating nurse and surgery
	scheduling.
	 European journal of operational research,
	 2008, 189: 652--668
	
	\bibitem{he2012constraint}
	He F, Qu R.
	 A constraint programming based column generation approach to nurse
	rostering problems.
	 Computers \& Operations Research, 2012, 39: 3331--3343
	
	\bibitem{burke1999hybrid}
	Burke E, De Causmaecker P, Berghe G V.
	 A hybrid tabu search algorithm for the nurse rostering problem.
	 In: Proceedings of Simulated evolution and learning. Berlin: Springer, 1999. 187--194
	
	\bibitem{burke2001memetic}
	Burke E, Cowling P, De Causmaecker P, et al.
	 A memetic approach to the nurse rostering problem.
	 Applied intelligence, 2001, 15: 199--214
	
	\bibitem{burke2004variable}
	Burke E, De Causmaecker P, Petrovic S, et al.
	 Variable neighborhood search for nurse rostering problems.
	 In: Proceedings of Metaheuristics: computer decision-making.
	 Berlin: Springer, 2004. 153--172
	
	\bibitem{burke2008hybrid}
	Burke E K, Curtois T, Post G, et al.
	 A hybrid heuristic ordering and variable neighbourhood search for the	nurse rostering problem.
	 European Journal of Operational Research,
	 2008, 188: 330--341
	
	\bibitem{burke2010scatter}
	Burke E K, Curtois T, Qu R, et al.
	 A scatter search methodology for the nurse rostering problem.
	 Journal of the Operational Research Society,
	 2010, 61: 1667--1679
	
	\bibitem{burke2013time}
	Burke E K, Curtois T, Qu R, et al.
	 A time predefined variable depth search for nurse rostering.
	 INFORMS Journal on Computing, 2013, 25: 411--419
	
	\bibitem{bai2010hybrid}
	Bai R, Burke E K, Kendall G, Li J P, et al.
	 A hybrid evolutionary approach to the nurse rostering problem.
	 Evolutionary Computation, IEEE Transactions on,
	 2010, 14: 580--590
	
	% FORMAT
	\bibitem{anwar2014hyper}
	Anwar K, Awadallah M, Khader A T, et al.
	Hyper-heuristic approach for solving nurse rostering problem.
	 In: Proceedings of Computational Intelligence in Ensemble Learning (CIEL), 2014 IEEE Symposium on, Orlando, 2014. 1--6
	
	\bibitem{huang2014evolutionary}
	Huang H, Lin W J, Lin Z Y, et al.
	 An evolutionary algorithm based on constraint set partitioning for
	nurse rostering problems.
	 Neural Computing and Applications, 2014, 25: 703--715
	
	\bibitem{haspeslagh2014first}
	Haspeslagh S, De Causmaecker P, Schaerf A, et al.
	 The first international nurse rostering competition 2010.
	 Annals of Operations Research, 2014, 218: 221--236
	
	% FORMAT
	\bibitem{ceschia2015second}
	Ceschia S, Dang N T T, De Causmaecker P, et al.
	 Second International Nurse Rostering Competition(INRC-II)---Problem  Description and Rules---[J].
	 arXiv preprint arXiv:1501.04177, 2015
	
	\bibitem{valouxis2012systematic}
	Valouxis C, Gogos C, Goulas G, et al.
	 A systematic two phase approach for the nurse rostering problem.
	 European Journal of Operational Research, 2012, 219: 425--433
	
	\bibitem{burke2014new}
	Burke E K, Curtois T.
	 New approaches to nurse rostering benchmark instances.
	 European Journal of Operational Research, 2014, 237: 71--81
	
	\bibitem{lu2012adaptive}
	L{\"u} Z P, Hao J K.
	 Adaptive neighborhood search for nurse rostering.
	 European Journal of Operational Research, 2012, 218: 865--876
	
%
%% 专著
%% 作者名. 书名. 版次(第一版不用列出). 出版社所在城市名: 出版社名, 出版年份. 起止页码
%\bibitem{1}Gaydon A G, Wolfhard H G. Flames. 2nd ed. London: Chapman and Hall Ltd, 1960. 30--35
%
%% 期刊
%% 作者名. 文章题目(用小写字母). 期刊名, 年份, 卷号: 起止页码
%\bibitem{2}Xu Y B, Shen L S, Susan R M. Extension of the rice DH population genetic map with microsatellite markers. Chin Sci Bull, 1998, 43:149--153
%\bibitem{3}Hutton B. Product of fuzzy topological space. Topology Appl, 1980, 11: 59--61
%\bibitem{4}Wang K J, Zhang J Y, Li D, et al. Adaptive affinity propagation clustering. Act Autom Sin, 2007, 33: 1242--1246 [王开军, 张军英, 李丹, 等. 自适应仿射传播聚类. 自动化学报, 2007, 33: 1242--1246]
%
%% 论文集
%% 作者名. 文章题目. In: 编者名, eds. 论文集名称. 出版社所在城市名: 出版社名, 出版年份. 起止页码
%\bibitem{5}Polito V S. Calmodulin and calmodulin inhibitors: effect on pollen germination and tube growth. In: Mulvshy D L, Ottaviaro E, eds. Pollen: Biology and Implication for Plant Breeding. New York: Elsevier, 1983. 53--60
%
%% 会议论文集 (必须是正式出版的, 否则只能作为脚注)
%% 作者名. 文章题目. In: Proceedings of 会议名称. 出版社所在城市名: 出版社名, 出版年份. 起止页码
%% 作者名. 文章题目. In: Proceedings of 会议名称, 会议地点, 会议年份. 起止页码
%\bibitem{6}Dmtriev V. Complete tables of the second rank constitutive tensors for linear homogeneous bianisotropic media described by point magnetic groups of symmetry and some general properties of the media. In: Proceedings of IEEE MTT-S IMOC' 99. Berlin: Springer, 2000. 435--439
%
%% 学位论文
%% 作者名. 文题. 学位. 学校所在城市名: 学校名, 年份
%\bibitem{7}Wang X M. Study on Data Visualization Methods and Related Techniques for Clustering. Dissertation for Ph.D. Degree. Beijing: Tsinghua University, 2006 [王晓明. 面向聚类的数据可视化方法及相关技术研究. 博士学位论文. 北京: 清华大学, 2006]
%
%% 技术报告
%% 作者名. 报告名. 报告编号. 年份
%\bibitem{8}Phillips N A. The Nested Grid Model. NOAA Technical Report NWS22. 1979
%
%% 专利文献
%% 作者名. 专利国籍, 专利号
%\bibitem{9}Plank C J, Posinski E J. US Patent, 4 081 490, 1978-02-15
%
%% 使用手册
%% 作者名. 手册名及版本号, 年份
%\bibitem{10}Wang D L, Zhu J, Li Z K, et al. User Manual for QTKMapper Version 1.6, 1999
%
\end{thebibliography}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% 附录章节, 非必选
%%% 自动从A编号, 以\section开始一节
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\begin{appendix}
%\section{appendix1}

%\end{appendix}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% 自动生成英文标题部分
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\makeentitle

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% 主要作者英文简介, 数量不超过4个
%%% \authorcv[照片文件名]{姓名}{英文介绍}
%%% [照片文件名]请提供清晰的一寸浅色背景照片, 宽高比为 25:35
%%% {姓名}与英文标题处一致
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\authorcv[]{}{}

\authorcv[]{}{}

%\vspace*{6mm} % 调整照片行间距

\authorcv[]{}{}

\authorcv[]{}{}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% 补充材料, 以补充材料形式作网络在线, 不出现在印刷版中
%%% 自动从I编号, 以\section开始一节
%%% 可以没有\section
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\begin{supplement}
%\section{supplement1}

%\end{supplement}

\end{document}
