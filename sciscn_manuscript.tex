%-----------------------------------------------------------------------
% 中国科学: 信息科学 中文模板, 请用 CCT & LaTeX 编译
% 请作者注意: 在整篇文章中, 不要使用任何改变文章版式的命令, 谢谢.
%-----------------------------------------------------------------------

\documentclass{SCIS2015cnauthor}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% 作者附加的定义
%%% 常用环境已经加载好, 不需要重复加载
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\renewcommand{\algorithmicrequire}{\textbf{Input:}}
\renewcommand{\algorithmicensure}{\textbf{Output:}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% 开始
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{document}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Authors do not modify the information below
%%% 作者不需要修改此处信息
\ArticleType{20truemm}{论~~~文}{}
\Year{2014}
\Vol{44}
\No{1}
\BeginPage{1}
\EndPage{?}
\DOI{xxxxxxxx}
\ReceiveDate{xxxxxxxx}
\AcceptDate{xxxxxxxx}
\OnlineDate{}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% 标题部分
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%% 标题 \title{正文标题}{引用的标题}
\title{用于求解多阶段护士排班问题的带权禁忌搜索}{}

%%% 英文题目, 只有第一个单词的首字母大写, 其余单词非专有名词全部小写
\entitle{Weighted tabu search for multistage nurse rostering problem}


%%% 通信作者 \author[number]{姓名}{{abc@xxxx.xxx}}
%%% 一般作者 \author[number]{姓名}{}
%%% 使用带圈标号 \ding{172},\ding{173},\ding{174},\ding{175},\ding{176}
\author[\ding{172}\ding{173}]{姓名}{{abc@xxxx.xxx}}
\author[\ding{173}]{姓名}{}

%%% 英文作者, 每行一个, []中写地址编号(1,2,3等), 与中文对应
%%% 姓的拼音字母全部大写, 名的拼音首字母大写
%%% 通信作者 \enauthor[number]{AAA BbbCcc}{{abc@xxxx.xxx}}
%%% 一般作者 \enauthor[number]{AAA BbbCcc}{}
\enauthor[1,2]{AAA BbbCcc}{{abc@xxxx.xxx}}
\enauthor[2]{AAA BbbCcc}{}


%%% 地址 \address[number]{地址, 城市 邮编}
\address[\ding{172}]{地址, 武汉 430074}
\address[\ding{173}]{地址, 武汉 430074}

%%% 英文地址, 每行一个, []中写地址编号(1,2,3等), 与中文对应, 需要写国家
%%% \enaddress[number]{Address, City {\rm 000000}, Country}
\enaddress[1]{Address, City {\rm 000000}, Country}
\enaddress[2]{Address, City {\rm 000000}, Country}


%%% 项目资助信息
%%% 国家自然科学基金 (批准号: 0000000, 0000000, 00000000),
%%% 国家高技术研究发展计划 (863计划) (批准号: 0000000, 0000000, 00000000) 和
%%% 国家重点基础研究发展计划 (973计划) (批准号: 0000000, 0000000, 00000000) 资助项目
\Foundation{}

%%% 页眉中的作者信息 \AuthorMark{第一作者等}
%%% 若只有一个作者去掉"等"
\AuthorMark{姓名等}

%%% 引用中的作者信息 \AuthorCitation{第一作者, 第二作者, 第三作者, 等}
%%% 少于三个作者去掉"等"
\AuthorCitation{姓名, 姓名}

\maketitle

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% 摘要和关键词
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%% 中文摘要
\abstract{}

%%% 英文摘要
\enabstract{}


%%% 中文关键词, \keywords{...\quad ...\quad ...\quad ...\quad ...}
%%% 多个关键词之间用\quad隔开
%%% 要求5-8个, 请尽量补充EI数据库中的受控词为关键词, 谢谢!
\keywords{护士排班\quad 禁忌搜索\quad 时刻表规划\quad 人员排班\quad 元启发式\quad 组合优化}

%%% 英文关键词, \enkeywords{..., ..., ..., ..., ...}
%%% 非专有名词全部小写, 与中文对应
\enkeywords{nurse rostering, tabu search, timetabling, personnel scheduling, metaheuristic, combinatorial optimization}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% 正文部分
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{引言}

随着医疗行业的发展，医院拥有了越来越多的医务人员、医疗设备和病房，同时也面临了更多的病人。于是，更合理地利用各种资源来为更多的病人提供更好的服务的重要性正日益凸显。在众多资源当中，人员起到了支配性作用，无疑是优化资源利用率的最关键因素。所以，合理的人员排班显得尤为重要。适当的工作量可以保证病人不被延误，同时可以保证医务人员有足够的休息时间，以保持较高的工作效率。

作为一个具体的人员排班问题，护士排班问题需要给出由每天每个班次有哪些护士需要上班构成的排班表。该排班表应满足多种硬约束，如各班次各岗位的人数达到需求下限、避免不合理的排班模式以及同一个护士在同一天只能排一个班次等。同时，排班表还应满足工作量上限、连续工作天数上下限、周末工作天数上限以及护士的特殊需求等软约束~\upcite{cheang2003nurse,burke2004state,de2011categorisation}~。

由于每天每班次每岗位上班的护士可以从拥有该岗位所需技能的护士中任意挑选，排班表中最小的时间单位的人员选择已经具有组合数级别的复杂度，将各个岗位排满又需要指数级别的复杂度来完成。与此同时，众多的软约束之间相互作用，此消彼涨。因此，护士排班问题无论是对医院的管理人员还是大学的研究者来说，都是一个极其复杂的问题，对其进行优化是一项艰巨的挑战。

护士排班问题在近几十年来得到了广泛的研究，而最近十年研究尤为深入。在众多求解算法中，主要有精确算法和近似算法两大类别。由于护士排班问题的复杂性，纯粹的精确算法往往有诸多局限，因此文献数量相对较少。其中有~isken~等、~Glass~等和~Santos~等分别在文献~\cite{isken2004implicit}~、~\cite{glass2010nurse}~和~\cite{santos2014integer}~中使用的整数规划方法对护士排班问题进行了建模与求解。与之相对地，以启发式算法为核心的近似算法则得到了更多研究者的关注。

Burke~等在~\cite{burke1999hybrid}~中提出了针对护士排班问题的混合禁忌搜索，之后又相继提出了模因算法~\upcite{burke2001memetic}~、变领域搜索~\upcite{burke2004variable,burke2008hybrid}~、分散搜索~\upcite{burke2010scatter}~和变深度搜索~\upcite{burke2013time}~来求解护士排班问题。
此外，针对护士排班问题还有众多解决方案，例如
~Beli{\"e}n~等在文献~\cite{belien2008branch}~中提出的分支定价方法、
~Bai~等在~\cite{bai2010hybrid}~中提出的混合进化算法、
~He~等在~\cite{he2012constraint}~中提出的列生成算法、
~Anwar~等在~\cite{anwar2014hyper}~中提出的超启发式算法以及
~Huang~等在~\cite{huang2014evolutionary}~中提出的进化算法。

由于护士排班问题是从实际应用中提炼出来的问题，不同医院的不同需求导致该问题长期以来没有统一的问题定义与算例，因此难以比较各种算法的优劣。于是，由鲁汶大学的CODeS课题组主办的护士排班竞赛~\upcite{haspeslagh2014first,ceschia2015second}~应运而生。在第一届护士排班竞赛\footnote{官方网站为http://www.kuleuven-kulak.be/nrpcompetition。}中，
~Valouxis~等在~\cite{valouxis2012systematic}~中提出的整数规划与局部搜索相结合的混合算法、
~Burke~等在~\cite{burke2014new}~中提出的分支定价算法以及
~L{\"u}~等在~\cite{lu2012adaptive}~中提出的自适应邻域搜索算法分别证明了其有效性。

由于医院对人员的需求量具有不确定性，周期较长的排班很容易因工作量的变化而需要重新调整。因此，第二届护士排班竞赛\footnote{官方网站为http://mobiz.vives.be/inrc2/。}除了保留了传统的约束之外，还将整个排班周期划分成多个较短的阶段，对当前阶段进行排班时无法得知后续阶段的人员需求，同时无法更改先前阶段的排班计划。在这种情况下，程序仍然需要平衡所有护士在整个排班周期中的工作量。

本文提出的算法\footnote{该算法在竞赛中取得了第四名的成绩。}为针对第二届护士排班竞赛而设计的多阶段、多邻域的带权禁忌搜索。首先，该算法在计算目标函数值时给每个护士设置了不同的权重，该权重根据当前解的质量动态调整。在当前解还有改进空间时，算法将提升集中性，将所有护士设置成相同的权重；在一定迭代次数没有改进本轮搜索的最优解时，算法将增强疏散性，调整权重对软约束违反较多的护士进行针对性优化。其次，算法使用了多种结构和复杂度均不相同的邻域动作，并根据邻域动作的效果动态调整探索各邻域的概率。此外，算法对复杂邻域动作的增量评估结果进行了缓存，有效减少了重复计算。最后，算法设计了辅助目标函数与全局约束的估算策略，以实现对跨阶段约束的优化。

本文接下来的部分将按如下结构组织。第二部分对第二届护士排班竞赛的问题模型进行简要的描述。第三部分对带权禁忌搜索进行深入分析。第四部分将带权禁忌搜索与其他方法进行比较，证明其有效性。第五部分对算法对比结果和竞赛结果进行深入的分析和讨论。第六部分对全文进行总结。


\section{问题定义}

本文讨论的护士排班问题的优化目标是在满足人员需求的情况下尽可能地降低护士的工作强度，以提升医院的效益。为了表述的方便，将一天中一个班次的某个岗位（与技能对应）称作一个时间槽。该问题将给出固定数量的护士，同时给出排班周期的长度以及每个时间槽的人数需求，要求得出一个排班计划，确定每个时间槽安排哪些护士上班。此外，整个排班周期将被划分为多个阶段，各阶段无法获取其他阶段的具体信息，只有特殊的边界信息（历史）能从前一个阶段传递到后一阶段。该排班计划必须满足若干硬约束，同时尽可能减少对各项软约束的违反。
每个护士都有若干技能，并且根据合同的规定有一个工作强度的最佳范围。工作强度包括总工作天数、周末工作天数、连续工作天数、连续相同班次数以及连续休息天数等指标。此外，每个护士可以请求在指定的日期不为其排班。

如果不考虑阶段的划分直接对整个排班周期进行考察，问题的硬约束和软约束的定义如下~\upcite{ceschia2015second}~。

令~$N$~为护士的集合；
~$D$~为排班周期中各天组成的集合；
~$H$~为班次组成的集合；
~$K$~为技能的集合；
~$X^H$~为一个~$ D \times N$~的矩阵，用于表示各护士在各天被安排至哪个班次；
~$X^K$~为一个~$ D \times N$~的矩阵，用于表示各护士在各天被安排使用哪个技能；
~$X^H$~和~$X^K$~共同构成了解向量~$X$~。
其中，休息（~ShiftOff~）算一个特殊的班次。

该问题一共有4个硬约束：

\begin{itemize}
	\item $\mathbf{H_1.}$ \textbf{单一指派约束。} 每个护士每天只能被安排到一个班次并使用一种技能。在本文提出的解向量的表示方式下，该硬约束将自动满足。
	
	\item $\mathbf{H_2.}$ \textbf{人数下限约束。} 每天每班次每技能的排班人数不能小于其人数需求的最小值。
	%即 $$ \forall d \in D, \forall h \in H, \forall k \in K, \quad \sum_{n}^{N} (\mathcal{C}(x^H\phantom{}_{d,n}=h) \times \mathcal{C}(x^K\phantom{}_{d,n}=k)) \ge \mathrm{MinDemand}(d,h,k) $$
	
	\item $\mathbf{H_3.}$ \textbf{后继约束。} 同一个护士连续两天的排班不能出现禁止的模式。例如，一个护士在某天上了夜班，则第二天不能安排她上早班。
	
	\item $\mathbf{H_4.}$ \textbf{技能约束。} 安排到某个时间槽的护士必须具备对应的技能。
\end{itemize}

此外，还有8个软约束：

\begin{itemize}
	\item $\mathbf{S_1.}$ \textbf{最优人数约束。} 每个时间槽安排的护士数量不得小于给定的最优值。每缺少一个护士都要受到~1~个单位的惩罚。
	
	\item $\mathbf{S_2.}$ \textbf{连续工作日约束。} 每个护士的连续工作天数必须在给定的区间内，每个超出或不足的工作日都要受到~1~个单位的惩罚。
	
	\item $\mathbf{S_3.}$ \textbf{连续相同班次约束。} 每个护士被连续安排到同一班次的天数必须在给定的区间内，每个超出或不足的工作日都要受到~1~个单位的惩罚。
	
	\item $\mathbf{S_4.}$ \textbf{连续休息约束。} 每个护士的连续休息天数必须在给定的区间内，每个超出或不足的休息日都要受到~1~个单位的惩罚。
	
	\item $\mathbf{S_5.}$ \textbf{工作偏好约束。} 如果一个护士请求不在某天某班次上班，但仍然被安排在该天该班次上班，将受到~1~个单位的惩罚。
	
	\item $\mathbf{S_6.}$ \textbf{完整周末约束。} 如果一个护士的合同规定其应有完整的周末，则其在周末的排班必须是两天均上班或者两天均休息，否则将受到~1~个单位的惩罚。
	
	\item $\mathbf{S_7.}$ \textbf{总排班数约束。} 每个护士在整个排班周期中的总工作天数必须在给定的区间内，每个超出或不足的工作日都要受到~1~个单位的惩罚。
	
	\item $\mathbf{S_8.}$ \textbf{总周末排班数约束。} 每个护士在整个排班周期中被排班了的周末总数不得大于给定的最大值，每超出一个周末都要受到~1~个单位的惩罚。
\end{itemize}

其中~$\mathbf{S_7}$~与~$\mathbf{S_8}$~为横跨整个排班周期的约束，而其他约束可以在各阶段完成计算。问题的求解目标为，在整个排班周期结束时，各阶段的解向量~$X$~满足硬约束~$\mathbf{H_1}$~到~$\mathbf{H_4}$~，同时使违反软约束~$\mathbf{S_1}$~到~$\mathbf{S_8}$~受到的惩罚最小。
假设软约束~$\mathbf{S_i}$~的惩罚之和为~$f_i(X)$~，权重为~$w_i$~，则合法解~$X$~的目标函数~$f(X)$~如公式~\ref{eq1}~所示。
\begin{equation}
f(X) = \sum_{i=1}^{8} w_i \times f_i(X).
\label{eq1}
\end{equation}


\section{带权禁忌搜索}

\subsection{算法流程概览}

护士排班问题的求解过程将按阶段依次执行，直到覆盖整个排班周期。如算法~\ref{alg1}~所示，每个阶段以场景信息~$Scenario$~、上阶段的历史信息~$h_i$~与本阶段的需求信息~$Weekdata_i$~为输入，调用带权禁忌搜索算法，输出本阶段的解向量~$X_i$~与供下阶段使用的历史信息~$h_{i+1}$~。在本次竞赛中，排班周期以周为单位划分阶段，总周数在场景信息中给出，且参赛者只需实现单个阶段进行求解的算法。

求解过程的核心是带权禁忌搜索算法，其伪代码如算法~\ref{alg2}~所示。其中$w$为对某个护士计算软约束违反情况时惩罚的权重系数。算法首先产生一个合法的初始解作为当前解，然后交替使用均匀的权重和根据惩罚分布情况进行调整后的权重对当前解进行改进。改进的过程使用了一种多邻域禁忌搜索，其处理流程如算法~\ref{alg3}~所示。接下来将详细介绍用于单个阶段求解的算法实现细节。

\begin{algorithm}
	\footnotesize
	\caption{护士排班问题求解过程}
	\label{alg1}
	\begin{algorithmic}
		\REQUIRE $\textrm{算例数据}~Scenario, InitialHistory, Weekdata$;
		\ENSURE $\textrm{求得的最优排班计划}~X$;
		\STATE $h_0 \Leftarrow InitialHistory$;
		\STATE $i \Leftarrow 0$;
		\WHILE{$i < Scenario.WeekNumber$}
			\STATE $X_i \Leftarrow \textrm{WeightedTabuSearch}(Scenario, h_i, Weekdata_i)$;  // 见算法 \ref{alg2}
			\STATE $i \Leftarrow i+1$;
			\STATE $h_i \Leftarrow \textrm{GenerateHistory}(Scenario, X_i)$;
		\ENDWHILE
	\end{algorithmic}
\end{algorithm}

\begin{algorithm}
	\footnotesize
	\caption{求解护士排班问题的带权禁忌搜索算法框架}
	\label{alg2}
	\begin{algorithmic}
		\REQUIRE $\textrm{算例数据}~Scenario, History, Weekdata$;
		\ENSURE $\textrm{求得的本阶段的最优排班计划}~X_i$;
		\STATE $X_i \Leftarrow \textrm{GenerateInitialSolution}()$;  // 见 ~\ref{subsec:init}~节
		\REPEAT
			\STATE $\textrm{ResetWeight}(w)$;  // 见 ~\ref{subsec:weight}~节
			\STATE $s \Leftarrow \textrm{TabuSearch}(w)$;  // 见算法 \ref{alg3}
			\STATE $X_i \Leftarrow \textrm{min}\{ s, X_i \}$;
			\STATE $s \Leftarrow \textrm{SelectRandomly}(s, X_i)$; 	// 按概率随机选择一个
			\STATE $w \Leftarrow \textrm{AdjustWeightToBiasNurseWithGreaterPenalty}(s)$;  // 见 ~\ref{subsec:weight}~节
			\STATE $s \Leftarrow \textrm{TabuSearch}(w)$;  // 见算法 \ref{alg3}
		\UNTIL{满足停止条件}
	\end{algorithmic}
\end{algorithm}

\begin{algorithm}
	\footnotesize
	\caption{多邻域禁忌搜索算法伪代码}
	\label{alg3}
	\begin{algorithmic}
		\REQUIRE $\textrm{各护士的惩罚权重}~w$;
		\ENSURE $\textrm{求得的当前权重下本阶段的最优排班计划}~s$;
		\STATE $\textrm{InitializeNeighborhoodSelectionPossibility}(p)$;  // 见 ~\ref{subsec:select}~节
		\STATE $\textrm{InitializeTabuList}(t)$;  // 见 ~\ref{subsec:tabu}~节
		\REPEAT
			\STATE $n \Leftarrow \textrm{SelectNeighborhood}(p)$;  // 见 ~\ref{subsec:select}~节
			\STATE $m \Leftarrow \textrm{FindBestNeighborhoodMove}(n, t)$;  // 见 ~\ref{subsec:neighbor}~节
			\STATE $\textrm{UpdateTabuList}(t)$;  // 见 ~\ref{subsec:tabu}~节
			\STATE $\textrm{ApplyNeighborhoodMove}(m)$;
			\STATE $\textrm{UpdateNeighborhoodSelectionPossibility}(p, n, m)$;  // 见 ~\ref{subsec:select}~节
		\UNTIL{满足停止条件}
	\end{algorithmic}
\end{algorithm}

\subsection{初始解}
\label{subsec:init}

初始解的生成使用了贪心构造的方法，从阶段的第一天到最后一天依次确定排班计划。对于每一天，统计每个技能对护士的总需求量~$r$~，然后根据其与拥有该技能的护士数~$n$~的比例确定先确定哪个技能的排班。如果~$r/n$~小，说明该技能的排班比较容易满足，可以放到后面排；反之说明拥有该技能的护士人手短缺，应该优先考虑。算法将从~$r/n$~比较小的技能开始，按顺序确定当天各班次的人员安排。对于每个时间槽，在保证不违反硬约束的情况下，优先挑选拥有技能数更少的护士，这样做可以照顾到还未排班的技能。

由于本算法中的贪心构造方法比较简单，可能出现生成了非法解的情况，因此在贪心构造之后还需要对解进行修复。该修复过程与算法~\ref{alg3}~的过程相同，只是目标函数中所有软约束的权重被设置为0，而硬约束变得可以违反，并具有一定的权重。由于初始解的生成方式对求解质量影响非常微弱，故在此不做进一步介绍。

\subsection{邻域结构}
\label{subsec:neighbor}

对于一个给定的解向量~$X$~，可以通过一个变换模式将其变为若干新的解向量，这些新的解向量称为邻域解，使~$X$~变为邻域解中的某个解向量~$X'$~的变换称为邻域动作~$m$~，而这个变换模式即邻域结构。
令作用于~$X$~的邻域动作的集合为~$M(X)$~；
~$C$~为布尔表达式到整数的转换函数，如果布尔表达式为真取~$1$~,否则取~$0$~。
则对于护士排班问题可以定义如下邻域结构。

\begin{itemize}
	\item \textbf{增加班次。} 安排原本在第~$d$~天休息的护士~$n$~在第~$d$~天班次~$h$~技能~$k$~上班。该邻域动作的集合为
	\begin{equation}
	M_1(X) = \{ m_1(d, n, h, k) | \forall d \in D, \forall n \in N, x^H\phantom{}_{d,n} = \textrm{ShiftOff} \wedge h \ne \textrm{ShiftOff} \}.
	\label{eq2}
	\end{equation}
	
	\item \textbf{减少班次。} 安排原本在第~$d$~天上班的护士~$n$~在第~$d$~天休息。该邻域动作的集合为
	\begin{equation}
	M_2(X) = \{ m_2(d, n) | \forall d \in D, \forall n \in N, x^H\phantom{}_{d,n} \ne \textrm{ShiftOff} \}.
	\label{eq3}
	\end{equation}
	
	\item \textbf{变更班次。} 安排原本在第~$d$~天班次~$x^H\phantom{}_{d,n}$~技能~$x^K\phantom{}_{d,n}$~上班的护士~$n$~在第~$d$~天班次~$h$~技能~$k$~上班。该邻域动作的集合为	
	\begin{align}
		M_3(X) = \{ m_3(d, n, h', k') | & \forall d \in D, \forall n \in N, \forall h' \in H, x^H\phantom{}_{d,n} \ne \textrm{ShiftOff} \wedge h' \ne \textrm{ShiftOff} \nonumber \\
		 & \wedge ( x^H\phantom{}_{d,n} \ne h' \vee x^K\phantom{}_{d,n} \ne k' ) \}.
		\label{eq4}
	\end{align}
	
	\item \textbf{交换班次。} 即块交换，交换两个护士~$n_1$~和~$n_2$~在第~$d_1$~到~$d_2$~天的排班。该邻域动作的集合为
	\begin{equation}
	M_4(X) = \{ m_4(d, n, h, k) | \forall d_1, d_2 \in D, \forall n_1, n_2 \in N, d_1 \le d_2 \wedge ( \sum_{d=d_1}^{d_2} C( x^H\phantom{}_{d,n_1} \ne x^H\phantom{}_{d,n_2} ) ) > 0 \}.
	\label{eq5}
	\end{equation}
\end{itemize}

四种邻域结构中，增加、减少和变更班次的复杂度相对较小，而交换班次的复杂度较大。虽然多个前三种邻域动作的组合可以构成块交换的邻域动作，但是总是选择最大改进的邻域动作比较缺乏远见，容易错过能产生更大改进的邻域动作。另一方面，由于硬约束的存在，合法解空间会被分割成很多不相邻的部分，简单的动作可能无法跨越非法解组成的边界，从而导致算法不能对整个合法解空间进行搜索。因此，交换班次作为前三种邻域动作组合而成的复合邻域结构，具有极其重大的意义。

\subsection{邻域选择策略}
\label{subsec:select}

由于邻域数量众多，每次选择邻域动作都对所有邻域进行探索开销过大，每次应仅对少量甚至一个邻域进行评估。于是，邻域的选择策略的设计对算法性能的提升起到了至关重要的作用。

本算法采用了轮盘赌的策略，每种邻域~$M_i$~都有一定的概率~$p_i$~被选中，所有邻域被选中的概率和满足~$\sum p_i = 1$~。在禁忌搜索的每一次迭代中，都会在所有邻域中挑选一个邻域进行搜索，寻找具有最大改进的邻域动作。

概率~$p_i$~由权重~$\omega_i$~来控制，~$p_i = \omega_i / \sum \omega_i$~。在搜索过程中，算法将根据邻域~$M_i$~的表现动态调整其权重~$\omega_i$~。每得到一个邻域动作，都会满足改进了本轮搜索的最优解、改进了当前解、没有改进当前解但存在合法动作和不存在合法动作这~$4$~种情况之一。这~$4$~种情况反应了邻域对当前搜索过程的适应程度，越适应，对解向量产生改进的可能性越大。很显然，应该让更合适的邻域以更大的概率被选择，因此本算法设置了~$4$~个基准值~$\Omega_1$~到~$\Omega_4$~，分别与~$4$~种适应程度相对应，每执行一个邻域动作都将根据其效果向对应的基准值趋近。具体的调整策略为
\begin{equation}
\omega_i = 
\begin{cases} 
\omega_i + (\Omega_1 - \omega_i) / \lambda_1 & , m_i \textrm{改进了本轮搜索的最优解} \\
\omega_i + (\Omega_2 - \omega_i) / \lambda_2 & , m_i \textrm{改进了当前解} \\
\omega_i + (\Omega_3 - \omega_i) / \lambda_3 & , m_i \textrm{没有改进当前解但存在合法动作} \\
\omega_i + (\Omega_4 - \omega_i) / \lambda_4 & , m_i \textrm{不存在合法动作} \\
\end{cases}
\end{equation}
其中~$\lambda \in [1, +\infty )$~控制~$\omega$~向基准值趋近的速度。在其定义域内，~$\lambda$~越小收敛速度越快。

\subsection{惩罚权重调整策略}
\label{subsec:weight}

禁忌搜索是一个集中性较强的算法，为了增加算法的疏散性，本算法引入了每个护士的惩罚权重。由于问题中的连续工作和连续休息等软约束的存在，打破当前的排班模式的代价往往很大，很有可能在对解向量产生结构性改变之前就因为惩罚的急剧增长而落回原来的排班布局，或者一直在相似的排班之间做小幅改进。针对这种情况，本算法通过降低惩罚较少的护士的权重，削弱对次优排班模式进行大幅调整的惩罚，防止搜索陷入局部最优而无法探索更广阔的解空间。

护士惩罚权重的具体调整过程为，在全部护士中，选择惩罚少的~$r_1 \times N$~个护士，将其权重设为~$W_1$~，然后再在剩余护士中，随机选择~$r_2 \times N$~个护士，将其权重设为~$W_2$~，再将剩下的护士的权重设为~$W_3$~。其中有~$0 < W_1 < W_2 < W_3, r_1, r_2 \in [0, 1], r_1 + r_2 < 1$~。该调整过程的伪代码如算法~\ref{alg4}~所示。由于~$\mathbf{S_1}$~是针对时间槽的约束，无法准确评价单个护士在该约束上的惩罚，故统计护士的惩罚情况时未考虑该软约束。

\begin{algorithm}
	\footnotesize
	\caption{惩罚权重调整过程}
	\label{alg4}
	\begin{algorithmic}
		\REQUIRE $\textrm{护士集合}~N, \textrm{某个护士当前惩罚的计算函数}~f$;
		\ENSURE $\textrm{护士的惩罚权重}~w$;
		\STATE $n \Leftarrow \textrm{SortNurseByPenalty}(N, f)$;
		\STATE $i \Leftarrow 1$;
		\WHILE{$i < N \times r_1$}
			\STATE $w_{n_i} \Leftarrow W_1$;
			\STATE $i \Leftarrow i + 1$;
		\ENDWHILE
		\WHILE{$i < N$}
			\STATE $w_{n_i} \Leftarrow W_3$;
			\STATE $i \Leftarrow i + 1$;
		\ENDWHILE
		\STATE $i \Leftarrow 1$;
		\WHILE{$i < N \times r_2$}
			\STATE $j \Leftarrow \textrm{SelectNurseRandomly}(N)$;
			\IF{$w_j = W_3$}
				\STATE $w_j \Leftarrow W_2$;
				\STATE $i \Leftarrow i + 1$;
			\ENDIF
		\ENDWHILE
	\end{algorithmic}
\end{algorithm}

\subsection{禁忌策略}
\label{subsec:tabu}

本算法中另一个防止搜索过程陷入局部最优的策略是禁忌。而禁忌策略的关键因素为禁忌表的设计和禁忌步长的设置，由于禁忌步长的选取较为简单，本节将详细介绍禁忌表的设计。

禁忌搜索的核心思想在于记录已搜索过的解的特征或已执行过的邻域动作的特征，防止搜索路径在局部最优附近绕圈，甚至原路返回落回局部最优。
本算法对排班情况进行了记录，如果一个在第~$d$~天休息的护士~$n$~被安排上班，那么在接下来的一段时间里，护士~$n$~将保持第~$d$~天的排班，即不能在第~$d$~天被安排为休息；
如果一个在第~$d$~天班次~$h$~技能~$k$~上班的护士~$n$~被安排为休息或者在其他班次或技能上班，那么在接下来的一段时间里，护士~$n$~将不能被重新安排在时间槽~$(d,h,k)$~上班。

具体来说，本算法中使用了两个禁忌表。禁忌表~$T^D$~是一个~$N \times D$~的矩阵，如果~$T^D\phantom{}_{n,d}$~大于当前迭代步数表示禁止护士~$n$~在第~$d$~天被安排为休息。禁忌表~$T^H$~是一个~$N \times D \times H \times K$~的矩阵，~$T^H\phantom{}_{n,d,h,k}$~大于当前迭代步数表示禁止护士~$n$~被安排在时间槽~$(d,h,k)$~上班。
对于~$M_4$~这种复合邻域结构，需要将其分解为~$M_1$~至~$M_3$~的组合，再针对每个动作查询或设置禁忌表。在判断一个给定的块交换是否被禁忌时，有~$4$~种策略，它们分别为：总是允许、只要有一个非禁忌的子动作就允许、只要有一个子动作被禁忌则禁止以及被禁忌的子动作超过一定比例则禁止。由于~$M_4$~邻域较大，再加上多种动作交替选择，其陷入局部最优的可能性相对较小，同时为了方便增量评估缓存的设计（见~\ref{subsec:cache}~节），本算法总是认为~$M_4$~是非禁忌的。

\subsection{缓存策略}
\label{subsec:cache}

由于护士排班问题软约束众多，目标函数计算过程十分复杂。对于较大的邻域，邻域评估的运算量更加庞大。分析禁忌搜索算法每次只对当前解做小幅改动的特性，可知每次执行一个邻域动作，大多数邻域动作对目标函数的影响并未发生变化。因此，本算法使用了缓存机制，将邻域动作导致的目标函数的增量保存起来，加速邻域评估过程。

本算法中有多种邻域结构，而搜索过程中每次只挑选一个进行评估，如果对所有邻域都进行缓存，可能会导致较高的缓存失效率，从而降低命中率，并增加缓存维护的开销。下面将分析各种缓存策略的利弊，最终得出本算法使用的缓存策略。

对于~$M_1$~至~$M_3$~，~$M_1$~至~$M_4$~中所涉及的护士的所有~$M_1$~至~$M_4$~缓存全部失效，同时由于~$\mathbf{S_1}$~的存在，动作添加或删除排班的时间槽中所有其他护士的~$M_1$~至~$M_4$~在该时间槽的缓存全部失效。如果以时间槽为粒度对缓存有效性进行标记，会导致每次邻域动作需要对众多标记位进行设置，时间复杂度为~$O(n)$~；如果以护士为粒度，每次邻域动作只需对一个标记位进行设置，时间复杂度为~$O(1)$~，但是会导致较高的失效率。

对于~$M_4$~，~$M_1$~至~$M_4$~中所涉及的护士的所有~$M_1$~至~$M_4$~的缓存全部失效。由于两个护士交换不会改变各时间槽的人数，所以~$M_1$~至~$M_4$~并不会通过~$\mathbf{S_1}$~影响其他护士的~$M_4$~缓存。如果以护士为粒度对缓存有效性进行标记，则可以在~$O(1)$~的时间复杂度内更新标记位，即每次邻域动作的执行只会导致不超过~$2$~个缓存项失效。

再对算法的性能瓶颈进行分析，可知对~$M_1$~至~$M_3$~的增量评估虽然逻辑复杂，但其时间复杂度仍为~$O(D)$~，而~$M_4$~的时间复杂度则为~$O(N^2 \times D^3)$~，远大于其他邻域的复杂度，对其进行缓存将极大地减少重复计算。

因此，经过对各种策略的开销与收益的综合分析，本算法仅对~$M_4$~以护士为粒度对缓存有效性进行标记，对两个护士的任意起止天的块交换中的最优值进行缓存。

\subsection{全局约束的近似评估}
\label{subsec:global}

软约束~$\mathbf{S_7}$~和~$\mathbf{S_8}$~在整个排班周期结束时才能被准确评估。因此，在各阶段内部需要一个近似评估机制来估算本阶段的排班会对全局约束的造成多大的影响。
辅助目标函数
均匀分配剩余排班数


\section{计算结果}

计算结果


\section{分析与讨论}

观察结果发现不同护士的惩罚差异很大。

对比分析


\section{总结}

总结


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% 致谢, 非必选
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\Acknowledgements{}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% 补充材料说明, 非必选
%%% 有补充材料时请添加补充材料说明, 例如图S1~S5
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\Supplements{图S1$\sim$S5.}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% 参考文献, {}为引用的标签, 数字/字母均可
%%% 文中上标引用: \upcite{1,2}
%%% 文中正常引用: \cite{1,2}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\bibliography{bib}{}
\bibliographystyle{plain}
%\begin{thebibliography}{99}
%
%% 专著
%% 作者名. 书名. 版次(第一版不用列出). 出版社所在城市名: 出版社名, 出版年份. 起止页码
%\bibitem{1}Gaydon A G, Wolfhard H G. Flames. 2nd ed. London: Chapman and Hall Ltd, 1960. 30--35
%
%% 期刊
%% 作者名. 文章题目(用小写字母). 期刊名, 年份, 卷号: 起止页码
%\bibitem{2}Xu Y B, Shen L S, Susan R M. Extension of the rice DH population genetic map with microsatellite markers. Chin Sci Bull, 1998, 43:149--153
%\bibitem{3}Hutton B. Product of fuzzy topological space. Topology Appl, 1980, 11: 59--61
%\bibitem{4}Wang K J, Zhang J Y, Li D, et al. Adaptive affinity propagation clustering. Act Autom Sin, 2007, 33: 1242--1246 [王开军, 张军英, 李丹, 等. 自适应仿射传播聚类. 自动化学报, 2007, 33: 1242--1246]
%
%% 论文集
%% 作者名. 文章题目. In: 编者名, eds. 论文集名称. 出版社所在城市名: 出版社名, 出版年份. 起止页码
%\bibitem{5}Polito V S. Calmodulin and calmodulin inhibitors: effect on pollen germination and tube growth. In: Mulvshy D L, Ottaviaro E, eds. Pollen: Biology and Implication for Plant Breeding. New York: Elsevier, 1983. 53--60
%
%% 会议论文集 (必须是正式出版的, 否则只能作为脚注)
%% 作者名. 文章题目. In: Proceedings of 会议名称. 出版社所在城市名: 出版社名, 出版年份. 起止页码
%% 作者名. 文章题目. In: Proceedings of 会议名称, 会议地点, 会议年份. 起止页码
%\bibitem{6}Dmtriev V. Complete tables of the second rank constitutive tensors for linear homogeneous bianisotropic media described by point magnetic groups of symmetry and some general properties of the media. In: Proceedings of IEEE MTT-S IMOC' 99. Berlin: Springer, 2000. 435--439
%
%% 学位论文
%% 作者名. 文题. 学位. 学校所在城市名: 学校名, 年份
%\bibitem{7}Wang X M. Study on Data Visualization Methods and Related Techniques for Clustering. Dissertation for Ph.D. Degree. Beijing: Tsinghua University, 2006 [王晓明. 面向聚类的数据可视化方法及相关技术研究. 博士学位论文. 北京: 清华大学, 2006]
%
%% 技术报告
%% 作者名. 报告名. 报告编号. 年份
%\bibitem{8}Phillips N A. The Nested Grid Model. NOAA Technical Report NWS22. 1979
%
%% 专利文献
%% 作者名. 专利国籍, 专利号
%\bibitem{9}Plank C J, Posinski E J. US Patent, 4 081 490, 1978-02-15
%
%% 使用手册
%% 作者名. 手册名及版本号, 年份
%\bibitem{10}Wang D L, Zhu J, Li Z K, et al. User Manual for QTKMapper Version 1.6, 1999
%
%\end{thebibliography}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% 附录章节, 非必选
%%% 自动从A编号, 以\section开始一节
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\begin{appendix}
%\section{appendix1}

%\end{appendix}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% 自动生成英文标题部分
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\makeentitle

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% 主要作者英文简介, 数量不超过4个
%%% \authorcv[照片文件名]{姓名}{英文介绍}
%%% [照片文件名]请提供清晰的一寸浅色背景照片, 宽高比为 25:35
%%% {姓名}与英文标题处一致
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\authorcv[]{}{}

\authorcv[]{}{}

%\vspace*{6mm} % 调整照片行间距

\authorcv[]{}{}

\authorcv[]{}{}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% 补充材料, 以补充材料形式作网络在线, 不出现在印刷版中
%%% 自动从I编号, 以\section开始一节
%%% 可以没有\section
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\begin{supplement}
%\section{supplement1}

%\end{supplement}

\end{document}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% 本模板使用的latex排版示例
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%% 章节
\section{}
\subsection{}
\subsubsection{}


%%% 列表
\begin{itemize}
\item Aaa aaa.
\item Bbb bbb.
\item Ccc ccc.
\end{itemize}


%%% 定义、定理、引理、推论
%%% []中的名称可以省略
\definition[定义名]{定义内容.}
\theorem[定理名]{定理内容.}
\lemma[引理名]{引理内容.}
\corollary[推论名]{推论内容.}

%%% 若使用定理样式的其他前缀
%%% 在 "作者附加的定义" 处加入\newtheorem命令, 例如
%%% "定理" 是由以下命令定义的
\newtheorem{theorem}{定理}


%%% 单图
%%% 可在文中使用图\ref{fig1}引用图编号
\begin{figure}[!t]
\centering
\includegraphics{fig1.eps}
\cnenfigcaption{中文图题}{Caption}
\label{fig1}
\end{figure}

%%% 并排图
%%% 可在文中使用图\ref{fig1}、图\ref{fig2}引用图编号
\begin{figure}[!t]
\centering
\begin{minipage}[c]{0.48\textwidth}
\centering
\includegraphics{fig1.eps}
\end{minipage}
\hspace{0.02\textwidth}
\begin{minipage}[c]{0.48\textwidth}
\centering
\includegraphics{fig2.eps}
\end{minipage}\\[3mm]
\begin{minipage}[t]{0.48\textwidth}
\centering
\cnenfigcaption{中文图题1}{Caption1}
\label{fig1}
\end{minipage}
\hspace{0.02\textwidth}
\begin{minipage}[t]{0.48\textwidth}
\centering
\cnenfigcaption{中文图题2}{Caption2}
\label{fig2}
\end{minipage}
\end{figure}

%%% 并排子图
%%% 需要英文分图题 (a)...; (b)...
\begin{figure}[!t]
\centering
\begin{minipage}[c]{0.48\textwidth}
\centering
\includegraphics{subfig1.eps}
\end{minipage}
\hspace{0.02\textwidth}
\begin{minipage}[c]{0.48\textwidth}
\centering
\includegraphics{subfig2.eps}
\end{minipage}
\cnenfigcaption{中文图题}{Caption. (a) Subfig1 caption; (b) subfig2 caption}
\label{fig1}
\end{figure}

%%% 算法
%%% 可在文中使用 算法\ref{alg1} 引用算法编号
\begin{algorithm}
\footnotesize
\caption{算法标题}
\label{alg1}
\begin{algorithmic}
    \REQUIRE $n \geq 0 \vee x \neq 0$;
    \ENSURE $y = x^n$;
    \STATE $y \Leftarrow 1$;
    \IF{$n < 0$}
        \STATE $X \Leftarrow 1 / x$;
        \STATE $N \Leftarrow -n$;
    \ELSE
        \STATE $X \Leftarrow x$;
        \STATE $N \Leftarrow n$;
    \ENDIF
    \WHILE{$N \neq 0$}
        \IF{$N$ is even}
            \STATE $X \Leftarrow X \times X$;
            \STATE $N \Leftarrow N / 2$;
        \ELSE[$N$ is odd]
            \STATE $y \Leftarrow y \times X$;
            \STATE $N \Leftarrow N - 1$;
        \ENDIF
    \ENDWHILE
\end{algorithmic}
\end{algorithm}

%%% 简单表格
%%% 可在文中使用 表\ref{tab1} 引用表编号
\begin{table}[!t]
\footnotesize
\cnentablecaption{表题}{Caption}
\label{tab1}
\tabcolsep 10pt %space between two columns. 用于调整列间距
\begin{tabular*}{\textwidth}{cccc}
\toprule
  Title a & Title b & Title c & Title d \\\hline
  Aaa & Bbb & Ccc & Ddd\\
  Aaa & Bbb & Ccc & Ddd\\
  Aaa & Bbb & Ccc & Ddd\\
\bottomrule
\end{tabular*}
\end{table}

%%% 换行表格
\begin{table}[!t]
\footnotesize
\cnentablecaption{表题}{Caption}
\label{tab1}
\def\tabblank{\hspace*{10mm}} %blank leaving of both side of the table. 左右两边的留白
\begin{tabularx}{\textwidth} %using p{?mm} to define the width of a column. 用p{?mm}控制列宽
{@{\tabblank}@{\extracolsep{\fill}}cccp{100mm}@{\tabblank}}
\toprule
  Title a & Title b & Title c & Title d \\\hline
  Aaa & Bbb & Ccc & Ddd ddd ddd ddd.

  Ddd ddd ddd ddd ddd ddd ddd ddd ddd ddd ddd ddd ddd ddd ddd ddd ddd ddd ddd ddd ddd ddd ddd ddd ddd ddd ddd ddd ddd ddd ddd.\\
  Aaa & Bbb & Ccc & Ddd ddd ddd ddd.\\
  Aaa & Bbb & Ccc & Ddd ddd ddd ddd.\\
\bottomrule
\end{tabularx}
\end{table}

%%% 单行公式
%%% 可在文中使用 (\ref{eq1})式 引用公式编号
%%% 如果是句子开头, 使用 公式(\ref{eq1}) 引用
\begin{equation}
A(d,f)=d^{l}a^{d}(f),
\label{eq1}
\end{equation}

%%% 不编号的单行公式
\begin{equation}
\nonumber
A(d,f)=d^{l}a^{d}(f),
\end{equation}

%%% 公式组
\begin{eqnarray}
\nonumber
&X=[x_{11},x_{12},\ldots,x_{ij},\ldots ,x_{n-1,n}]^{\rm T},\\
\nonumber
&\varepsilon=[e_{11},e_{12},\ldots ,e_{ij},\ldots ,e_{n-1,n}],\\
\nonumber
&T=[t_{11},t_{12},\ldots ,t_{ij},\ldots ,t_{n-1,n}].
\end{eqnarray}

%%% 条件公式
\begin{eqnarray}
\sum_{j=1}^{n}x_{ij}-\sum_{k=1}^{n}x_{ki}=
\left\{
\begin{aligned}
1,&\quad i=1,\\
0,&\quad i=2,\ldots ,n-1,\\
-1,&\quad i=n.
\end{aligned}
\right.
\label{eq1}
\end{eqnarray}

%%% 其他格式
\footnote{Comments.} %footnote. 脚注
\raisebox{-1pt}[0mm][0mm]{xxxx} %put xxxx upper or lower. 控制xxxx的垂直位置