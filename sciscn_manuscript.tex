%-----------------------------------------------------------------------
% 中国科学: 信息科学 中文模板, 请用 CCT & LaTeX 编译
% 请作者注意: 在整篇文章中, 不要使用任何改变文章版式的命令, 谢谢.
%-----------------------------------------------------------------------

\documentclass{SCIS2015cnauthor}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% 作者附加的定义
%%% 常用环境已经加载好, 不需要重复加载
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage{etex}
\usepackage{pgfplots}
\usepackage{multirow}

\renewcommand{\algorithmicrequire}{\textbf{Input:}}
\renewcommand{\algorithmicensure}{\textbf{Output:}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% 开始
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{document}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Authors do not modify the information below
%%% 作者不需要修改此处信息
\ArticleType{20truemm}{论~~~文}{}
\Year{2014}
\Vol{44}
\No{1}
\BeginPage{1}
\EndPage{?}
\DOI{xxxxxxxx}
\ReceiveDate{xxxxxxxx}
\AcceptDate{xxxxxxxx}
\OnlineDate{}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% 标题部分
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%% 标题 \title{正文标题}{引用的标题}
\title{用于求解多阶段护士排班问题的带权禁忌搜索}{}

%%% 英文题目, 只有第一个单词的首字母大写, 其余单词非专有名词全部小写
\entitle{Weighted tabu search for multistage nurse rostering problem}


%%% 通信作者 \author[number]{姓名}{{abc@xxxx.xxx}}
%%% 一般作者 \author[number]{姓名}{}
%%% 使用带圈标号 \ding{172},\ding{173},\ding{174},\ding{175},\ding{176}
\author[\ding{172}\ding{173}]{姓名}{{abc@xxxx.xxx}}
\author[\ding{173}]{姓名}{}

%%% 英文作者, 每行一个, []中写地址编号(1,2,3等), 与中文对应
%%% 姓的拼音字母全部大写, 名的拼音首字母大写
%%% 通信作者 \enauthor[number]{AAA BbbCcc}{{abc@xxxx.xxx}}
%%% 一般作者 \enauthor[number]{AAA BbbCcc}{}
\enauthor[1,2]{AAA BbbCcc}{{abc@xxxx.xxx}}
\enauthor[2]{AAA BbbCcc}{}


%%% 地址 \address[number]{地址, 城市 邮编}
\address[\ding{172}]{地址, 武汉 430074}
\address[\ding{173}]{地址, 武汉 430074}

%%% 英文地址, 每行一个, []中写地址编号(1,2,3等), 与中文对应, 需要写国家
%%% \enaddress[number]{Address, City {\rm 000000}, Country}
\enaddress[1]{Address, City {\rm 000000}, Country}
\enaddress[2]{Address, City {\rm 000000}, Country}


%%% 项目资助信息
%%% 国家自然科学基金 (批准号: 0000000, 0000000, 00000000),
%%% 国家高技术研究发展计划 (863计划) (批准号: 0000000, 0000000, 00000000) 和
%%% 国家重点基础研究发展计划 (973计划) (批准号: 0000000, 0000000, 00000000) 资助项目
\Foundation{}

%%% 页眉中的作者信息 \AuthorMark{第一作者等}
%%% 若只有一个作者去掉"等"
\AuthorMark{姓名等}

%%% 引用中的作者信息 \AuthorCitation{第一作者, 第二作者, 第三作者, 等}
%%% 少于三个作者去掉"等"
\AuthorCitation{姓名, 姓名}

\maketitle

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% 摘要和关键词
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%% 中文摘要
\abstract{
	本文提出了一种用于求解第二届国际护士排班竞赛中提出的多阶段护士排班问题的带权禁忌搜索算法。该算法使用了~$3$~种互斥的简单邻域结构与~$1$~种复合邻域结构，并根据其适应性动态调整搜索各邻域的概率，同时通过调整各护士的惩罚权重来实现搜索过程中集中性与疏散性的平衡。为了应对多阶段问题中各个独立的阶段缺乏全局信息，算法提出了一种对全局约束的近似评估策略。算法还以平衡各邻域的优化效果与计算开销为目标设计了邻域评估的缓存策略，进一步提升了算法的执行效率。算法在竞赛使用的~$60$~个算例上的计算结果表明，本算法生成合法解的频率为~$100\%$~，具有极高的可用性，同时在绝大多数算例上求得的最优值与所有参赛者求得的最优值的差距不超过~$15\%$~，具有较高的求解质量。最后，本文对算法中的关键要素进行了对比分析，证明了这些组成部分的方案选择和参数设置的合理性。
}

%%% 英文摘要
\enabstract{
	%This paper proposes a weighted tabu search algorithm for solving multistage nurse rostering problem given by second 
}


%%% 中文关键词, \keywords{...\quad ...\quad ...\quad ...\quad ...}
%%% 多个关键词之间用\quad隔开
%%% 要求5-8个, 请尽量补充EI数据库中的受控词为关键词, 谢谢!
\keywords{护士排班\quad 禁忌搜索\quad 时刻表规划\quad 人员排班\quad 元启发式\quad 组合优化}

%%% 英文关键词, \enkeywords{..., ..., ..., ..., ...}
%%% 非专有名词全部小写, 与中文对应
\enkeywords{nurse rostering, tabu search, timetabling, personnel scheduling, metaheuristic, combinatorial optimization}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% 正文部分
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{引言}

随着医疗行业的发展，医院拥有了越来越多的医务人员、医疗设备和病房，同时也面临了更多的病人。于是，更合理地利用各种资源来为更多的病人提供更好的服务的重要性正日益凸显。在众多资源当中，人员起到了支配性作用，无疑是优化资源利用率的最关键因素。所以，合理的人员排班显得尤为重要。适当的工作量可以保证病人不被延误，同时可以保证医务人员有足够的休息时间，以保持较高的工作效率。

作为一个具体的人员排班问题，护士排班问题需要给出由每天每个班次有哪些护士需要上班构成的排班表。该排班表应满足多种硬约束，如各班次各岗位的人数达到需求下限、避免不合理的排班模式以及同一个护士在同一天只能排一个班次等。同时，排班表还应满足工作量上限、连续工作天数上下限、周末工作天数上限以及护士的特殊需求等软约束~\upcite{cheang2003nurse,burke2004state,de2011categorisation}~。

由于每天每班次每岗位上班的护士可以从拥有该岗位所需技能的护士中任意挑选，排班表中最小的时间单位的人员选择已经具有组合数级别的复杂度，将各个岗位排满又需要指数级别的复杂度来完成。与此同时，众多的软约束之间相互作用，此消彼涨。因此，护士排班问题无论是对医院的管理人员还是大学的研究者来说，都是一个极其复杂的问题，对其进行优化是一项艰巨的挑战。

护士排班问题在近几十年来得到了广泛的研究，而最近十年研究尤为深入。在众多求解算法中，主要有精确算法和近似算法两大类别。由于护士排班问题的复杂性，纯粹的精确算法往往有诸多局限，因此文献数量相对较少。其中有~isken~等、~Glass~等和~Santos~等分别在文献~\cite{isken2004implicit}~、~\cite{glass2010nurse}~和~\cite{santos2014integer}~中使用的整数规划方法对护士排班问题进行了建模与求解。与之相对地，以启发式算法为核心的近似算法则得到了更多研究者的关注。

Burke~等在~\cite{burke1999hybrid}~中提出了针对护士排班问题的混合禁忌搜索，之后又相继提出了模因算法~\upcite{burke2001memetic}~、变领域搜索~\upcite{burke2004variable,burke2008hybrid}~、分散搜索~\upcite{burke2010scatter}~和变深度搜索~\upcite{burke2013time}~来求解护士排班问题。
此外，针对护士排班问题还有众多解决方案，例如
~Beli{\"e}n~等在文献~\cite{belien2008branch}~中提出的分支定价方法、
~Bai~等在~\cite{bai2010hybrid}~中提出的混合进化算法、
~He~等在~\cite{he2012constraint}~中提出的列生成算法、
~Anwar~等在~\cite{anwar2014hyper}~中提出的超启发式算法以及
~Huang~等在~\cite{huang2014evolutionary}~中提出的进化算法。

由于护士排班问题是从实际应用中提炼出来的问题，不同医院的不同需求导致该问题长期以来没有统一的问题定义与算例，因此难以比较各种算法的优劣。于是，由鲁汶大学的CODeS课题组主办的护士排班竞赛~\upcite{haspeslagh2014first,ceschia2015second}~应运而生。在第一届护士排班竞赛\footnote{官方网站为http://www.kuleuven-kulak.be/nrpcompetition。}中，
~Valouxis~等在~\cite{valouxis2012systematic}~中提出的整数规划与局部搜索相结合的混合算法、
~Burke~等在~\cite{burke2014new}~中提出的分支定价算法以及
~L{\"u}~等在~\cite{lu2012adaptive}~中提出的自适应邻域搜索算法分别证明了其有效性。

由于医院对人员的需求量具有不确定性，周期较长的排班很容易因工作量的变化而需要重新调整。因此，第二届护士排班竞赛\footnote{官方网站为http://mobiz.vives.be/inrc2/。}除了保留了传统的约束之外，还将整个排班周期划分成多个较短的阶段，对当前阶段进行排班时无法得知后续阶段的人员需求，同时无法更改先前阶段的排班计划。在这种情况下，程序仍然需要平衡所有护士在整个排班周期中的工作量。

本文提出的算法为针对第二届护士排班竞赛而设计的多阶段、多邻域的带权禁忌搜索。首先，该算法在计算目标函数值时给每个护士设置了不同的权重，该权重根据当前解的质量动态调整。在当前解还有改进空间时，算法将提升集中性，将所有护士设置成相同的权重；在一定迭代次数没有改进本轮搜索的最优解时，算法将增强疏散性，调整权重对软约束违反较多的护士进行针对性优化。其次，算法使用了多种结构和复杂度均不相同的邻域动作，并根据邻域动作的效果动态调整探索各邻域的概率。此外，算法对复杂邻域动作的增量评估结果进行了缓存，有效减少了重复计算。最后，算法设计了辅助目标函数与全局约束的估算策略，以实现对跨阶段约束的优化。

本文接下来的部分将按如下结构组织。第二部分对第二届护士排班竞赛的问题模型进行简要的描述。第三部分对带权禁忌搜索进行深入分析。第四部分将带权禁忌搜索与其他方法进行比较，证明其有效性。第五部分对算法对比结果和竞赛结果进行深入的分析和讨论。第六部分对全文进行总结。


\section{问题定义}

本文讨论的护士排班问题的优化目标是在满足人员需求的情况下尽可能地降低护士的工作强度，以提升医院的效益。为了表述的方便，将一天中一个班次的某个岗位（与技能对应）称作一个时间槽。该问题将给出固定数量的护士，同时给出排班周期的长度以及每个时间槽的人数需求，要求得出一个排班计划，确定每个时间槽安排哪些护士上班。此外，整个排班周期将被划分为多个阶段，各阶段无法获取其他阶段的具体信息，只有特殊的边界信息（历史）能从前一个阶段传递到后一阶段。该排班计划必须满足若干硬约束，同时尽可能减少对各项软约束的违反。
每个护士都有若干技能，并且根据合同的规定有一个工作强度的最佳范围。工作强度包括总工作天数、周末工作天数、连续工作天数、连续相同班次数以及连续休息天数等指标。此外，每个护士可以请求在指定的日期不为其排班。

如果不考虑阶段的划分直接对整个排班周期进行考察，问题的硬约束和软约束的定义如下~\upcite{ceschia2015second}~。

令~$N$~为护士的集合；
~$D$~为排班周期中各天组成的集合；
~$H$~为班次组成的集合；
~$K$~为技能的集合；
~$X^H$~为一个~$ D \times N$~的矩阵，用于表示各护士在各天被安排至哪个班次；
~$X^K$~为一个~$ D \times N$~的矩阵，用于表示各护士在各天被安排使用哪个技能；
~$X^H$~和~$X^K$~共同构成了解向量~$X$~。
其中，休息（~ShiftOff~）算一个特殊的班次。

该问题一共有4个硬约束：

\begin{itemize}
	\item $\mathbf{H_1.}$ \textbf{单一指派约束。} 每个护士每天只能被安排到一个班次并使用一种技能。在本文提出的解向量的表示方式下，该硬约束将自动满足。
	
	\item $\mathbf{H_2.}$ \textbf{人数下限约束。} 每天每班次每技能的排班人数不能小于其人数需求的最小值。
	
	\item $\mathbf{H_3.}$ \textbf{后继约束。} 同一个护士连续两天的排班不能出现禁止的模式。例如，一个护士在某天上了夜班，则第二天不能安排她上早班。
	
	\item $\mathbf{H_4.}$ \textbf{技能约束。} 安排到某个时间槽的护士必须具备对应的技能。
\end{itemize}

此外，还有8个软约束：

\begin{itemize}
	\item $\mathbf{S_1.}$ \textbf{最优人数约束。} 每个时间槽安排的护士数量不得小于给定的最优值。每缺少一个护士都要受到~1~个单位的惩罚。
	
	\item $\mathbf{S_2.}$ \textbf{连续工作日约束。} 每个护士的连续工作天数必须在给定的区间内，每个超出或不足的工作日都要受到~1~个单位的惩罚。
	
	\item $\mathbf{S_3.}$ \textbf{连续相同班次约束。} 每个护士被连续安排到同一班次的天数必须在给定的区间内，每个超出或不足的工作日都要受到~1~个单位的惩罚。
	
	\item $\mathbf{S_4.}$ \textbf{连续休息约束。} 每个护士的连续休息天数必须在给定的区间内，每个超出或不足的休息日都要受到~1~个单位的惩罚。
	
	\item $\mathbf{S_5.}$ \textbf{工作偏好约束。} 如果一个护士请求不在某天某班次上班，但仍然被安排在该天该班次上班，将受到~1~个单位的惩罚。
	
	\item $\mathbf{S_6.}$ \textbf{完整周末约束。} 如果一个护士的合同规定其应有完整的周末，则其在周末的排班必须是两天均上班或者两天均休息，否则将受到~1~个单位的惩罚。
	
	\item $\mathbf{S_7.}$ \textbf{总排班数约束。} 每个护士在整个排班周期中的总工作天数必须在给定的区间内，每个超出或不足的工作日都要受到~1~个单位的惩罚。
	
	\item $\mathbf{S_8.}$ \textbf{总周末排班数约束。} 每个护士在整个排班周期中被排班了的周末总数不得大于给定的最大值，每超出一个周末都要受到~1~个单位的惩罚。
\end{itemize}

其中~$\mathbf{S_7}$~与~$\mathbf{S_8}$~为横跨整个排班周期的约束，而其他约束可以在各阶段完成计算。问题的求解目标为，在整个排班周期结束时，各阶段的解向量~$X$~满足硬约束~$\mathbf{H_1}$~到~$\mathbf{H_4}$~，同时使违反软约束~$\mathbf{S_1}$~到~$\mathbf{S_8}$~受到的惩罚最小。
假设软约束~$\mathbf{S_i}$~的惩罚之和为~$f_i(X)$~，权重为~$w_i$~，则合法解~$X$~的目标函数~$f(X)$~如公式~\ref{eq1}~所示。
\begin{equation}
f(X) = \sum_{i=1}^{8} w_i \times f_i(X)
\label{eq1}
\end{equation}


\section{带权禁忌搜索}
\label{sec:implement}

\subsection{算法流程概览}

护士排班问题的求解过程将按阶段依次执行，直到覆盖整个排班周期。如算法~\ref{alg1}~所示，每个阶段以场景信息~$Scenario$~、上阶段的历史信息~$h_i$~与本阶段的需求信息~$Weekdata_i$~为输入，调用带权禁忌搜索算法，输出本阶段的解向量~$X_i$~与供下阶段使用的历史信息~$h_{i+1}$~。在本次竞赛中，排班周期以周为单位划分阶段，总阶段数~$T$~在场景信息中给出，且参赛者只需实现单个阶段进行求解的算法。

求解过程的核心是带权禁忌搜索算法，其伪代码如算法~\ref{alg2}~所示。其中$w$为对某个护士计算软约束违反情况时惩罚的权重系数。算法首先产生一个合法的初始解作为当前解，然后交替使用均匀的权重和根据惩罚分布情况进行调整后的权重对当前解进行改进。改进的过程使用了一种多邻域禁忌搜索，其处理流程如算法~\ref{alg3}~所示。接下来将详细介绍用于单个阶段求解的算法实现细节。

\begin{algorithm}
	\footnotesize
	\caption{护士排班问题求解过程}
	\label{alg1}
	\begin{algorithmic}
		\REQUIRE $\textrm{算例数据}~Scenario, InitialHistory, Weekdata$;
		\ENSURE $\textrm{求得的最优排班计划}~X$;
		\STATE $h_0 \Leftarrow InitialHistory$;
		\STATE $i \Leftarrow 0$;
		\WHILE{$i < T$}
			\STATE $X_i \Leftarrow \textrm{WeightedTabuSearch}(Scenario, h_i, Weekdata_i)$;  // 见算法 \ref{alg2}
			\STATE $i \Leftarrow i+1$;
			\STATE $h_i \Leftarrow \textrm{GenerateHistory}(Scenario, X_i)$;
		\ENDWHILE
	\end{algorithmic}
\end{algorithm}

\begin{algorithm}
	\footnotesize
	\caption{求解护士排班问题的带权禁忌搜索算法框架}
	\label{alg2}
	\begin{algorithmic}
		\REQUIRE $\textrm{算例数据}~Scenario, History, Weekdata$;
		\ENSURE $\textrm{求得的本阶段的最优排班计划}~X_i$;
		\STATE $X_i \Leftarrow \textrm{GenerateInitialSolution}()$;  // 见 ~\ref{subsec:init}~节
		\REPEAT
			\STATE $\textrm{ResetWeight}(w)$;  // 见 ~\ref{subsec:weight}~节
			\STATE $s \Leftarrow \textrm{TabuSearch}(w)$;  // 见算法 \ref{alg3}
			\STATE $X_i \Leftarrow \textrm{min}\{ s, X_i \}$;
			\STATE $s \Leftarrow \textrm{SelectRandomly}(s, X_i)$; 	// 按概率随机选择一个
			\STATE $w \Leftarrow \textrm{AdjustWeightToBiasNurseWithGreaterPenalty}(s)$;  // 见 ~\ref{subsec:weight}~节
			\STATE $s \Leftarrow \textrm{TabuSearch}(w)$;  // 见算法 \ref{alg3}
		\UNTIL{满足停止条件}
	\end{algorithmic}
\end{algorithm}

\begin{algorithm}
	\footnotesize
	\caption{多邻域禁忌搜索算法伪代码}
	\label{alg3}
	\begin{algorithmic}
		\REQUIRE $\textrm{各护士的惩罚权重}~w$;
		\ENSURE $\textrm{求得的当前权重下本阶段的最优排班计划}~s$;
		\STATE $\textrm{InitializeNeighborhoodSelectionPossibility}(p)$;  // 见 ~\ref{subsec:select}~节
		\STATE $\textrm{InitializeTabuList}(t)$;  // 见 ~\ref{subsec:tabu}~节
		\REPEAT
			\STATE $n \Leftarrow \textrm{SelectNeighborhood}(p)$;  // 见 ~\ref{subsec:select}~节
			\STATE $m \Leftarrow \textrm{FindBestNeighborhoodMove}(n, t)$;  // 见 ~\ref{subsec:neighbor}~节
			\STATE $\textrm{UpdateTabuList}(t)$;  // 见 ~\ref{subsec:tabu}~节
			\STATE $\textrm{ApplyNeighborhoodMove}(m)$;
			\STATE $\textrm{UpdateNeighborhoodSelectionPossibility}(p, n, m)$;  // 见 ~\ref{subsec:select}~节
		\UNTIL{满足停止条件}
	\end{algorithmic}
\end{algorithm}

\subsection{初始解}
\label{subsec:init}

初始解的生成使用了贪心构造的方法，从阶段的第一天到最后一天依次确定排班计划。对于每一天，统计每个技能对护士的总需求量~$r$~，然后根据其与拥有该技能的护士数~$n$~的比例确定先确定哪个技能的排班。如果~$r/n$~小，说明该技能的排班比较容易满足，可以放到后面排；反之说明拥有该技能的护士人手短缺，应该优先考虑。算法将从~$r/n$~比较小的技能开始，按顺序确定当天各班次的人员安排。对于每个时间槽，在保证不违反硬约束的情况下，优先挑选拥有技能数更少的护士，这样做可以照顾到还未排班的技能。

由于本算法中的贪心构造方法比较简单，可能出现生成了非法解的情况，因此在贪心构造之后还需要对解进行修复。该修复过程与算法~\ref{alg3}~的过程相同，只是目标函数中所有软约束的权重被设置为0，而硬约束变得可以违反，并具有一定的权重。由于初始解的生成方式对求解质量影响非常微弱，故在此不做进一步介绍。

\subsection{邻域结构}
\label{subsec:neighbor}

对于一个给定的解向量~$X$~，可以通过一个变换模式将其变为若干新的解向量，这些新的解向量称为邻域解，使~$X$~变为邻域解中的某个解向量~$X'$~的变换称为邻域动作~$m$~，而这个变换模式即邻域结构。
令作用于~$X$~的邻域动作的集合为~$M(X)$~；
~C~为布尔表达式到整数的转换函数，如果布尔表达式为真取~$1$~,否则取~$0$~。
则对于护士排班问题可以定义如下邻域结构。

\begin{itemize}
	\item \textbf{增加班次。} 安排原本在第~$d$~天休息的护士~$n$~在第~$d$~天班次~$h$~技能~$k$~上班。该邻域动作的集合为
	\begin{equation}
	M_1(X) = \{ m_1(d, n, h, k) | \forall d \in D, \forall n \in N, x^H\phantom{}_{d,n} = \textrm{ShiftOff} \wedge h \ne \textrm{ShiftOff} \}
	\label{eq2}
	\end{equation}
	
	\item \textbf{减少班次。} 安排原本在第~$d$~天上班的护士~$n$~在第~$d$~天休息。该邻域动作的集合为
	\begin{equation}
	M_2(X) = \{ m_2(d, n) | \forall d \in D, \forall n \in N, x^H\phantom{}_{d,n} \ne \textrm{ShiftOff} \}
	\label{eq3}
	\end{equation}
	
	\item \textbf{变更班次。} 安排原本在第~$d$~天班次~$x^H\phantom{}_{d,n}$~技能~$x^K\phantom{}_{d,n}$~上班的护士~$n$~在第~$d$~天班次~$h$~技能~$k$~上班。该邻域动作的集合为	
	\begin{align}
		M_3(X) = \{ m_3(d, n, h', k') | & \forall d \in D, \forall n \in N, \forall h' \in H, x^H\phantom{}_{d,n} \ne \textrm{ShiftOff} \wedge h' \ne \textrm{ShiftOff} \nonumber \\
		 & \wedge ( x^H\phantom{}_{d,n} \ne h' \vee x^K\phantom{}_{d,n} \ne k' ) \}
		\label{eq4}
	\end{align}
	
	\item \textbf{交换班次。} 即块交换，交换两个护士~$n_1$~和~$n_2$~在第~$d_1$~到~$d_2$~天的排班。该邻域动作的集合为
	\begin{equation}
	M_4(X) = \{ m_4(d, n, h, k) | \forall d_1, d_2 \in D, \forall n_1, n_2 \in N, d_1 \le d_2 \wedge ( \sum_{d=d_1}^{d_2} \textrm{C}( x^H\phantom{}_{d,n_1} \ne x^H\phantom{}_{d,n_2} ) ) > 0 \}
	\label{eq5}
	\end{equation}
\end{itemize}

四种邻域结构中，增加、减少和变更班次的复杂度相对较小，而交换班次的复杂度较大。虽然多个前三种邻域动作的组合可以构成块交换的邻域动作，但是总是选择最大改进的邻域动作比较缺乏远见，容易错过能产生更大改进的邻域动作。另一方面，由于硬约束的存在，合法解空间会被分割成很多不相邻的部分，简单的动作可能无法跨越非法解组成的边界，从而导致算法不能对整个合法解空间进行搜索。因此，交换班次作为前三种邻域动作组合而成的复合邻域结构，具有极其重大的意义。

\subsection{邻域选择策略}
\label{subsec:select}

由于邻域数量众多，每次选择邻域动作都对所有邻域进行探索开销过大，每次应仅对少量甚至一个邻域进行评估。于是，邻域的选择策略的设计对算法性能的提升起到了至关重要的作用。

本算法采用了轮盘赌的策略，每种邻域~$M_i$~都有一定的概率~$p_i$~被选中，所有邻域被选中的概率和满足~$\sum p_i = 1$~。在禁忌搜索的每一次迭代中，都会在所有邻域中挑选一个邻域进行搜索，寻找具有最大改进的邻域动作。

概率~$p_i$~由权重~$\omega_i$~来控制，~$p_i = \omega_i / \sum \omega_i$~。在搜索过程中，算法将根据邻域~$M_i$~的表现动态调整其权重~$\omega_i$~。每得到一个邻域动作，都会满足改进了本轮搜索的最优解、改进了当前解、没有改进当前解但存在合法动作和不存在合法动作这~$4$~种情况之一。这~$4$~种情况反应了邻域对当前搜索过程的适应程度，越适应，对解向量产生改进的可能性越大。很显然，应该让更合适的邻域以更大的概率被选择，因此本算法设置了~$4$~个基准值~$\Omega_1$~到~$\Omega_4$~，分别与~$4$~种适应程度相对应，每执行一个邻域动作都将根据其效果向对应的基准值趋近。具体的调整策略为
\begin{equation}
\omega_i = 
\begin{cases} 
\omega_i + (\Omega_1 - \omega_i) / \lambda_1 & , m_i \textrm{改进了本轮搜索的最优解} \\
\omega_i + (\Omega_2 - \omega_i) / \lambda_2 & , m_i \textrm{改进了当前解} \\
\omega_i + (\Omega_3 - \omega_i) / \lambda_3 & , m_i \textrm{没有改进当前解但存在合法动作} \\
\omega_i + (\Omega_4 - \omega_i) / \lambda_4 & , m_i \textrm{不存在合法动作} \\
\end{cases}
\end{equation}
其中~$\lambda \in [1, +\infty )$~控制~$\omega$~向基准值趋近的速度。在其定义域内，~$\lambda$~越小收敛速度越快。

\subsection{惩罚权重调整策略}
\label{subsec:weight}

禁忌搜索是一个集中性较强的算法，为了增加算法的疏散性，本算法引入了每个护士的惩罚权重。由于问题中的连续工作和连续休息等软约束的存在，打破当前的排班模式的代价往往很大，很有可能在对解向量产生结构性改变之前就因为惩罚的急剧增长而落回原来的排班布局，或者一直在相似的排班之间做小幅改进。针对这种情况，本算法通过降低惩罚较少的护士的权重，削弱对次优排班模式进行大幅调整的惩罚，防止搜索陷入局部最优而无法探索更广阔的解空间。

护士惩罚权重的具体调整过程为，在全部护士中，选择惩罚少的~$r_1 \times N$~个护士，将其权重设为~$W_1$~，然后再在剩余护士中，随机选择~$r_2 \times N$~个护士，将其权重设为~$W_2$~，再将剩下的护士的权重设为~$W_3$~。其中有~$0 < W_1 < W_2 < W_3, r_1, r_2 \in [0, 1], r_1 + r_2 < 1$~。该调整过程的伪代码如算法~\ref{alg4}~所示。由于~$\mathbf{S_1}$~是针对时间槽的约束，无法准确评价单个护士在该约束上的惩罚，故统计护士的惩罚情况时未考虑该软约束。

\begin{algorithm}
	\footnotesize
	\caption{惩罚权重调整过程}
	\label{alg4}
	\begin{algorithmic}
		\REQUIRE $\textrm{护士集合}~N, \textrm{某个护士当前惩罚的计算函数}~f$;
		\ENSURE $\textrm{护士的惩罚权重}~w$;
		\STATE $n \Leftarrow \textrm{SortNurseByPenalty}(N, f)$;
		\STATE $i \Leftarrow 1$;
		\WHILE{$i < N \times r_1$}
			\STATE $w_{n_i} \Leftarrow W_1$;
			\STATE $i \Leftarrow i + 1$;
		\ENDWHILE
		\WHILE{$i < N$}
			\STATE $w_{n_i} \Leftarrow W_3$;
			\STATE $i \Leftarrow i + 1$;
		\ENDWHILE
		\STATE $i \Leftarrow 1$;
		\WHILE{$i < N \times r_2$}
			\STATE $j \Leftarrow \textrm{SelectNurseRandomly}(N)$;
			\IF{$w_j = W_3$}
				\STATE $w_j \Leftarrow W_2$;
				\STATE $i \Leftarrow i + 1$;
			\ENDIF
		\ENDWHILE
	\end{algorithmic}
\end{algorithm}

\subsection{禁忌策略}
\label{subsec:tabu}

本算法中另一个防止搜索过程陷入局部最优的策略是禁忌。而禁忌策略的关键因素为禁忌表的设计和禁忌步长的设置，由于禁忌步长的选取较为简单，本节将详细介绍禁忌表的设计。

禁忌搜索的核心思想在于记录已搜索过的解的特征或已执行过的邻域动作的特征，防止搜索路径在局部最优附近绕圈，甚至原路返回落回局部最优。
本算法对排班情况进行了记录，如果一个在第~$d$~天休息的护士~$n$~被安排上班，那么在接下来的一段时间里，护士~$n$~将保持第~$d$~天的排班，即不能在第~$d$~天被安排为休息；
如果一个在第~$d$~天班次~$h$~技能~$k$~上班的护士~$n$~被安排为休息或者在其他班次或技能上班，那么在接下来的一段时间里，护士~$n$~将不能被重新安排在时间槽~$(d,h,k)$~上班。

具体来说，本算法中使用了两个禁忌表。禁忌表~$T^D$~是一个~$N \times D$~的矩阵，如果~$T^D\phantom{}_{n,d}$~大于当前迭代步数表示禁止护士~$n$~在第~$d$~天被安排为休息。禁忌表~$T^H$~是一个~$N \times D \times H \times K$~的矩阵，~$T^H\phantom{}_{n,d,h,k}$~大于当前迭代步数表示禁止护士~$n$~被安排在时间槽~$(d,h,k)$~上班。
对于~$M_4$~这种复合邻域结构，需要将其分解为~$M_1$~至~$M_3$~的组合，再针对每个动作查询或设置禁忌表。在判断一个给定的块交换是否被禁忌时，有~$4$~种策略，它们分别为：总是允许、只要有一个非禁忌的子动作就允许、只要有一个子动作被禁忌则禁止以及被禁忌的子动作超过一定比例则禁止。由于~$M_4$~邻域较大，再加上多种动作交替选择，其陷入局部最优的可能性相对较小，同时为了方便增量评估缓存的设计（见~\ref{subsec:cache}~节），本算法总是认为~$M_4$~是非禁忌的。

\subsection{全局约束的近似评估}
\label{subsec:global}

软约束~$\mathbf{S_7}$~和~$\mathbf{S_8}$~在整个排班周期结束时才能被准确评估，但是先前阶段排班不合理会严重影响后续阶段的排班的效果，甚至导致后续阶段无法找到满足硬约束的排班计划。因此，在各阶段内部需要一个近似评估机制来估算本阶段的排班会对全局约束的造成多大的影响。本算法在两个部分使用了近似评估策略，其一是在计算本阶段的目标函数时，根据各护士的总排班数上下限、历史排班数和本阶段人员需求等因素估算本阶段排班对~$\mathbf{S_7}$~和~$\mathbf{S_8}$~的贡献；其二是在更新最优解时，根据本阶段的排班情况设计辅助目标函数，处理目标函数值相同的情况下最优解的取舍。本节将对这两种策略进行详细介绍。

首先，对于~$\mathbf{S_7}$~和~$\mathbf{S_8}$~的上限，本算法采用了均匀分配剩余排班数的处理方案。令~$A_n$~为护士~$n$~不计本阶段排班数的历史累计排班数，总排班数下限为~$A^L_n$~，上限为~$A^U_n$,则可以按如下公式计算护士~$n$~在第~$i$~个阶段的排班数上限~$A^U\phantom{}_{n,i}$~
\begin{equation}
A^U\phantom{}_{n,i} = (A^U_n - A_n) \times \frac{i}{T}
\end{equation}
相比于完全均匀分配各阶段的排班数，该方法更具灵活性，即如果前期需求不多，则中后期会放松该约束，剩余排班数较多的护士可以更多地排班；如果前期需求过多，则中后期会收紧该约束，保证最终排班数不会超出上限太多。

其次，本算法对~$\mathbf{S_7}$~中总排班数下限的处理为在整个排班周期的前半部分忽略该约束。由于合同规定的总排班数下限是针对整个排班周期的，而在开始的几个阶段中累计需求并不多，所以该约束很容易被违反。另外，因为连续性约束~$\mathbf{S_2}$~至~$\mathbf{S_4}$~的存在，各护士的排班可能出现不均衡的状态，即在最初的几个阶段里，某些护士排班比较满，但是某些护士休息比较多。介于上述两种情况，在排版周期的前期就考虑~$\mathbf{S_7}$~会鼓励算法增加总排班量，这样会导致后期护士的总排班数大幅超出合同规定的上限。因此，本算法将根据~$A^L_n / A^U_n$~确定从第几个阶段开始考虑。具体来说，对于总共有~$T$~个阶段的排版周期，将按如下规则计算护士~$n$~在第~$i$~个阶段的排班数下限~$A^L\phantom{}_{n,i}$~
\begin{equation}
A^L\phantom{}_{n,i} = 
\begin{cases} 
0 & , i < T \times \frac{A^L_n}{A^U_n} \\
(A^L_n - A_n) \times \frac{i}{T} & , i \ge T \times \frac{A^L_n}{A^U_n} \\
\end{cases}
\end{equation}

最后，考虑到对护士的需求往往超过了合同规定的工作量上限，本算法中辅助目标函数的设计以优先选择排班数较少的方案为目标，保证在不影响本阶段求解质量的情况下，尽可能地为后续阶段预留人力资源。对于两个目标函数值相同的解向量，可能因为其对违反约束的组成的不同而对后续阶段的排班产生不同的影响。例如，有的排班可能对总排班数上限违反较多，而对主要在本阶段内部发生作用的连续性约束和覆盖性约束违反很少，这种排班会对后续阶段产生较大的负面影响，反之，可以给后续阶段留出更多的调整空间。因此，本算法中辅助目标函数将更倾向于保留总排班数较少的解。其具体的计算方法为
\begin{equation}
f'(X) = \sum_{n=1}^{N} \frac{\sum_{d=1}^{D} \textrm{C}(X^H\phantom{}_{d,n} \ne \textrm{ShiftOff})}{A^U_n - A_n}
\end{equation}
其中求和式的分子部分为本阶段排班的累计排班数。由于不同护士的总排班数上限不同，辅助目标函数并不是直接统计所有护士的总排班数，而是统计各护士当前排班数占剩余排班数的比例之和，保证排班的均衡性。

\subsection{缓存策略}
\label{subsec:cache}

由于护士排班问题软约束众多，目标函数计算过程十分复杂。对于较大的邻域，邻域评估的运算量更加庞大。分析禁忌搜索算法每次只对当前解做小幅改动的特性，可知每次执行一个邻域动作，大多数邻域动作对目标函数的影响并未发生变化。因此，本算法使用了缓存机制，将邻域动作导致的目标函数的增量保存起来，加速邻域评估过程。

本算法中有多种邻域结构，而搜索过程中每次只挑选一个进行评估，如果对所有邻域都进行缓存，可能会导致较高的缓存失效率，从而降低命中率，并增加缓存维护的开销。下面将分析各种缓存策略的利弊，最终得出本算法使用的缓存策略。

对于~$M_1$~至~$M_3$~，~$M_1$~至~$M_4$~中所涉及的护士的所有~$M_1$~至~$M_4$~缓存全部失效，同时由于~$\mathbf{S_1}$~的存在，动作添加或删除排班的时间槽中所有其他护士的~$M_1$~至~$M_4$~在该时间槽的缓存全部失效。如果以时间槽为粒度对缓存有效性进行标记，会导致每次邻域动作需要对众多标记位进行设置，时间复杂度为~$O(n)$~；如果以护士为粒度，每次邻域动作只需对一个标记位进行设置，时间复杂度为~$O(1)$~，但是会导致较高的失效率。

对于~$M_4$~，~$M_1$~至~$M_4$~中所涉及的护士的所有~$M_1$~至~$M_4$~的缓存全部失效。由于两个护士交换不会改变各时间槽的人数，所以~$M_1$~至~$M_4$~并不会通过~$\mathbf{S_1}$~影响其他护士的~$M_4$~缓存。如果以护士为粒度对缓存有效性进行标记，则可以在~$O(1)$~的时间复杂度内更新标记位，即每次邻域动作的执行只会导致不超过~$2$~个缓存项失效。

再对算法的性能瓶颈进行分析，可知对~$M_1$~至~$M_3$~的增量评估虽然逻辑复杂，但其时间复杂度仍为~$O(D)$~，而~$M_4$~的时间复杂度则为~$O(N^2 \times D^3)$~，远大于其他邻域的复杂度，对其进行缓存将极大地减少重复计算。

因此，经过对各种策略的开销与收益的综合分析，本算法仅对~$M_4$~以护士为粒度对缓存有效性进行标记，对两个护士的任意起止天的块交换中的最优值进行缓存。

\section{计算结果}

\subsection{算例与运行环境}

第二届国际护士排班竞赛的算例包括初赛的~$14$~个数据集和决赛的~$6$~个数据集。所有数据集均由~$1$~个场景信息文件、~$3$~个初始历史信息文件和~$10$~个阶段需求信息文件组成。对于每个数据集，数据规模主要与护士数相关，而数据集中的护士数主要分布于~$30$~到~$120$~之间。具体运行时从中选取~$1$~个场景信息文件、~$1$~个初始历史信息文件和~$4$~个或~$8$~个阶段需求信息文件构成一个算例，这些文件按算法~\ref{alg1}~所示的流程依次输入求解程序。求解护士排班问题得到的目标函数值越小说明解向量的质量越好。本次竞赛使用的算例\footnote{数据集和算例可在http://mobiz.vives.be/inrc2/?page\_id=20下载。}与排名\footnote{决赛排名可在http://mobiz.vives.be/inrc2/?page\_id=241查看。}已公布于竞赛官方网站。

本算法使用~C++~编写，由~Visual C++ 2013~编译。程序的运行环境为~Windows Server 2012~操作系统，~Intel Xeon E5-2609 2.5GHz CPU~，~32GB~内存。运行时间由竞赛官方网站提供的基准测试程序\footnote{基准测试程序可在http://mobiz.vives.be/inrc2/?page\_id=245下载}求得，其给定的运行时间与护士数量成正比。

由于相同的数据集使用不同的文件序列可以构成大量算例，而随意挑选的序列不便于进行对比，本节将仅对决赛使用的算例进行测试。为了防止启发式算法的求解过程的随机性使结果出现较大偏差，竞赛组织者将每个算例独立重复运行了~$10$~次，而本文讨论与分析中使用了每个算例独立重复运行~$32$~次的统计结果。

\subsection{第二届国际护士排班竞赛结果对比}

\begin{table}[!t]
	\footnotesize
	\cnentablecaption{小规模算例计算结果}{Computational result on small scale instances}
	\label{tab1}
	\tabcolsep 10pt %space between two columns. 用于调整列间距
	\begin{tabular*}{\textwidth}{c|ccc|cc}
		\toprule
		Instance & Known best & Our best & Winner's best & Our Average & Winner's Average \\\hline
		n035w4\_2\_8-8-7-5         & 1255 & 1335 & 1255 & 1370.5 & 1367.5 \\   
		n035w4\_0\_1-7-1-8         & 1630 & 1685 & 1630 & 1756.5 & 1630 \\ 
		n035w4\_0\_4-2-1-6         & 1800 & 1970 & 1810 & 2021.5 & 1831.5 \\   
		n035w4\_0\_5-9-5-6         & 1755 & 1760 & 1755 & 1834.5 & 1755 \\ 
		n035w4\_0\_9-8-7-7         & 1540 & 1660 & 1545 & 1723.5 & 1586 \\ 
		n035w4\_1\_0-6-9-2         & 1500 & 1650 & 1525 & 1737 & 1545 \\   
		n035w4\_2\_8-6-7-1         & 1490 & 1600 & 1510 & 1644.5 & 1510 \\ 
		n035w4\_2\_9-2-2-6         & 1705 & 1895 & 1705 & 1947.5 & 1708 \\ 
		n035w4\_2\_9-7-2-2         & 1650 & 1940 & 1650 & 1970.5 & 1695 \\ 
		n035w4\_2\_9-9-2-1         & 1620 & 1880 & 1620 & 1927.5 & 1652 \\ 
		n035w8\_0\_6-2-9-8-7-7-9-8 & 3020 & 3505 & 99999 & 3628 & 99999 \\ 
		n035w8\_1\_0-8-1-6-1-7-2-0 & 2770 & 3405 & 2900 & 3653.5 & 12669.4 \\  
		n035w8\_1\_0-8-4-0-9-1-3-2 & 2775 & 3190 & 2870 & 3378.5 & 80576.7 \\  
		n035w8\_1\_1-4-4-9-3-5-3-2 & 2805 & 3180 & 2810 & 3325 & 2849.5 \\ 
		n035w8\_1\_7-0-6-2-1-1-1-6 & 2840 & 3440 & 2840 & 3548.5 & 2842 \\ 
		n035w8\_2\_2-1-7-1-8-7-4-2 & 2910 & 3445 & 3050 & 3672 & 90304.1 \\    
		n035w8\_2\_7-1-4-9-2-2-6-7 & 2960 & 3540 & 2960 & 3632.5 & 3028.5 \\   
		n035w8\_2\_8-8-7-5-0-0-6-9 & 2815 & 3385 & 2815 & 3603 & 2863 \\   
		n035w8\_2\_9-5-6-3-9-9-2-1 & 3045 & 3350 & 3045 & 3533.5 & 3083.5 \\   
		n035w8\_2\_9-7-2-2-5-7-4-3 & 2715 & 3295 & 2865 & 3488 & 2928 \\   
		\bottomrule
	\end{tabular*}
\end{table}

\begin{table}[!t]
	\footnotesize
	\cnentablecaption{中等规模算例计算结果}{Computational result on medium scale instances}
	\label{tab2}
	\tabcolsep 10pt %space between two columns. 用于调整列间距
	\begin{tabular*}{\textwidth}{c|ccc|cc}
		\toprule
		Instance & Known best & Our best & Winner's best & Our Average & Winner's Average \\\hline
		n070w4\_0\_3-6-5-1         & 2700 & 3090 & 2705 & 3151 & 2723 \\   
		n070w4\_0\_4-9-6-7         & 2430 & 2790 & 2430 & 2889 & 2446 \\   
		n070w4\_0\_4-9-7-6         & 2475 & 2865 & 2475 & 2948 & 2557.5 \\ 
		n070w4\_0\_8-6-0-8         & 2435 & 2855 & 2435 & 3016 & 2477 \\   
		n070w4\_0\_9-1-7-5         & 2320 & 2725 & 2320 & 2864 & 2323 \\   
		n070w4\_1\_1-3-8-8         & 2700 & 3035 & 2700 & 3134.5 & 2728 \\ 
		n070w4\_2\_0-5-6-8         & 2520 & 2880 & 2520 & 3012 & 2533 \\   
		n070w4\_2\_3-5-8-2         & 2615 & 3050 & 2615 & 3141.5 & 2635 \\ 
		n070w4\_2\_5-8-2-5         & 2540 & 2875 & 2540 & 3005.5 & 2544.5 \\   
		n070w4\_2\_9-5-6-5         & 2615 & 2975 & 2615 & 3046 & 2652 \\   
		n070w8\_0\_3-3-9-2-3-7-5-2 & 5115 & 6000 & 5115 & 6222 & 5164 \\   
		n070w8\_0\_9-3-0-7-2-1-1-0 & 5390 & 6420 & 5390 & 6602 & 5478.5 \\ 
		n070w8\_1\_5-6-8-5-7-8-5-6 & 5475 & 6095 & 5475 & 6236.5 & 5549 \\ 
		n070w8\_1\_9-8-9-9-2-8-1-4 & 5100 & 5700 & 5100 & 6018.5 & 5167 \\ 
		n070w8\_2\_4-9-2-0-2-7-0-6 & 5410 & 5990 & 5410 & 6259 & 5581.5 \\ 
		n070w8\_2\_5-1-3-0-8-0-5-8 & 5280 & 5975 & 5280 & 6315 & 5359.5 \\ 
		n070w8\_2\_5-7-4-8-7-2-9-9 & 5505 & 6210 & 5505 & 6317.5 & 5531.5 \\   
		n070w8\_2\_6-3-0-1-8-1-5-9 & 5120 & 5960 & 5120 & 6255 & 5240 \\   
		n070w8\_2\_8-6-0-1-6-4-7-8 & 5350 & 6205 & 5350 & 6492.5 & 7138.5 \\   
		n070w8\_2\_9-3-5-2-2-9-2-0 & 5320 & 5895 & 5320 & 6044.5 & 5374 \\   
		\bottomrule
	\end{tabular*}
\end{table}

\begin{table}[!t]
	\footnotesize
	\cnentablecaption{大规模算例计算结果}{Computational result on large scale instances}
	\label{tab3}
	\tabcolsep 10pt %space between two columns. 用于调整列间距
	\begin{tabular*}{\textwidth}{c|ccc|cc}
		\toprule
		Instance & Known best & Our best & Winner's best & Our Average & Winner's Average \\\hline
		n110w4\_0\_1-4-2-8         & 2710 & 3395 & 2720 & 3539 & 2725 \\   
		n110w4\_0\_1-9-3-5         & 2920 & 3475 & 2970 & 3663 & 3065 \\   
		n110w4\_1\_0-1-6-4         & 2850 & 3685 & 2920 & 3769 & 12690.4 \\    
		n110w4\_1\_0-5-8-8         & 2820 & 3440 & 2895 & 3569.5 & 3210 \\ 
		n110w4\_1\_2-9-2-0         & 3345 & 3995 & 3380 & 4092 & 3425 \\   
		n110w4\_1\_4-8-7-2         & 2805 & 3515 & 2805 & 3661 & 2855.5 \\ 
		n110w4\_2\_0-2-7-0         & 3005 & 3795 & 3175 & 3903.5 & 51625.5 \\  
		n110w4\_2\_5-1-3-0         & 2925 & 3520 & 3025 & 3637.5 & 3095 \\ 
		n110w4\_2\_8-9-9-2         & 3415 & 3895 & 3470 & 4025 & 3502.5 \\ 
		n110w4\_2\_9-8-4-9         & 3135 & 3640 & 3335 & 3769 & 3540 \\   
		n110w8\_0\_2-1-1-7-2-6-4-7 & 5155 & 6420 & 5165 & 6596 & 5243 \\   
		n110w8\_0\_3-2-4-9-4-1-3-7 & 4805 & 6015 & 4830 & 6172.5 & 4982.5 \\   
		n110w8\_0\_5-5-2-2-5-3-4-7 & 4750 & 6065 & 4870 & 6227 & 4939 \\   
		n110w8\_0\_7-8-7-5-9-7-8-1 & 4855 & 6105 & 5005 & 6251.5 & 5234 \\ 
		n110w8\_0\_8-8-0-2-3-4-6-3 & 4465 & 5920 & 4955 & 6146.5 & 5021.5 \\   
		n110w8\_0\_8-8-2-2-3-2-0-8 & 4865 & 6310 & 5435 & 6469 & 5510.5 \\ 
		n110w8\_1\_0-6-1-0-3-2-9-1 & 5090 & 6330 & 5175 & 6514 & 5259.5 \\ 
		n110w8\_1\_4-1-3-6-8-8-1-3 & 4315 & 5925 & 4785 & 6115.5 & 4842.5 \\   
		n110w8\_2\_2-9-5-5-1-8-4-0 & 4770 & 5840 & 5200 & 6222.5 & 5274 \\ 
		n110w8\_2\_8-5-7-3-9-8-8-5 & 4360 & 5540 & 4765 & 5809 & 5292 \\  
		\bottomrule
	\end{tabular*}
\end{table}

本算法在决赛中取得了第四名的成绩。相比于其他进入决赛的队伍，前两名在大多数算例上保持了一定的优势，但是都存在无法于给定时间内求得合法解的情况，其中第一名的算法在组委会提供的环境下进行的~$600$~次运行中，有~$34$~次产生了非法解，而本算法均能产生合法解，故本算法在稳定性上与前两名相比有一定的优势。
%由于本次竞赛的排名方案并未对产生非法解的情况施加严格的惩罚机制，前两名凭借在大多数算例上积累的巨大优势保持了其领先地位。

决赛中一共使用了三种规模的数据集，小规模、中等规模和大规模算例的计算结果分别如表~\ref{tab1}~、表~\ref{tab2}~和表~\ref{tab3}~所示。对于求出非法解的情况，竞赛组委会将其目标函数值设为一个大于所有参赛者所求目标函数值的数值，在本次竞赛中为~$99999$~。从结果对比可以看出，本算法的最优解质量离第一名均有一定差距，但是本算法对不同算例的适应性更好，而第一名的算法在算例~n035w8\_0\_6-2-9-8-7-7-9-8~上~$10$~次运行均没有求出合法解，同时在多个算例上产生了非法解，导致其在这些算例上的平均求解质量不如本算法。


\section{分析与讨论}

第~\ref{sec:implement}~节中描述了算法的关键模块和策略，本节将对本算法使用的策略与其他可能的策略进行对比分析，以阐明选择这些方案的原因。

\subsection{邻域结构效果对比分析}

\begin{figure}[!t]
	\centering
	\begin{minipage}[c]{0.48\textwidth}
		\centering
		\begin{tikzpicture}
		\begin{axis}[
		title={},
		xlabel={Iteration (~$\log_ai$~)},
		ylabel={Best objective value found so far}, y label style={at={(0.05,0.5)}},
		xmin=0, xmax=100,
		ymin=0, ymax=240,
		xtick={0,20,40,60,80,100},
		ytick={0,40,80,120,160,200,240},
		legend pos=north east,
		ymajorgrids=true,
		grid style=dashed,
		width = \textwidth,% height = 3in,
		]
		
		\addplot[
		color=blue,
		mark=square, % triangle, diamond, o, *, x, +, asterisk
		]
		coordinates {
			(0,222)(10,211)(20,190)(30,175)(40,158)(60,131)(80,117)(100,26)
		};
		\addplot[
		color=red,
		mark=triangle,
		]
		coordinates {
			(0,233)(10,221)(20,198)(30,185)(40,148)(60,151)(80,117)(100,88)
		};
		\legend{with~$M_4$~, without~$M_4$~}
		
		\end{axis}
		\end{tikzpicture}
	\end{minipage}
	%\hspace{0.04\textwidth}
	\begin{minipage}[c]{0.48\textwidth}
		\centering
		\begin{tikzpicture}
		\begin{axis}[
		title={},
		xlabel={Time (~$\log_at$~ seconds)},
		ylabel={Best objective value found so far}, y label style={at={(0.05,0.5)}},
		xmin=0, xmax=100,
		ymin=0, ymax=240,
		xtick={0,20,40,60,80,100},
		ytick={0,40,80,120,160,200,240},
		legend pos=north east,
		ymajorgrids=true,
		grid style=dashed,
		width = \textwidth,% height = 3in,
		]
		
		\addplot[
		color=blue,
		mark=square, % triangle, diamond, o, *, x, +, asterisk
		]
		coordinates {
			(0,222)(10,211)(20,190)(30,175)(40,158)(60,131)(80,117)(100,26)
		};
		\addplot[
		color=red,
		mark=triangle,
		]
		coordinates {
			(0,233)(10,221)(20,198)(30,185)(40,148)(60,151)(80,117)(100,88)
		};
		\legend{with~$M_4$~, without~$M_4$~}
		
		\end{axis}
		\end{tikzpicture}
	\end{minipage}
	\cnenfigcaption{块交换邻域的重要性}{Significance of block swap neighborhood. (a) measursed by iteration; (b) measured by time}
	\label{fig1}
\end{figure}

虽然~$M_4$~理论上可以多个由~$M_1$~至~$M_3$~组合而成，但是其在本算法中仍起到了至关重要的作用。图~\ref{fig1}~分别从迭代次数和运行时间两个角度展示了有无~$M_4$~时算法的收敛速度，所用数据来自于一个小规模算例和一个大规模算例的~$32$~次独立运行中对应时间刻度位置取样所得的平均值。其横坐标为时间刻度，纵坐标表示截止当前时间点算法所求得的最优目标函数值。由于每次运行分为多个阶段，所以无法对整个排班周期的目标函数值的收敛情况进行分析。因此图~\ref{fig1}~中的目标函数值均为第一阶段的近似目标函数值（见~\ref{subsec:global}~节）。另外，因为算法初期收敛速度非常快，而后期目标函数值变化幅度较小，导致等间隔取样的结果不便于观察比较。故图中横坐标为对时间刻度取对数的结果，即~$x= \log_at$~，其中~$a=1.08$~，~$t$~为取样的时间点。

从图~\ref{fig1}~中可以看出，以迭代次数为取样间隔时，块交换对收敛速度的加速效果尤为明显。但是由于其时间复杂度较高，故以秒为取样间隔时加速效果没有那么显著，但仍有较大优势，且收敛的极限优于没有块交换的情况。由此可见，块交换邻域无论从短期的收敛速度来考虑，还是从长期的目标函数值下限来考虑，都发挥了重要的积极作用。

\subsection{疏散性搜索策略对比分析}

\begin{table}[!t]
	\footnotesize
	\cnentablecaption{疏散性过程的计算结果对比}{Comparison of computational results between diversification procedures}
	\label{tab4}
	\tabcolsep 6pt %space between two columns. 用于调整列间距
	\begin{tabular*}{\textwidth}{c|ccc|ccc}
		\toprule
		\multirow{2}{*}{Instance} & \multicolumn{3}{c|}{Best} & \multicolumn{3}{c}{Average} \\\cline{2-7}
		 & Pure TS & Partial rebuild & Adjust Weight & Pure TS & Partial rebuild & Adjust Weight \\\hline
		n035w4\_0\_1-7-1-8         & 1630 & 1685 & 1630 & 1756.5 & 1630 & \\ 
		n035w4\_1\_0-6-9-2         & 1500 & 1650 & 1525 & 1737 & 1545 & \\   
		n035w4\_2\_8-6-7-1         & 1490 & 1600 & 1510 & 1644.5 & 1510 & \\ 
		n035w8\_0\_6-2-9-8-7-7-9-8 & 3020 & 3505 & 99999 & 3628 & 99999 & \\ 
		n035w8\_1\_0-8-1-6-1-7-2-0 & 2770 & 3405 & 2900 & 3653.5 & 12669.4 & \\  
		n035w8\_2\_2-1-7-1-8-7-4-2 & 2910 & 3445 & 3050 & 3672 & 90304.1 & \\ 
		n070w4\_0\_3-6-5-1         & 2700 & 3090 & 2705 & 3151 & 2723 & \\   
		n070w4\_1\_1-3-8-8         & 2700 & 3035 & 2700 & 3134.5 & 2728 & \\ 
		n070w4\_2\_0-5-6-8         & 2520 & 2880 & 2520 & 3012 & 2533 & \\   
		n070w8\_0\_3-3-9-2-3-7-5-2 & 5115 & 6000 & 5115 & 6222 & 5164 & \\   
		n070w8\_1\_5-6-8-5-7-8-5-6 & 5475 & 6095 & 5475 & 6236.5 & 5549 & \\ 
		n070w8\_2\_4-9-2-0-2-7-0-6 & 5410 & 5990 & 5410 & 6259 & 5581.5 & \\ 
		n110w4\_0\_1-4-2-8         & 2710 & 3395 & 2720 & 3539 & 2725 & \\   
		n110w4\_1\_0-1-6-4         & 2850 & 3685 & 2920 & 3769 & 12690.4 & \\    
		n110w4\_2\_0-2-7-0         & 3005 & 3795 & 3175 & 3903.5 & 51625.5 & \\  
		n110w8\_0\_2-1-1-7-2-6-4-7 & 5155 & 6420 & 5165 & 6596 & 5243 & \\   
		n110w8\_1\_0-6-1-0-3-2-9-1 & 5090 & 6330 & 5175 & 6514 & 5259.5 & \\ 
		n110w8\_2\_2-9-5-5-1-8-4-0 & 4770 & 5840 & 5200 & 6222.5 & 5274 & \\ 
		\bottomrule
	\end{tabular*}
\end{table}

观察目标函数值的组成可以发现，不同护士的惩罚差异很大，因此~\ref{subsec:weight}~节所述权重调整策略应该能改善单纯的禁忌搜索集中性太强的不足，为算法提供一个有导向而非盲目的疏散性搜索过程。为了验证这个猜想，本文对比了单纯的禁忌搜索、使用了保留解向量的部分元素然后对其贪心构造和修复直至重新产生合法解的扰动策略的禁忌搜索和使用了权重调整策略的禁忌搜索的计算结果。从表~\ref{tab4}~可以看出，















\subsection{全局约束近似评估策略对比分析}

为了讨论全局约束的近似评估策略对算法的影响，算法














\section{总结}

本文提出了一种用于求解多阶段护士排班问题的启发式算法。在对第二届国际护士排班竞赛所涉及的问题进行了简要的介绍之后，本文详细描述了带权禁忌搜索算法。算法以禁忌搜索为核心，通过调整护士的惩罚权重来实现搜索过程中集中性与疏散性的平衡。算法使用了增加班次、减少班次、变更班次和交换班次~$4$~种邻域结构，并使用了一种根据其适应性动态调整各邻域被选中的概率的策略。为了解决全局约束无法在单个阶段计算的问题，算法使用了一种近似评估方案来衡量各阶段的排班对全局约束产生的贡献。
此外，本文通过对比试验展示了不同邻域结构对收敛速度产生的影响，得出了权重调整策略对提升求解质量具有重要意义的结论，证明了全局约束的近似评估策略的合理性。

第二届护士排班竞赛的计算结果充分证明了算法的有效性。在决赛的~$60$~个算例上，算法在保证结果合法性的同时，求解质量也接近目前已知的最优解，最终在第二届国际护士排班竞赛中获得了全球第~$4$~名的成绩。
但是，由于算法使用的邻域变化模式比较简单，对于约束众多的问题，容易陷入局部最优，或者难以跨过非法解以探索更广阔的解空间。因此可以考虑增加更大的邻域，对解空间进行更充分的探索。与此同时，对全局约束的近似评估策略也可以有更细致的考量，让算法对多阶段问题的求解更接近掌握了整个排班周期的完整信息的理想状态。

值得注意的是，带权禁忌搜索的思想并不局限于护士排班问题的求解，其对解向量产生有潜力的结构性改变的能力，可以在很多组合优化问题中得到应用，为算法提供有导向的疏散性搜索。而算法对多阶段问题的求解能力，更接近大多数问题的现实情况。对不确定因素和易变因素进行考虑，将使理论问题更具有实际意义和应用价值。



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% 致谢, 非必选
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\Acknowledgements{}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% 补充材料说明, 非必选
%%% 有补充材料时请添加补充材料说明, 例如图S1~S5
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\Supplements{图S1$\sim$S5.}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% 参考文献, {}为引用的标签, 数字/字母均可
%%% 文中上标引用: \upcite{1,2}
%%% 文中正常引用: \cite{1,2}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\bibliography{bib}{}
\bibliographystyle{plain}
%\begin{thebibliography}{99}
%
%% 专著
%% 作者名. 书名. 版次(第一版不用列出). 出版社所在城市名: 出版社名, 出版年份. 起止页码
%\bibitem{1}Gaydon A G, Wolfhard H G. Flames. 2nd ed. London: Chapman and Hall Ltd, 1960. 30--35
%
%% 期刊
%% 作者名. 文章题目(用小写字母). 期刊名, 年份, 卷号: 起止页码
%\bibitem{2}Xu Y B, Shen L S, Susan R M. Extension of the rice DH population genetic map with microsatellite markers. Chin Sci Bull, 1998, 43:149--153
%\bibitem{3}Hutton B. Product of fuzzy topological space. Topology Appl, 1980, 11: 59--61
%\bibitem{4}Wang K J, Zhang J Y, Li D, et al. Adaptive affinity propagation clustering. Act Autom Sin, 2007, 33: 1242--1246 [王开军, 张军英, 李丹, 等. 自适应仿射传播聚类. 自动化学报, 2007, 33: 1242--1246]
%
%% 论文集
%% 作者名. 文章题目. In: 编者名, eds. 论文集名称. 出版社所在城市名: 出版社名, 出版年份. 起止页码
%\bibitem{5}Polito V S. Calmodulin and calmodulin inhibitors: effect on pollen germination and tube growth. In: Mulvshy D L, Ottaviaro E, eds. Pollen: Biology and Implication for Plant Breeding. New York: Elsevier, 1983. 53--60
%
%% 会议论文集 (必须是正式出版的, 否则只能作为脚注)
%% 作者名. 文章题目. In: Proceedings of 会议名称. 出版社所在城市名: 出版社名, 出版年份. 起止页码
%% 作者名. 文章题目. In: Proceedings of 会议名称, 会议地点, 会议年份. 起止页码
%\bibitem{6}Dmtriev V. Complete tables of the second rank constitutive tensors for linear homogeneous bianisotropic media described by point magnetic groups of symmetry and some general properties of the media. In: Proceedings of IEEE MTT-S IMOC' 99. Berlin: Springer, 2000. 435--439
%
%% 学位论文
%% 作者名. 文题. 学位. 学校所在城市名: 学校名, 年份
%\bibitem{7}Wang X M. Study on Data Visualization Methods and Related Techniques for Clustering. Dissertation for Ph.D. Degree. Beijing: Tsinghua University, 2006 [王晓明. 面向聚类的数据可视化方法及相关技术研究. 博士学位论文. 北京: 清华大学, 2006]
%
%% 技术报告
%% 作者名. 报告名. 报告编号. 年份
%\bibitem{8}Phillips N A. The Nested Grid Model. NOAA Technical Report NWS22. 1979
%
%% 专利文献
%% 作者名. 专利国籍, 专利号
%\bibitem{9}Plank C J, Posinski E J. US Patent, 4 081 490, 1978-02-15
%
%% 使用手册
%% 作者名. 手册名及版本号, 年份
%\bibitem{10}Wang D L, Zhu J, Li Z K, et al. User Manual for QTKMapper Version 1.6, 1999
%
%\end{thebibliography}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% 附录章节, 非必选
%%% 自动从A编号, 以\section开始一节
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\begin{appendix}
%\section{appendix1}

%\end{appendix}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% 自动生成英文标题部分
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\makeentitle

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% 主要作者英文简介, 数量不超过4个
%%% \authorcv[照片文件名]{姓名}{英文介绍}
%%% [照片文件名]请提供清晰的一寸浅色背景照片, 宽高比为 25:35
%%% {姓名}与英文标题处一致
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\authorcv[]{}{}

\authorcv[]{}{}

%\vspace*{6mm} % 调整照片行间距

\authorcv[]{}{}

\authorcv[]{}{}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% 补充材料, 以补充材料形式作网络在线, 不出现在印刷版中
%%% 自动从I编号, 以\section开始一节
%%% 可以没有\section
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\begin{supplement}
%\section{supplement1}

%\end{supplement}

\end{document}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% 本模板使用的latex排版示例
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%% 章节
\section{}
\subsection{}
\subsubsection{}


%%% 列表
\begin{itemize}
\item Aaa aaa.
\item Bbb bbb.
\item Ccc ccc.
\end{itemize}


%%% 定义、定理、引理、推论
%%% []中的名称可以省略
\definition[定义名]{定义内容.}
\theorem[定理名]{定理内容.}
\lemma[引理名]{引理内容.}
\corollary[推论名]{推论内容.}

%%% 若使用定理样式的其他前缀
%%% 在 "作者附加的定义" 处加入\newtheorem命令, 例如
%%% "定理" 是由以下命令定义的
\newtheorem{theorem}{定理}


%%% 单图
%%% 可在文中使用图\ref{fig1}引用图编号
\begin{figure}[!t]
\centering
\includegraphics{fig1.eps}
\cnenfigcaption{中文图题}{Caption}
\label{fig1}
\end{figure}

%%% 并排图
%%% 可在文中使用图\ref{fig1}、图\ref{fig2}引用图编号
\begin{figure}[!t]
\centering
\begin{minipage}[c]{0.48\textwidth}
\centering
\includegraphics{fig1.eps}
\end{minipage}
\hspace{0.02\textwidth}
\begin{minipage}[c]{0.48\textwidth}
\centering
\includegraphics{fig2.eps}
\end{minipage}\\[3mm]
\begin{minipage}[t]{0.48\textwidth}
\centering
\cnenfigcaption{中文图题1}{Caption1}
\label{fig1}
\end{minipage}
\hspace{0.02\textwidth}
\begin{minipage}[t]{0.48\textwidth}
\centering
\cnenfigcaption{中文图题2}{Caption2}
\label{fig2}
\end{minipage}
\end{figure}

%%% 并排子图
%%% 需要英文分图题 (a)...; (b)...
\begin{figure}[!t]
\centering
\begin{minipage}[c]{0.48\textwidth}
\centering
\includegraphics{subfig1.eps}
\end{minipage}
\hspace{0.02\textwidth}
\begin{minipage}[c]{0.48\textwidth}
\centering
\includegraphics{subfig2.eps}
\end{minipage}
\cnenfigcaption{中文图题}{Caption. (a) Subfig1 caption; (b) subfig2 caption}
\label{fig1}
\end{figure}

%%% 算法
%%% 可在文中使用 算法\ref{alg1} 引用算法编号
\begin{algorithm}
\footnotesize
\caption{算法标题}
\label{alg1}
\begin{algorithmic}
    \REQUIRE $n \geq 0 \vee x \neq 0$;
    \ENSURE $y = x^n$;
    \STATE $y \Leftarrow 1$;
    \IF{$n < 0$}
        \STATE $X \Leftarrow 1 / x$;
        \STATE $N \Leftarrow -n$;
    \ELSE
        \STATE $X \Leftarrow x$;
        \STATE $N \Leftarrow n$;
    \ENDIF
    \WHILE{$N \neq 0$}
        \IF{$N$ is even}
            \STATE $X \Leftarrow X \times X$;
            \STATE $N \Leftarrow N / 2$;
        \ELSE[$N$ is odd]
            \STATE $y \Leftarrow y \times X$;
            \STATE $N \Leftarrow N - 1$;
        \ENDIF
    \ENDWHILE
\end{algorithmic}
\end{algorithm}

%%% 简单表格
%%% 可在文中使用 表\ref{tab1} 引用表编号
\begin{table}[!t]
\footnotesize
\cnentablecaption{表题}{Caption}
\label{tab1}
\tabcolsep 10pt %space between two columns. 用于调整列间距
\begin{tabular*}{\textwidth}{cccc}
\toprule
  Title a & Title b & Title c & Title d \\\hline
  Aaa & Bbb & Ccc & Ddd\\
  Aaa & Bbb & Ccc & Ddd\\
  Aaa & Bbb & Ccc & Ddd\\
\bottomrule
\end{tabular*}
\end{table}

%%% 换行表格
\begin{table}[!t]
\footnotesize
\cnentablecaption{表题}{Caption}
\label{tab1}
\def\tabblank{\hspace*{10mm}} %blank leaving of both side of the table. 左右两边的留白
\begin{tabularx}{\textwidth} %using p{?mm} to define the width of a column. 用p{?mm}控制列宽
{@{\tabblank}@{\extracolsep{\fill}}cccp{100mm}@{\tabblank}}
\toprule
  Title a & Title b & Title c & Title d \\\hline
  Aaa & Bbb & Ccc & Ddd ddd ddd ddd.

  Ddd ddd ddd ddd ddd ddd ddd ddd ddd ddd ddd ddd ddd ddd ddd ddd ddd ddd ddd ddd ddd ddd ddd ddd ddd ddd ddd ddd ddd ddd ddd.\\
  Aaa & Bbb & Ccc & Ddd ddd ddd ddd.\\
  Aaa & Bbb & Ccc & Ddd ddd ddd ddd.\\
\bottomrule
\end{tabularx}
\end{table}

%%% 单行公式
%%% 可在文中使用 (\ref{eq1})式 引用公式编号
%%% 如果是句子开头, 使用 公式(\ref{eq1}) 引用
\begin{equation}
A(d,f)=d^{l}a^{d}(f),
\label{eq1}
\end{equation}

%%% 不编号的单行公式
\begin{equation}
\nonumber
A(d,f)=d^{l}a^{d}(f),
\end{equation}

%%% 公式组
\begin{eqnarray}
\nonumber
&X=[x_{11},x_{12},\ldots,x_{ij},\ldots ,x_{n-1,n}]^{\rm T},\\
\nonumber
&\varepsilon=[e_{11},e_{12},\ldots ,e_{ij},\ldots ,e_{n-1,n}],\\
\nonumber
&T=[t_{11},t_{12},\ldots ,t_{ij},\ldots ,t_{n-1,n}].
\end{eqnarray}

%%% 条件公式
\begin{eqnarray}
\sum_{j=1}^{n}x_{ij}-\sum_{k=1}^{n}x_{ki}=
\left\{
\begin{aligned}
1,&\quad i=1,\\
0,&\quad i=2,\ldots ,n-1,\\
-1,&\quad i=n.
\end{aligned}
\right.
\label{eq1}
\end{eqnarray}

%%% 其他格式
\footnote{Comments.} %footnote. 脚注
\raisebox{-1pt}[0mm][0mm]{xxxx} %put xxxx upper or lower. 控制xxxx的垂直位置