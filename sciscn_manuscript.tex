%-----------------------------------------------------------------------
% 中国科学: 信息科学 中文模板, 请用 CCT & LaTeX 编译
% 请作者注意: 在整篇文章中, 不要使用任何改变文章版式的命令, 谢谢.
%-----------------------------------------------------------------------

\documentclass{SCIS2015cnauthor}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% 作者附加的定义
%%% 常用环境已经加载好, 不需要重复加载
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage{ccmap}
\usepackage{etex}
\usepackage{pgfplots}
\usepackage{multirow}
\usepackage{threeparttable}
\usepackage{graphicx}
\usepackage{epstopdf}

\renewcommand{\algorithmicrequire}{\textbf{Input:}}
\renewcommand{\algorithmicensure}{\textbf{Output:}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% 开始
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{document}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Authors do not modify the information below
%%% 作者不需要修改此处信息
\ArticleType{20truemm}{论~~~文}{}
\Year{2014}
\Vol{44}
\No{1}
\BeginPage{1}
\EndPage{?}
\DOI{xxxxxxxx}
\ReceiveDate{xxxxxxxx}
\AcceptDate{xxxxxxxx}
\OnlineDate{}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% 标题部分
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%% 标题 \title{正文标题}{引用的标题}
\title{求解多阶段护士排班问题的带权禁忌搜索算法}{}

%%% 英文题目, 只有第一个单词的首字母大写, 其余单词非专有名词全部小写
\entitle{Weighted tabu search for multi-stage nurse rostering problem}


%%% 通信作者 \author[number]{姓名}{{abc@xxxx.xxx}}
%%% 一般作者 \author[number]{姓名}{}
%%% 使用带圈标号 \ding{172},\ding{173},\ding{174},\ding{175},\ding{176}
\author[\ding{172}]{苏宙行}{}
\author[\ding{172}]{王卓}{{wang\_zhuo@hust.edu.cn}}
\author[\ding{172}]{吕志鹏}{}

%%% 英文作者, 每行一个, []中写地址编号(1,2,3等), 与中文对应
%%% 姓的拼音字母全部大写, 名的拼音首字母大写
%%% 通信作者 \enauthor[number]{AAA BbbCcc}{{abc@xxxx.xxx}}
%%% 一般作者 \enauthor[number]{AAA BbbCcc}{}
\enauthor[1]{SU ZhouXing}{}
\enauthor[1]{WANG Zhuo}{{wang\_zhuo@hust.edu.cn}}
\enauthor[1]{L\"{U} ZhiPeng}{}


%%% 地址 \address[number]{地址, 城市 邮编}
\address[\ding{172}]{华中科技大学计算机科学与技术学院智慧计算与优化实验室, 武汉~430074}
%\address[\ding{173}]{地址, 武汉 430074}

%%% 英文地址, 每行一个, []中写地址编号(1,2,3等), 与中文对应, 需要写国家
%%% \enaddress[number]{Address, City {\rm 000000}, Country}
\enaddress[1]{The Laboratory of Smart Computing and Optimization, School of Computer Science and Technology, Huazhong University of Science and Technology, Wuhan {\rm 430074}, China}
%\enaddress[2]{Address, City {\rm 000000}, Country}


%%% 项目资助信息
%%% 国家自然科学基金 (批准号: 0000000, 0000000, 00000000),
%%% 国家高技术研究发展计划 (863计划) (批准号: 0000000, 0000000, 00000000) 和
%%% 国家重点基础研究发展计划 (973计划) (批准号: 0000000, 0000000, 00000000) 资助项目
\Foundation{}

%%% 页眉中的作者信息 \AuthorMark{第一作者等}
%%% 若只有一个作者去掉"等"
\AuthorMark{姓名等}

%%% 引用中的作者信息 \AuthorCitation{第一作者, 第二作者, 第三作者, 等}
%%% 少于三个作者去掉"等"
\AuthorCitation{姓名, 姓名}

\maketitle

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% 摘要和关键词
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%% 中文摘要
\abstract{
	本文研究了多阶段护士排班问题, 该问题由第二届国际护士排班竞赛提出, 在医疗优化领域具有重要的意义. 针对多阶段护士排班问题, 本文提出了一种带权禁忌搜索算法. 该算法使用了三种互斥的简单邻域结构与一种复合邻域结构, 并根据其适应性动态调整搜索各邻域的概率. 同时, 通过调整各护士的惩罚权重来实现搜索过程中集中性与疏散性的平衡. 为了应对各个独立的阶段缺乏全局信息的问题, 提出了一种对全局约束的近似评估策略. 算法还针对自适应的邻域选择策略, 以减少多种邻域的整体计算开销为目标设计了邻域评估的缓存策略, 进一步提升了算法的执行效率. 算法在竞赛使用的~$60$~个算例上的计算结果表明了算法的有效性, 最终在第二届国际护士排班竞赛决赛排名全球第四. 此外, 本文对算法中的关键要素进行了对比分析, 表明了这些组成部分的方案选择和参数设置的合理性.
}

%%% 英文摘要
\enabstract{
	This paper studies multi-stage nurse rostering problem which is proposed in the Second International Nurse Rostering Competition. It is very important in healthcare optimization. We propose a weighted tabu search algorithm for solving multi-stage nurse rostering problem. The algorithm employs $3$ simple neighborhood structures which are exclusive to each other and $1$ compound one. The possibilities of selecting each neighborhood to search are tuned by their adaptiveness dynamically. Meanwhile, the balance between intensification and diversification during the search procedure is achieved by adjusting weight of penalty on each nurse. To tackle the problem of lacking global information within each independent stage, we propose an approximate evaluation strategy for spanning constraints. The algorithm employs cache for neighborhood move evaluation with the purpose of reducing overall cost of computation for the adaptive neighborhood selection strategy, which improves the efficiency of the algorithm further. The benchmark result of our algorithm on $60$ instances from the competition shows good solving quality and ranks fourth in the final of the Second International Nurse Rostering Competition. Furthermore, we compare and analyze some key factors in the algorithm and demonstrate their rationality.
}


%%% 中文关键词, \keywords{...\quad ...\quad ...\quad ...\quad ...}
%%% 多个关键词之间用\quad隔开
%%% 要求5-8个, 请尽量补充EI数据库中的受控词为关键词, 谢谢!
\keywords{护士排班\quad 禁忌搜索\quad 时刻表规划\quad 人员排班\quad 元启发式\quad 组合优化}

%%% 英文关键词, \enkeywords{..., ..., ..., ..., ...}
%%% 非专有名词全部小写, 与中文对应
\enkeywords{nurse rostering, tabu search, timetabling, personnel scheduling, metaheuristic, combinatorial optimization}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% 正文部分
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{引言}

随着医疗行业的发展, 医院拥有了越来越多的医务人员、医疗设备和病房, 同时也面临满足更多病人的需求. 于是, 更合理地利用各种资源来为更多的病人提供更好的服务的重要性正日益凸显. 在众多资源当中, 医护人员起到了支配性作用, 无疑是优化资源利用率的关键因素. 所以, 合理的人员排班显得尤为重要. 适当的工作量可以保证病人的病情不被延误, 同时可以保证医务人员有足够的休息时间, 以保持较高的工作效率.

作为一个具体的人员排班问题, 护士排班问题需要给出每天每个班次有哪些护士需要上班, 即一个人员排班表. 该排班表必须满足多种硬约束, 如各班次各岗位的人数达到需求下限、避免不合理的排班模式以及一个护士在同一天只能排一个班次等. 同时, 排班表还应尽量满足工作量上限、连续工作天数上下限、周末工作天数上限以及护士的特殊需求等软约束~\upcite{cheang2003nurse,burke2004state,de2011categorisation}.

由于每天每班次每岗位上班的护士可以从拥有该岗位所需技能的护士中任意挑选, 其人员选择已经具有组合数级别的复杂度, 同时对整个排班周期进行排班又需要指数级别的复杂度来完成. 此外, 众多的软约束之间相互作用, 此消彼涨. 因此, 护士排班问题无论是对医院的管理人员还是学者来说, 都是一个极其复杂的问题, 对其进行求解优化是一项艰巨的挑战.

护士排班问题在近几十年来得到了广泛的研究, 而最近十年研究尤为深入. 在众多求解算法中, 主要有精确算法和启发式算法两大类别. 精确算法有~Isken~等和~Glass~等分别在文献~\cite{isken2004implicit}~和~\cite{glass2010nurse}~中使用的整数规划方法, 以及~Beli{\"e}n~等在文献~\cite{belien2008branch}~中提出的分支定价方法. 此外, ~He~等在~\cite{he2012constraint}~中使用列生成算法对护士排班问题进行了建模与求解.

另一方面, 启发式算法也得到了众多研究者的关注.
Burke~等在~\cite{burke1999hybrid}~中提出了针对护士排班问题的混合禁忌搜索, 之后又相继提出了模因算法~\upcite{burke2001memetic}、变邻域搜索~\upcite{burke2004variable,burke2008hybrid}、分散搜索~\upcite{burke2010scatter}~和变深度搜索~\upcite{burke2013time}~来求解护士排班问题.
此外, 针对护士排班问题还有众多解决方案, 例如
~Bai~等在~\cite{bai2010hybrid}~中提出的混合进化算法、
Anwar~等在~\cite{anwar2014hyper}~中提出的超启发式算法以及
~Huang~等在~\cite{huang2014evolutionary}~中提出的进化算法.

由于护士排班问题是从实际应用中提炼出来的问题, 不同医院的不同需求导致该问题长期以来没有统一的问题定义与算例, 因此难以比较各种算法的优劣. 于是, 由鲁汶大学的~CODeS~课题组主办的护士排班竞赛~\upcite{haspeslagh2014first,ceschia2015second}~应运而生. 在第一届国际护士排班竞赛\footnote{官方网站为 ~http://www.kuleuven-kulak.be/nrpcompetition.}中,
Valouxis~等在~\cite{valouxis2012systematic}~中提出的整数规划与局部搜索相结合的混合算法、
Burke~等在~\cite{burke2014new}~中提出的分支定价算法以及
~L{\"u}~等在~\cite{lu2012adaptive}~中提出的自适应邻域搜索算法分别证明了其有效性.

为了更加贴近医院排班的实际场景, 第二届国际护士排班竞赛\footnote{官方网站为~http://mobiz.vives.be/inrc2/.}正式提出了多阶段护士排班问题, 在提炼出常见的实际约束的基础上, 引入了多阶段的概念以适应整个排班周期中需求变化的特点, 从而使得排班更具灵活性, 与此同时也增加了求解的挑战性. 此次竞赛全球共有~15~支队伍参加, 最终~7~支队伍进入决赛, 本文提出的算法在决赛中排名第四.

由于医院对医护人员的需求量具有不确定性, 周期较长的排班很容易因工作量的变化而需要重新调整, 因此第二届国际护士排班竞赛除了保留了传统的约束之外, 还将整个排班周期划分成多个较短的阶段, 对当前阶段进行排班时无法得知后续阶段的人员需求, 同时无法更改先前阶段的排班计划. 在这种情况下, 仍然需要考虑平衡所有护士在整个排班周期中的工作量.

本文提出的算法为针对第二届护士排班竞赛而设计的多邻域带权禁忌搜索. 首先, 该算法在计算目标函数值时给每个护士设置了不同的权重, 该权重根据当前解的改进潜力动态调整. 在当前解还有改进空间时, 算法将加强集中性, 将所有护士设置成相同的权重, 对原始目标函数进行优化; 在一定迭代次数没有改进最优解时, 算法将增强疏散性, 调整权重对软约束违反较多的护士进行针对性优化. 其次, 算法使用了多种结构和复杂度均不相同的邻域动作, 并根据邻域动作的效果动态调整探索各邻域的概率. 此外, 算法对复杂邻域动作的增量评估结果进行了缓存, 有效减少了重复计算. 最后, 算法设计了辅助目标函数与全局约束的估算策略, 以实现对跨阶段约束的优化.

本文接下来的部分将按如下结构组织. 第二章对第二届护士排班竞赛的问题模型进行了简要的介绍. 第三章对带权禁忌搜索算法进行了详细的描述和分析. 第四章展示了算法的计算结果和竞赛结果. 第五章通过对比实验对算法的重要策略进行了深入的分析和讨论. 最后一章对全文进行总结.


\section{问题定义}

本文讨论的护士排班问题的优化目标是在满足人员需求的情况下尽可能地平衡护士的工作强度, 以提升医院的效益. 每一天有若干时间段不同的班次, 如早班和夜班. 一个护士拥有若干技能, 如某一个护士掌握了护士长和普通护士两个技能. 为了表述方便, 将一天中任意一个班次与任意一个技能的组合称作一个时间槽. 例如, 如果有早班和晚班两个班次, 以及护士长和普通护士两个技能, 那么每天就有~(早班, 护士长)、(晚班, 护士长)、(早班, 普通护士)~和~(晚班, 普通护士)~一共~$4$~个时间槽. 该问题将给出固定数量的护士、排班周期的长度以及每天每个时间槽的人数需求, 要求得出一个排班计划, 确定每天每个时间槽安排哪些护士上班, 即确定是否安排一个护士在某一天上班, 如上班, 该护士使用其掌握的哪个技能上哪一个班. 此外, 整个排班周期被划分为多个阶段, 依次对各阶段进行排班. 在对某一阶段进行排班时, 无法修改先前阶段的排班, 也无法获知后续阶段\textcolor{red}{每天的时间槽对护士人数}的需求信息, 只有特殊的边界信息（历史）能从前一个阶段传递到后一阶段. 该排班计划必须满足若干硬约束, 同时尽可能减少对各项软约束的违反.
每个护士有一份工作合同, 合同详细规定了工作强度的最佳范围. 工作强度包括总工作天数、周末工作天数、连续工作天数、连续相同班次数以及连续休息天数等指标. 此外, 每个护士可以请求在指定的日期不为其排班.

整个周期由~$t$~个长度相等的连续且不重叠的阶段组成.
令~$D$~为排班周期中各天组成的集合, $D_i$~为阶段~$i$~中各天的集合, $D = D_1 \cup D_2 \cup ... \cup D_t $;
$N$~为护士的集合;
$H$~为班次的集合;
$K$~为技能的集合;
$X^H_i$~为一个~$|N| \times |D_i|$~的矩阵, 用于表示各护士在阶段~$i$~中各天被安排至哪个班次, 其中, 休息（ShiftOff）可以看作一个特殊的班次;
$X^K_i$~为一个~$|N| \times |D_i|$~的矩阵, 用于表示各护士在阶段~$i$~中各天使用哪个技能上安排的班次;
$X^H_i$~和~$X^K_i$~共同构成了阶段~$i$~的解向量~$X_i$, 整个排班周期的解向量为~$X$, $X = [X_1, X_2, ..., X_t]$. \textcolor{red}{图~\ref{figsolution}~给出了一个~5~个护士~7~天的解向量示例. 从图中可知每个护士每一天的工作安排, 如护士~$n_1$~在第~$d_1$~天被安排在时间槽~$(h_3, k_2)$, 护士~$n_2$~在第~$d_3$~天休息.}

\begin{figure}[!t]
	\centering
    \includegraphics[scale=0.9]{solution.eps}
	\cnenfigcaption{解向量示例}{Example of solution}
	\label{figsolution}
\end{figure}

该问题一共有~4~个必须满足的硬约束：

\begin{itemize}
	\item $\mathbf{H_1.}$ \textbf{单一指派约束. } 每个护士每天最多只能被安排到一个时间槽. 在本文提出的解向量的表示方式下, 该硬约束将自动满足.
	
	\item $\mathbf{H_2.}$ \textbf{人数下限约束. } 每天每个时间槽的排班人数不能小于其人数需求的最小值.
	
	\item $\mathbf{H_3.}$ \textbf{后继约束. } 同一个护士连续两天的排班不能出现某些特定的模式. 例如, 一个护士在某天上了夜班, 则第二天不能再安排上早班.

	\item $\mathbf{H_4.}$ \textbf{技能约束. } 安排到某个时间槽的护士必须具备对应的技能. 例如, 安排在~(早班, 护士长)~的护士必须具备护士长这个技能.
\end{itemize}

此外, 还有~8~个应尽量避免违反的软约束：

\begin{itemize}
	\item $\mathbf{S_1.}$ \textbf{最优人数约束. } 每天每个时间槽安排的护士数量不得小于给定的最优值, 每缺少一个护士都受到~1~个单位的惩罚. \textcolor{red}{该最优值大于等于~$\mathbf{H_2}$~规定的相应时间槽的人数需求最小值.}
	
	\item $\mathbf{S_2.}$ \textbf{连续工作日约束. } 每个护士的连续工作天数必须在给定的区间内, 每个超出或不足的工作日都受到~1~个单位的惩罚.
	
	\item $\mathbf{S_3.}$ \textbf{连续相同班次约束. } 每个护士被连续安排到同一班次的天数必须在给定的区间内, 每个超出或不足的工作日都受到~1~个单位的惩罚.
	
	\item $\mathbf{S_4.}$ \textbf{连续休息约束. } 每个护士的连续休息天数必须在给定的区间内, 每个超出或不足的休息日都受到~1~个单位的惩罚.
	
	\item $\mathbf{S_5.}$ \textbf{工作偏好约束. } 如果一个护士请求不在某天某班次上班, 但仍然被安排在该天该班次上班, 将受到~1~个单位的惩罚.
	
	\item $\mathbf{S_6.}$ \textbf{完整周末约束. } 如果一个护士的合同规定其应有完整的周末, 则其在周末的排班必须是两天均上班或者两天均休息, 否则将受到~1~个单位的惩罚.
	
	\item $\mathbf{S_7.}$ \textbf{总排班数约束. } 每个护士在整个排班周期中的总工作天数必须在给定的区间内, 每个超出或不足的工作日都要受到~1~个单位的惩罚.
	
	\item $\mathbf{S_8.}$ \textbf{总周末排班数约束. } 每个护士在整个排班周期中被排班了的周末总数不得大于给定的最大值, 每超出一个工作周末都要受到~1~个单位的惩罚. 其中周六或周日任意一天被排班则周末算作工作, 否则为休息.
\end{itemize}

其中所有硬约束可以在各阶段中单独考虑, 各阶段满足即整个周期的排班合法; 软约束中除~$\mathbf{S_7}$~与~$\mathbf{S_8}$~外其它约束均可在各阶段中考虑, 各阶段惩罚的累加和即为整个周期的相应惩罚. $\mathbf{S_7}$~与~$\mathbf{S_8}$~是横跨整个周期的约束, 由于整个周期的排班是分阶段进行的, 因此只有在排最后一个阶段时才能准确计算这两个软约束的违反程度. 对于其它阶段, 可以采取近似评估策略考虑, 以防止前期由于不考虑而违反过多. 另外, 除了~$\mathbf{H_2}$~与~$\mathbf{S_1}$~是与时间槽相关的约束, 其它约束只针对单个护士, 护士之间不会相互影响.
问题的求解目标为, 在整个排班周期结束时, 解向量~$X$~满足硬约束~$\mathbf{H_1}$~到~$\mathbf{H_4}$, 同时使违反软约束~$\mathbf{S_1}$~到~$\mathbf{S_8}$~受到的惩罚最小.
假设软约束~$\mathbf{S_i}$~在所有阶段的惩罚之和为~$f_i(X)$, 权重系数为~$c_i$, 则合法解~$X$~的目标函数~$f(X)$~如公式~\ref{eq1}~所示
\begin{equation}
f(X) = \sum_{i=1}^{8} c_i \times f_i(X)
\label{eq1}
\end{equation}
\textcolor{red}{该问题的目标即为找到一个满足所有硬约束同时目标函数值最小的解.}

已知数据主要包括场景、需求和历史三类.

场景信息为应用于所有阶段的公共数据, 其规定了排班周期的长度, 可能出现的班次和技能, $\mathbf{H_3}$~中涉及的非法后继班次的模式, 不同种类的合同的内容, 以及可供排班的护士与他们签订的合同类型. 其中合同规定了~$\mathbf{S_2}$~和~$\mathbf{S_4}$~中涉及的连续天数的上下限、$\mathbf{S_6}$~中涉及的是否要求有完整周末、$\mathbf{S_7}$~中涉及的总排班数区间以及~$\mathbf{S_8}$~中涉及的总周末排班数上限.

需求信息仅作用于单个阶段, 其中包括用于判断~$\mathbf{H_2}$~和~$\mathbf{S_1}$~的违反程度的人数需求, 即一阶段中每天每个时间槽的最低和最优护士数量, 以及~$\mathbf{S_5}$~中描述的护士请假要求.

历史信息即从前一阶段传递给后一阶段的数据, 用于评估跨阶段约束的违反情况. 典型的历史信息包含各护士的累计排班数、累计周末排班数、上阶段最后一天的排班、上阶段最后的连续排班天数与连续休息天数等. 求解器的实现者也可以将任意可获取的数据以自定义格式保存供后续阶段使用.

具体数据格式以及各约束在边界情况下的处理请参考竞赛的问题描述文档~\upcite{ceschia2015second}.


\section{带权禁忌搜索}
\label{sec:implement}

\subsection{算法流程概览}

护士排班问题的求解过程将按阶段依次执行, 直到覆盖整个排班周期. 如算法~\ref{alg1}~所示, 每个阶段以场景信息~$Scenario$、上阶段的历史信息~$h_i$~与本阶段的需求信息~$Weekdata_i$~为输入, 调用带权禁忌搜索算法, 输出本阶段的解向量~$X_i$~与供下阶段使用的历史信息~$h_{i+1}$. 在本次竞赛中, 排班周期以周为单位划分阶段, 通常为~4~周或~8~周, 且参赛者只需设计实现一周排班的求解算法, 由竞赛组织者重复调用该算法来完成整个周期所有阶段的排班.

\begin{algorithm}
	\footnotesize
	\caption{护士排班问题求解过程}
	\label{alg1}
	\begin{algorithmic}
		\REQUIRE $\textrm{算例数据}~Scenario, InitialHistory, Weekdata$;
		\ENSURE $\textrm{求得的最优排班计划}~X$;
		\STATE $h_0 \Leftarrow InitialHistory$;
		\STATE $i \Leftarrow 0$;
		\WHILE{$i < t$}
		\STATE $X_i \Leftarrow \textrm{WeightedTabuSearch}(Scenario, h_i, Weekdata_i)$;  // 见算法~\ref{alg2}
		\STATE $h_{i+1} \Leftarrow \textrm{GenerateHistory}(Scenario, h_i, X_i)$;
		\STATE $i \Leftarrow i+1$;
		\ENDWHILE
	\end{algorithmic}
\end{algorithm}

对单阶段进行排班使用了带权禁忌搜索算法, 其伪代码如算法~\ref{alg2}~所示.
%其中~$w_n$~为对护士~$n$~计算软约束违反情况时惩罚的权重系数（见 ~\ref{subsec:weight}~节）.
算法首先产生一个合法的初始解作为当前解, 然后交替使用集中性和疏散性的多邻域禁忌搜索, 每轮先使用集中性搜索对当前解进行改进, 更新全局最优解~$X_i$~之后, 再使用疏散性搜索进行扰动. 到达给定的运行时间后算法终止并输出找到的最优排班. 由于只是针对一个阶段进行排班, 需要定义单个阶段解~$X_i$~的目标函数~$f^S$~
\begin{equation}
f^S(X_i) = \sum_{j=1}^{6} c_j \times f^S_j(X_i) + \sum_{j=7}^{8} c_j \times g^S_j(X_i)
\label{eq6}
\end{equation}
其中~$f^S_j(X_i)$~为软约束~$\mathbf{S_j}$~在阶段~$i$~的惩罚之和, 其计算方式和针对全周期解向量~$X$~的计算方式~$f_j$~相同. ~$g^S_7$~和~$g^S_8$~是针对~$\mathbf{S_7}$~和~$\mathbf{S_8}$~的近似评估函数.

接下来将详细介绍用于单个阶段求解的算法实现细节.

\begin{algorithm}
	\footnotesize
	\caption{求解护士排班问题的带权禁忌搜索算法框架}
	\label{alg2}
	\begin{algorithmic}
		\REQUIRE $\textrm{算例数据}~Scenario, History, Weekdata$;
		\ENSURE $\textrm{求得的本阶段的最优排班计划}~X_i$;
		\STATE $X_i \Leftarrow \textrm{GenerateInitialSolution}()$;  // \textcolor{red}{生成初始解,} 见~\ref{subsec:init}~节
		\STATE $s \Leftarrow X_i$;  // $s$~表示当前解
		\REPEAT
			\STATE $\textrm{ResetWeight}(w)$;  // 见~\ref{subsec:weight}~节
			\STATE $s \Leftarrow \textrm{TabuSearch}(s, w)$;  // \textcolor{red}{集中性多邻域禁忌搜索,} 见~\ref{sec:tabusearch}~节算法~\ref{alg3}
			\STATE $\textrm{UpdateOptima}( s, X_i )$;  // \textcolor{red}{更新全局最优解~$X_i$}
			\STATE $s \Leftarrow \textrm{SelectRandomly}(s, X_i)$; 	// \textcolor{red}{从~$s$~和~$X_i$~中}等概率随机选择一个\textcolor{red}{进行之后的疏散性搜索}
			\STATE $w \Leftarrow \textrm{AdjustWeightToBiasNurseWithGreaterPenalty}(s)$;  // \textcolor{red}{调整惩罚权重,} 见~\ref{subsec:weight}~节
			\STATE $s \Leftarrow \textrm{TabuSearch}(s, w)$;  // \textcolor{red}{疏散性多邻域禁忌搜索,} 见~\ref{sec:tabusearch}~节算法~\ref{alg3}
		\UNTIL{满足停止条件}
	\end{algorithmic}
\end{algorithm}

\subsection{初始解生成}
\label{subsec:init}

初始解的生成使用了贪心构造的方法, 从阶段的第一天到最后一天依次填充时间槽以确定排班计划. 对于每一天~$d$, 统计每个技能~$k$~对护士的总最低需求量~$r_{d,k}$, 即当天技能为~$k$~的各时间槽的人数下限之和, $r_{d,k} = \sum_{h \in H} \textrm{MinDemand}(d, h, k)$, 其中~MinDemand~函数表示第~$d$~天班次~$h$~技能~$k$~的时间槽~$(h, k)$~的人数下限（硬约束~$\mathbf{H_2}$）. 然后根据其与拥有该技能的护士数~$num$~的比例确定先排哪个技能的所有时间槽. 如果~$r/num$~小, 说明拥有该技能的护士人手充足, 排班比较容易满足, 可以放到后面排; 反之说明拥有该技能的护士人手紧张, 应该优先考虑. 算法将从~$r/num$~比较\textcolor{red}{大}的技能开始, 给该技能的所有时间槽填充护士, 直到达到\textcolor{red}{硬约束~$\mathbf{H_2}$~规定的}人数下限. 对于每个时间槽, 在保证不违反硬约束~$\mathbf{H_1}$, $\mathbf{H_3}$~和~$\mathbf{H_4}$~的情况下, 优先选择拥有技能数更少的护士, 有多个技能数相同的护士时随机挑选一个, 以给后续技能的时间槽保留更充足的人选, 同时保证初始解的多样性. \textcolor{red}{例如第~$d_1$~天时间槽~$(h_1, k_1)$~至少需要一个掌握了技能~$k_1$~的护士, 护士~$n_1$~和~$n_2$~均只具备技能~$k_1$, 护士~$n_3$~同时具备~$k_1$~和~$k_2$~两项技能, 那么在挑选护士时, 从~$n_1$~和~$n_2$~中等概率随机选择一个填充该时间槽, 即安排~$n_1$~或~$n_2$~在第~$d_1$~天使用技能~$k_1$~上班次~$h_1$.}

由于该贪心构造方法比较简单, 理论上可能生成不满足硬约束~$\mathbf{H_2}$~的非法解. 但是由于软约束~$\mathbf{S_1}$~的存在, 未达到人数下限意味着与最优人数差距较大, 会产生巨大的惩罚, 因此在禁忌搜索初期可以被轻松修复. 然而根据实验观察, 通过贪心构造方法得到合法初始解的频率为~$100\%$, 不需要通过搜索修复.

\subsection{邻域结构}
\label{subsec:neighbor}

对于一个给定的阶段~$i$~解向量~$X_i$, 可以通过对其施加一个动作得到一个新的解向量~$X'_i$, 这个新的解向量称为~$X_i$~的邻域解, 使~$X_i$~变为某个邻域解~$X'_i$~的变换称为邻域动作~$m$,
令作用于~$X_i$~的邻域动作的集合为~$M(X_i)$;
C~为布尔表达式到整数的转换函数, 如果所给布尔表达式为真取~$1$, 否则取~$0$.
则对于护士排班问题可以定义如下邻域结构.

\begin{itemize}
	\item \textbf{增加排班. } 安排原本在第~$d$~天休息的护士~$n$~在第~$d$~天班次~$h$~技能~$k$~上班. 该邻域动作的集合为
	\begin{equation}
	M_1(X_i) = \{ m_1(n, d, h, k) | \forall n \in N, \forall d \in D_i, \forall h \in H, \forall k \in K, x^H_{i,n,d} = \textrm{ShiftOff} \wedge h \ne \textrm{ShiftOff} \}
	\label{eq2}
	\end{equation}
\textcolor{red}{以图~\ref{figsolution}~所示的解向量为例, 将原本在~$d_1$~天休息的护士~$n_4$~安排到时间槽~$(h_2, k_2)$~工作, 则变为图~\ref{add}~所示的邻域解.}
	
	\item \textbf{减少排班. } 安排原本在第~$d$~天上班的护士~$n$~在第~$d$~天休息. 该邻域动作的集合为
	\begin{equation}
	M_2(X_i) = \{ m_2(n, d) | \forall n \in N, \forall d \in D_i, x^H_{i,n,d} \ne \textrm{ShiftOff} \}
	\label{eq3}
	\end{equation}
\textcolor{red}{以图~\ref{figsolution}~所示的解向量为例, 安排原本在~$d_1$~天上班的护士~$n_1$~休息, 则变为图~\ref{remove}~所示的邻域解.}
	
	\item \textbf{变更排班. } 安排原本在第~$d$~天班次~$x^H_{i,n,d}$~技能~$x^K_{i,n,d}$~上班的护士~$n$~在第~$d$~天班次~$h$~技能~$k$~上班. 该邻域动作的集合为	
	\begin{align}
		M_3(X_i) = \{ m_3(n, d, h, k) | & \forall n \in N, \forall d \in D_i, \forall h \in H, \forall k \in K, x^H_{i,n,d} \ne \textrm{ShiftOff} \wedge h \ne \textrm{ShiftOff} \nonumber \\
		 & \wedge ( x^H_{i,n,d} \ne h \vee x^K_{i,n,d} \ne k ) \}
		\label{eq4}
	\end{align}
\textcolor{red}{以图~\ref{figsolution}~所示的解向量为例, 将第~$d_6$~天原本在时间槽~$(h_2, k_2)$~上班的护士~$n_1$~变为在~$(h_1, k_1)$~上班, 则变为图~\ref{change}~所示的邻域解.}
	
	\item \textbf{交换排班. } 即块交换. 交换两个护士~$n_1$~和~$n_2$~在第~$d_1$~到~$d_2$~天的排班. 该邻域动作的集合为
	\begin{equation}
	M_4(X_i) = \{ m_4( n_1, n_2, d_1, d_2) | \forall n_1, n_2 \in N, \forall d_1, d_2 \in D_i, d_1 \le d_2 \wedge ( \sum_{d=d_1}^{d_2} \textrm{C}( x^H_{i,n_1,d} \ne x^H_{i,n_2,d} ) ) > 0 \}
	\label{eq5}
	\end{equation}
\textcolor{red}{以图~\ref{figsolution}~所示的解向量为例, 交换护士~$n_1$~和~$n_2$~从~$d_2$~到~$d_5$~天的排班, 则变为图~\ref{swap}~所示的邻域解.}

\begin{figure}[!t]
	\centering
    \includegraphics[scale=0.9]{add.eps}
	\cnenfigcaption{增加排班示例}{Example of adding assignment}
	\label{add}
\end{figure}

\begin{figure}[!t]
	\centering
    \includegraphics[scale=0.9]{remove.eps}
	\cnenfigcaption{减少排班示例}{Example of removing assignment}
	\label{remove}
\end{figure}

\begin{figure}[!t]
	\centering
    \includegraphics[scale=0.9]{change.eps}
	\cnenfigcaption{变更排班示例}{Example of changing assignment}
	\label{change}
\end{figure}

\begin{figure}[!t]
	\centering
    \includegraphics[scale=0.9]{swap.eps}
	\cnenfigcaption{交换排班示例}{Example of swapping assignment}
	\label{swap}
\end{figure}

\end{itemize}

四种邻域结构中, 增加、减少和变更排班的复杂度相对较小, 而交换排班的复杂度较大. 虽然多个前三种邻域动作的组合可以构成块交换的邻域动作, 但局部搜索每一步通常选择能够改进目标函数的邻域动作, 可能错过可以产生更大改进的组合动作. 例如两个护士在某一天都上班时, 交换他们在这一天的排班可以等效成连续执行两个变更排班邻域动作. 考虑这个组合动作整体对目标函数值的改变, 可能是有较大改进的, 但是先单考虑其中一个护士的变更班次时, 会发现原班次的最优人数等约束的违反导致解的质量变差了, 于是该变更班次不会被执行, 从而导致组合动作不会被考虑. 另一方面, 如果将复杂的邻域动作分解为若干个简单的邻域动作, 其中间状态可能违反硬约束. 例如将交换两个护士在某一天的排班分解为先后变更两个护士的排班, 可能出现先变更一个护士的排班后原时间槽的人数小于人数下限的情况.
因此, 交换排班作为前三种邻域动作组合而成的复合邻域结构, 具有极其重要的意义.

\subsection{多邻域禁忌搜索}
\label{sec:tabusearch}

多邻域禁忌搜索以禁忌搜索为框架, 在搜索的每一步迭代中, 通过概率选择四种结构不同的邻域中的一种进行搜索. 如算法~\ref{alg3}~所示, 该过程首先令选中各种邻域的概率相等, 然后将禁忌表初始化为允许所有邻域动作执行的状态. 接下来循环执行邻域搜索过程, 直到连续一定迭代步数~$th$~无法改进本次局部搜索找到的最优解\textcolor{red}{~$s^*$~}即停止. 在循环体中, 首先按概率在~$M_1$~到~$M_4$~中选择一个邻域~$\mathcal{M}$, 然后对~$\mathcal{M}$~中的所有动作进行评估, 计算其对目标函数值的改变量,
\textcolor{red}{即执行邻域动作后得到的解的目标函数与执行之前的解的目标函数的差值}. 选出\textcolor{red}{差值最小的}最优邻域动作~$m$~之后, 更新相关的禁忌表项, 执行该邻域动作, 并更新本次搜索的最优解. 最后根据该邻域动作的优度更新下一次迭代中各邻域被选中的概率. 接下来将介绍上述过程的具体实现.

\begin{algorithm}
	\footnotesize
	\caption{多邻域禁忌搜索算法伪代码}
	\label{alg3}
	\begin{algorithmic}
		\REQUIRE $\textrm{初始解}~s^0, \textrm{各护士的惩罚权重}~w$;
		\ENSURE $\textrm{求得的当前权重下本阶段的最优排班计划}~s^*$;
		\STATE $s \Leftarrow s^0,~s^* \Leftarrow s^0$ // $s$~表示当前解
		\STATE $\textrm{InitializeNeighborhoodSelectionPossibility}(p_1, p_2, p_3, p_4)$; // $p_1$~到~$p_4$~分别表示选中~$M_1$~到~$M_4$~的概率
%		\STATE $\textrm{InitializeTabuList}()$;  // 见 ~\ref{subsec:tabu}~节
		\REPEAT
		\STATE $\mathcal{M} \Leftarrow \textrm{SelectNeighborhood}(p_1, p_2, p_3, p_4)$;  // \textcolor{red}{按概率分布选择一种邻域,} 见~\ref{subsec:select}~节
		\STATE $m \Leftarrow \textrm{FindBestNeighborhoodMove}(s, \mathcal{M})$;  // \textcolor{red}{禁忌搜索最优动作, 见~\ref{subsec:tabu}~节}
%		\STATE $\textrm{UpdateTabuList}(m)$;  // 见 ~\ref{subsec:tabu}~节
		\STATE $s \Leftarrow \textrm{ApplyNeighborhoodMove}(s, m)$;  // \textcolor{red}{对当前解~$s$~执行动作~$m$}
        \STATE $\textrm{UpdateOptima}(s, s^*)$;  // \textcolor{red}{更新最优解~$s^*$}
		\STATE $\textrm{UpdateNeighborhoodSelectionPossibility}(p_1, p_2, p_3, p_4, \mathcal{M}, m)$;  // \textcolor{red}{更新邻域选择概率,} 见~\ref{subsec:select}~节
		\UNTIL{满足停止条件}
	\end{algorithmic}
\end{algorithm}

\subsubsection{邻域选择策略}
\label{subsec:select}

由于本算法设计了四种结构不同的邻域, 局部搜索每一步对所有邻域进行探索开销过大, 因此每次只选择一个邻域进行评估. 于是, 邻域的选择策略的设计对算法性能的提升起到了至关重要的作用.

本算法采用了轮盘赌的策略, 每种邻域~$M_i$~有一定的概率~$p_i$~被选中, 所有邻域被选中的概率之和满足~$\sum_{i=1}^4 p_i = 1$. 在局部搜索的每一次迭代中, 会在所有邻域中挑选一个邻域进行搜索, 寻找具有最大改进的邻域动作.

概率~$p_i$~由相应权重~$\omega_i$~来控制, $p_i = \omega_i / \sum_{i=1}^4 \omega_i$. \textcolor{red}{初始时四种邻域的权重相等, 即选中概率都为~0.25.} 在搜索过程中, 算法将根据邻域~$M_i$~的表现动态调整其权重~$\omega_i$. 每一\textcolor{red}{迭代步}搜索某一邻域寻找最优动作~$m$~时, 会出现~$m$~改进了最优解\textcolor{red}{~$s^*$}、改进了当前解\textcolor{red}{~$s$}、没有改进当前解以及不存在合法动作这四种情况之一. 这四种情况反映了该邻域对当前搜索过程的适应性, 表明了对解向量产生改进的程度. 很显然, 应该让更合适的邻域在接下的迭代中以更大的概率被选择, 因此本算法设置了四个基准值~$\Omega_1$~到~$\Omega_4$, 分别与上述四种情况相对应, 每执行一个邻域动作都将根据其效果调整\textcolor{red}{对应邻域的}权重向对应的基准值趋近, \textcolor{red}{其它邻域的权重保持不变.} 具体的调整策略为
\begin{equation}
\omega_i =
\begin{cases}
\omega_i + \lambda (\Omega_1 - \omega_i) ,&~m~\textrm{改进了本次搜索的最优解;} \\
\omega_i + \lambda (\Omega_2 - \omega_i) ,&~m~\textrm{改进了当前解;} \\
\omega_i + \lambda (\Omega_3 - \omega_i) ,&~m~\textrm{没有改进当前解但是合法动作;} \\
\omega_i + \lambda (\Omega_4 - \omega_i) ,&~\textrm{不存在合法动作.} \\
\end{cases}
\label{eq7}
\end{equation}
其中~$\Omega_1 > \Omega_2 > \Omega_3 > \Omega_4 > 0$, $\lambda \in (0, 1]$~控制~$\omega_i$~向基准值趋近的速度. 在其定义域内, $\lambda$~越大收敛速度越快. \textcolor{red}{例如, 局部搜索的某一迭代步选择了增加排班邻域~$M_1$, $M_1$~的权重~$\omega_1$~此时位于区间~$(\Omega_2, \Omega_1)$, 若该邻域中的最优动作~$m$~能够改进最优解~$s^*$, 则根据公式~\ref{eq7}, $M_1$~的权重调整为~$\omega_1 = \omega_1 + \lambda (\Omega_1 - \omega_i)$, $M_1$~的权重增加, 因此之后的选中概率也将变大; 而如果该邻域不存在合法动作, 则权重调整为~$\omega_1 = \omega_1 + \lambda (\Omega_4 - \omega_i)$, $M_1$~的权重减少, 下一迭代步被选中的概率也将变小.}

\subsubsection{禁忌策略}
\label{subsec:tabu}

按概率选定一种邻域后, 本算法采用了禁忌搜索策略以避免搜索过程陷入局部最优陷阱.
%禁忌策略的关键因素为禁忌表的设计和禁忌步长的设置, 由于禁忌步长的选取较为简单, 本节将详细介绍禁忌表的设计.

禁忌搜索的核心思想在于记录最近一定步数内已搜索过的解的特征或已执行过的邻域动作的特征, 防止搜索路径在局部最优附近绕圈.
\textcolor{red}{一个护士在某一天的状态只存在两种可能: 休息或在某个时间槽上班, 当搜索中某一迭代步一个护士某一天的状态发生了改变, 那么在接下来的若干步内将避免该护士在这一天被安排回原先的状态.}
具体来说, 本算法对排班情况进行了记录, 如果某一迭代步一个在第~$d$~天休息的护士~$n$~被安排上班, 那么在接下来的~$l_1$~步内, 将不能对护士~$n$~执行第~$d$~天的减少排班动作, 即不能在第~$d$~天被重新安排为休息;
如果某一迭代步一个在第~$d$~天班次~$h$~技能~$k$~上班的护士~$n$~被安排为休息或者在其他时间槽上班, 那么在接下来的~$l_2$~步内, 护士~$n$~将不能被重新安排在第~$d$~天的时间槽~$(h,k)$~上班. 在每一迭代步中, 只考虑邻域当中没有\textcolor{red}{被}禁忌的动作, 但如果一个动作可以改进本次局部搜索的最优解\textcolor{red}{~$s^*$~}则不考虑其是否被禁忌（特赦准则）. \textcolor{red}{最终在所有未禁忌的动作和满足特赦准则的禁忌动作中挑选出一个对目标函数值改进幅度最大的动作.}

%具体来说, 本算法中使用了两个禁忌表. 禁忌表~$T^D$~是一个~$|N| \times |D_i|$~的矩阵, 如果~$T^D_{n,d}$~大于当前迭代步数表示禁止护士~$n$~在第~$d$~天被安排为休息. 禁忌表~$T^H$~是一个~$|N| \times |D_i| \times |H| \times |K|$~的矩阵, $T^H_{n,d,h,k}$~大于当前迭代步数表示禁止护士~$n$~被安排在第~$d$~天时间槽~$(h,k)$~上班.
%对于~$M_4$~这种复合邻域结构, 需要将其分解为~$M_1$~至~$M_3$~的组合, 再针对每个动作查询或设置禁忌表. 在判断一个给定的块交换是否被禁忌时, 有~$4$~种策略, 它们分别为：总是允许、只要有一个非禁忌的子动作就允许、只要有一个子动作被禁忌则禁止以及被禁忌的子动作超过一定比例则禁止. 由于~$M_4$~邻域较大, 再加上多种动作交替选择, 其陷入局部最优的可能性相对较小, 同时为了方便增量评估缓存的设计（见~\ref{subsec:cache}~节）, 本算法总是认为~$M_4$~是非禁忌的.

\subsubsection{缓存策略}
\label{subsec:cache}

由于护士排班问题软约束众多, 目标函数计算过程十分复杂. 对于较大的邻域, 邻域评估的运算量更加庞大. 分析局部搜索每次只对当前解做小幅改动的特性, 可知每次执行一个邻域动作后, 大多数其它邻域动作对目标函数的影响并未发生变化. \textcolor{red}{例如, 将一个在第~$d$~天休息的护士~$n_1$~安排到时间槽~$(h_1, k_1)$~工作的增加排班动作~$m_1(n_1, d, h_1, k_1)$~与安排一个在第~$d$~天时间槽~$(h_2, k_2)$~上班的护士~$n_2$~休息的减少排班动作~$m_2(n_2, d)$~是互不影响的, 即不管其中一个动作执行与否, 另一个动作的执行对目标函数带来的变化不会发生改变.}
因此, 本算法使用了缓存机制, 将邻域动作导致的目标函数的增量保存起来, 加速邻域评估过程.

本算法中有多种邻域结构, 而搜索过程中每次只挑选一个进行搜索, 如果对所有邻域都进行缓存, 会产生更大的缓存维护开销. 下面将分析对各种邻域进行缓存的利弊, 最终得出本算法使用的缓存策略.

当对护士~$n$~执行了~$M_1$~至~$M_3$~中的一个动作后, 由于其排班出现了变化, 所有与其相关的四种邻域~$M_1$~至~$M_4$~中的动作引起的目标函数的增量可能会发生改变.
%如果以时间槽为粒度对缓存有效性进行标记, 会导致每次邻域动作需要对该护士的所有时间槽进行设置, 时间复杂度为~$O(n)$; 如果以护士为粒度, 每次邻域动作只需对一个标记位进行设置, 时间复杂度为~$O(1)$, 仅考虑单个邻域时, 能带来一定的性能提升.
同理, 当对护士~$n_1$~和~$n_2$~执行了块交换~$M_4$~后, 所有与护士~$n_1$~和~$n_2$~相关的~$M_1$~至~$M_4$~中的动作引起的目标函数的增量可能发生改变.
%如果以护士为粒度对缓存有效性进行标记, 则每次邻域动作的执行只会导致~$2$~个缓存项失效, 即可以在~$O(1)$~的时间复杂度内更新标记位.

根据预先实验观察, 由于邻域~$M_4$~的规模远大于其它三种邻域, 对~$M_4$~进行邻域搜索的时间开销占用了总时间的~80\%~以上,
%再对算法的性能瓶颈进行分析, 可知对~$M_1$~至~$M_3$~中单个邻域动作的增量评估虽然逻辑复杂, 但其时间复杂度仍为~$O(|D|)$,而对~$M_4$~中单个邻域动作进行评估的时间复杂度则为~$O(|D|^3)$, 远大于其他邻域的复杂度,
对其进行缓存将极大地减少重复计算, 因此缓存该邻域动作引起的目标函数增量是非常有必要的. 而由上面的分析可以看出, $M_1$~至~$M_3$~的搜索时间开销较小, 并且所有邻域动作的执行都会影响其它邻域相关动作的缓存, \textcolor{red}{例如对护士~$n$~执行了增加排班动作后, 涉及护士~$n$~的减少排班动作、变更排班动作以及交换排班动作都会受到影响.} 随着被缓存的邻域种类数的增多, 相互影响将被放大, 会有更多缓存在被再次利用之前就已经失效, 增加了缓存的维护开销.

因此, 经过上述综合分析, 本算法仅对~$M_4$~进行缓存, 对任意两个护士, 缓存其任意起止天的块交换中的最优动作及其引起的目标函数增量, \textcolor{red}{即计算两个护士之间所有可能的交换动作, 记录其中最优的交换}. 当某个护士~$n$~的排班发生改变时, 其与所有其他护士的最优块交换缓存失效, 需要重新计算以更新这些缓存.

\subsection{惩罚权重调整策略}
\label{subsec:weight}

为了增加算法的疏散性, 本算法为护士设置了惩罚权重~$w$. 除~$\mathbf{S_1}$~以外的所有软约束都是针对单个护士的排班考虑的, 各护士对这些软约束的违反程度的计算是相互独立的, 即可以将其进一步细分, 将软约束~$S_j$~在所有护士上的惩罚之和表示为~$f^S_j(X_i) = \sum_{n \in N} w_n \times f^S_j(X_{i,n})$, \textcolor{red}{其中~$f^S_j(X_{i,n})$~表示解~$X_i$~中护士~$n$~软约束~$S_j$~的惩罚, $w_n$~为算法引入的护士~$n$~的惩罚权重}. 在原始问题中, 可看作所有护士的权重~$w_n$~相等（即~$w_n=1, n \in N$）, 而本算法将动态调整该权重. \textcolor{red}{集中性搜索前, 将所有护士的权重设置为~1,} 当集中性搜索无法继续改进最优解时, \textcolor{red}{调整护士的权重进行疏散性搜索.} 本算法通过增加惩罚较多的护士的权重, 引导搜索优先改进这些护士的排班, 即通过改变目标函数来探索其他有改进潜力的解空间.

\begin{algorithm}
	\footnotesize
	\caption{惩罚权重调整过程}
	\label{alg4}
	\begin{algorithmic}
		\REQUIRE $\textrm{护士集合}~N, \textrm{某个护士当前惩罚的计算函数}~f^S$;
		\ENSURE $\textrm{护士的惩罚权重}~w$;
		\STATE $L \Leftarrow \textrm{SortNurseByPenalty}(N, f^S)$;  // $L$ \textcolor{red}{是将全体护士按惩罚从大到小排列的序列}
		\STATE $i \Leftarrow 1$;
		\WHILE{$i < |N| \times r_1$}
		\STATE $n \Leftarrow L_i$;
		\STATE $w_n \Leftarrow W_1$;
		\STATE $i \Leftarrow i + 1$;
		\ENDWHILE
		\WHILE{$i < |N|$}
		\STATE $n \Leftarrow L_i$;
		\STATE $w_n \Leftarrow W_3$;
		\STATE $i \Leftarrow i + 1$;
		\ENDWHILE
		\STATE $i \Leftarrow 1$;
		\WHILE{$i < |N| \times r_2$}
		\STATE $n \Leftarrow \textrm{SelectNurseRandomly}(N)$;
		\IF{$w_n = W_3$}
		\STATE $w_n \Leftarrow W_2$;
		\STATE $i \Leftarrow i + 1$;
		\ENDIF
		\ENDWHILE
	\end{algorithmic}
\end{algorithm}

护士惩罚权重的具体调整过程为, 在全部护士中, 选择惩罚最多的~$r_1 \times |N|$~个护士, 将其权重设为~$W_1$, 然后在剩余护士中, 随机选择~$r_2 \times |N|$~个护士, 将其权重设为~$W_2$, 再将剩下的护士的权重设为~$W_3$. 其中有~$W_1~\textcolor{red}{\ge}~W_2~\textcolor{red}{\ge}~W_3 \ge 0, r_1, r_2 \in [0, 1], r_1 + r_2 < 1$. 为了增强扰动效果, 算法在具体实现时参数的取值为~$W_1=W_2=1, W_3=0$, 即只考虑排班格局较差的护士以及为增加多样性随机挑选的护士. \textcolor{red}{例如, 若~$r_1 = 0.2, r_2 = 0.05$, 则在调整权重时, 首先将惩罚最多的~$0.2 \times |N|$~个护士的权重设为~1, 然后在剩余的护士中随机挑选~$0.05 \times |N|$~个护士将其权重设为~1, 剩下没有选中的护士权重设为~0, 即不考虑这些护士的惩罚.}
该调整过程的伪代码如算法~\ref{alg4}~所示.


\subsection{全局约束的近似评估}
\label{subsec:global}

软约束~$\mathbf{S_7}$~和~$\mathbf{S_8}$~属于评估整个排班周期的约束, 只有当求解最后一个阶段的排班时才能被准确计算, 但是如果先前阶段排班不考虑这些约束的话, 会严重影响最终全周期的排班效果, 甚至导致后续某阶段无法找到满足硬约束的排班计划. 因此, 在各阶段内部需要一个近似评估机制来估算本阶段的排班会对全局约束~$\mathbf{S_7}$~和~$\mathbf{S_8}$~造成多大的影响. 本算法在两个部分使用了近似评估策略, 其一是在计算本阶段的目标函数时, 根据各护士的总排班数上下限、历史排班数和本阶段人员需求等因素估算本阶段排班对~$\mathbf{S_7}$~和~$\mathbf{S_8}$~的贡献; 其二是在更新最优解时, 根据本阶段的排班情况设计辅助目标函数, 处理目标函数值相同的情况下最优解的取舍. 本节将对这两种策略进行详细介绍.

首先, 对于~$\mathbf{S_7}$~的上限, 本算法采用了均匀分配剩余排班数上限的处理方案. 令~$A_{n,i}$~为护士~$n$~在第~$i$~阶段的总排班数, 全周期总排班数下限为~$A^L_n$, 上限为~$A^U_n$, 则可以按如下公式模拟护士~$n$~在第~$i$~阶段的排班数上限~$A^U_{n,i}$~
\begin{equation}
A^U_{n,i} = \frac{A^U_n - \sum_{j=1}^{i-1} A_{n,j}}{t - i + 1}, \quad i = 1, 2, ..., t
\label{eq8}
\end{equation}
其中分子为剩余排班数上限, 由总排班数上限减去第~$i$~阶段之前的累计排班数求得, 其取值可能为负数, 即已经超过全周期的上限; 分母为包括阶段~$i$~在内的剩余阶段数.
\textcolor{red}{例如, 求解一个全周期长度为~4~周的排班, 单阶段长度为一周, 护士~$n$~的总排班数上限~$A^U_n$~为~22, 则求解第一周的排班时, 该护士这一阶段的排班数上限~$A^U_{n,1} = 22 / 4 = 5.5$. 若该护士第一周有~6~天上班, 则超过了该阶段的排班数上限, 受到~0.5~个惩罚. 依照公式~\ref{eq8}~可得该护士第二周的排班数上限~$A^U_{n,2} = (22-6)/(4-1) = 16/3$, 依次类推可得剩余阶段的排班数上限.}

相比于均匀分配各阶段的排班数, 即~$A^U_{n,i} = A^U_n / t$, 该方法更具灵活性, 即如果前期需求不多, 则中后期会放松该约束, 剩余排班数上限较多的护士可以更多地排班; 如果前期需求过多, 则中后期会收紧该约束, 保证最终排班数不会超出上限太多.
对于~$\mathbf{S_8}$~所规定的上限, 采用了与~$\mathbf{S_7}$~中的上限相同的近似评估方式.

其次, 本算法对~$\mathbf{S_7}$~中总排班数下限的处理为在整个排班周期的前期若干阶段忽略该约束. 由于合同规定的总排班数下限是针对整个排班周期的, 而在开始的几个阶段中累积需求并不多, 所以该约束很容易被违反. 另外, 因为连续性约束~$\mathbf{S_2}$~至~$\mathbf{S_4}$~的存在, 各护士的排班可能出现不均衡的状态, 即在最初的几个阶段里, 某些护士排班比较满, 另外一些护士休息比较多. 介于上述两种情况, 在排班周期的前期阶段就考虑~$\mathbf{S_7}$~的下限会鼓励算法增加总排班量, 这样易导致后期护士的总排班数大幅超出合同规定的上限. 因此, 本算法将根据~$A^L_n / A^U_n$~确定从第几个阶段开始以均匀分配剩余排班数下限的方式考虑. 具体来说, 对于总共有~$t$~个阶段的排班周期, 将按如下规则计算护士~$n$~在第~$i$~个阶段的排班数下限~$A^L_{n,i}$~
\begin{equation}
A^L_{n,i} =
\begin{cases}
0 ,& 1 \le i < t \times \frac{A^L_n}{A^U_n} \\
\frac{A^L_n - \sum_{j=1}^{i-1} A_{n,j}}{t - i + 1} ,& t \times \frac{A^L_n}{A^U_n} \le i \le t \\
\end{cases}
\end{equation}
\textcolor{red}{例如一个护士~$n$~的总排班数上限~$A^U_n$~为~22, 下限~$A^L_n$~为~15, 则对于求解~4~周的排班来说, 前两周的排班数下限为~0, 即不需要考虑排班数下限, 从第~3~周开始开始考虑, 其计算方式与排班数上限相同.}

最后, 考虑到对护士的需求往往超过了合同规定的工作量上限, 本算法中辅助目标函数的设计以优先选择排班数较少的方案为目标, 保证在不影响本阶段求解质量的情况下, 尽可能地为后续阶段预留人力资源. 对于两个目标函数值相同的解向量, 可能因为其对违反约束的组成的不同而对后续阶段的排班产生不同的影响. 例如, 有的排班可能对总排班数上限违反较多, 而对主要在本阶段内部发生作用的连续性约束和覆盖性约束违反很少, 这种排班会对后续阶段产生较大的负面影响, 反之, 可以给后续阶段留出更多的调整空间. 因此, 本算法中阶段~$i$~的解向量~$X_i$~的辅助目标函数将更倾向于保留总排班数较少的解. 其具体的计算方法为
\begin{equation}
f'(X_i) = \sum_{n=1}^{|N|} \frac{A_{n,i}}{2 \times A^U_n - \sum_{j=1}^{i-1} A_{n,j}}, \quad i = 1, 2, ..., t
\end{equation}

由于不同护士的总排班数上限不同, 辅助目标函数并不是直接统计所有护士的总排班数, 而是统计各护士当前排班数占剩余排班数上限的比例之和, 保证排班的均衡性. 此外, 分母中对总排班数上限乘以~$2$~是为了保证分母为正数. 当两个解的目标函数值相等时, 优先选择辅助目标函数值更小的解.


\section{计算结果}

\subsection{算例与运行环境}

第二届国际护士排班竞赛的算例包括初赛的~$14$~个数据集和决赛的~$6$~个数据集. 所有数据集均由~$1$~个场景信息文件、$3$~个初始历史信息文件和~$10$~个阶段需求信息文件组成.

\textcolor{red}{其中, 场景信息文件包括以下内容:}
\begin{itemize}
\item \textcolor{red}{\textbf{周期长度. }排班周期长度, 4~周或~8~周.}

\item \textcolor{red}{\textbf{技能列表. }列出所有技能名称.}

\item \textcolor{red}{\textbf{合同列表. }列出所有合同, 对于每一类合同, 给出该合同的名称, 规定的总排班数上下限, 连续工作天数上下限, 连续休息天数上下限, 总周末排班数上限以及是否要求完整周末.}
   
\item \textcolor{red}{\textbf{护士列表. }列出所有护士, 对于每一个护士, 给出该护士的名称, 所属合同以及具备的技能.}

\item \textcolor{red}{\textbf{班次列表. }列出所有班次, 对于每一种班次, 给出该班次的名称, 连续上该班次的天数的上下限以及该班次非法后继班次.}
\end{itemize}

\textcolor{red}{阶段需求信息文件包括以下内容:}
\begin{itemize}
\item \textcolor{red}{\textbf{护士需求. }给出该阶段每天每个时间槽的护士人数下限和最优人数.}

\item \textcolor{red}{\textbf{护士请求. }列出该阶段的护士请求, 每一项护士请求由一个三元组表示, 其中包括护士名称, 日期以及班次名称, 表示该护士在该阶段的某一天请求不上该班次.}
\end{itemize}

\textcolor{red}{历史信息文件包括以下内容:}
\begin{itemize}
\item \textcolor{red}{\textbf{边界数据. }列出所有护士的边界数据, 对于每一个护士, 给出该护士上阶段最后一天的工作班次（如果最后一天休息, 用特殊标志~NONE~表示）, 上阶段最后连续工作天数, 连续相同班次工作天数以及连续休息天数.}

\item \textcolor{red}{\textbf{累积数据. }列出所有护士的累计数据, 对于每一个护士, 给出该护士当前的累积排班数以及工作周末数（在初始历史信息文件中这两项都是~0）.}
\end{itemize}

对于每个数据集, 数据规模主要与护士数相关, 而数据集中的护士数主要分布于~$30$~到~$120$~之间. \textcolor{red}{初赛的数据集的护士数包括~30, 40, 50, 60, 80, 100, 120, 周期长度包括~4~周和~8~周, 因此一共有~14~个数据集; 决赛的数据集的护士数包括~35, 70, 110, 周期长度同样包括~4~周和~8~周, 因此一共有~6~个数据集.} 具体运行时从中选取~$1$~个场景信息文件、~$1$~个初始历史信息文件和~$4$~个或~$8$~个阶段需求信息文件的排列构成一个算例, 因此一个数据集可以生成大量算例. 算例的名称中包括了护士数、周数、初始历史文件编号和阶段需求文件编号序列, 例如, n035w4\_2\_8-8-7-5 表示有~35~个护士, 排班周期为~4~周, 初始历史文件编号为~2, 4~周的需求分别由编号为~8、8、7、5~的需求文件提供. 这些文件按算法~\ref{alg1}~所示的流程依次输入求解程序. 求解护士排班问题得到的目标函数值越小说明解向量的质量越好. 本次竞赛使用的算例\footnote{数据集和算例可在~http://mobiz.vives.be/inrc2/?page\_id=20~下载.}与排名\footnote{决赛排名可在~http://mobiz.vives.be/inrc2/?page\_id=241~查看. }已公布于竞赛官方网站.

\begin{table}[!t]
	\footnotesize
	\cnentablecaption{重要参数设置}{Settings of important parameters}
	\label{tabpara}
	\tabcolsep 14pt %space between two columns. 用于调整列间距
	\begin{threeparttable}
		\begin{tabular*}{\textwidth}{ccccc}
			\toprule
			Parameter & Section & Description & Value in this paper & Recommending range \\\hline
			$th$ & \ref{sec:tabusearch} & 禁忌搜索最大未改进步数 & $scale$\tnote{*} & $[0.8scale, 2scale]$\\
			$\Omega_1$  & \ref{subsec:select} & 邻域选择权重基准值 & 4096 & $[1.5\Omega_2, 4\Omega_2]$ \\
			$\Omega_2$  & \ref{subsec:select} & 邻域选择权重基准值 & 2048 & $[1.5\Omega_3, 4\Omega_3]$ \\
			$\Omega_3$  & \ref{subsec:select} & 邻域选择权重基准值 & 1024 & $[1.5\Omega_4, 4\Omega_4]$ \\
			$\Omega_4$  & \ref{subsec:select} & 邻域选择权重基准值 & 256 &  $[0, 4096]$\\
			$\lambda$  & \ref{subsec:select} & 邻域选择权重调整系数 & 0.125 &  $[0.0625, 0.25]$\\
			$l_1$  & \ref{subsec:tabu} & 禁忌步长 & $1.5|D_i|$ & $[|D_i|, 2|D_i|]$ \\
			$l_2$  & \ref{subsec:tabu} & 禁忌步长 & $1.5|D_i|$ & $[|D_i|, 2|D_i|]$ \\
			$r_1$  & \ref{subsec:weight} & 护士选择比例 & 0.2 & $[0.1, 0.4]$ \\
			$r_2$  & \ref{subsec:weight} & 护士选择比例 & 0.05 & $[0.01, 0.1]$\\
			\bottomrule
		\end{tabular*}
		\begin{tablenotes}
			\small
			\item[*] $scale$ stands for problem scale, and $scale = |N| \times |D_i| \times \sqrt{|H| \times |K|}$.
		\end{tablenotes}
	\end{threeparttable}
\end{table}

本算法使用~C++~编写, 由~Visual C++ 2013~编译. 程序的运行环境为~Windows Server 2012~操作系统, Intel Xeon E5-2609 2.5GHz CPU, 32GB~内存. 运行时间由竞赛官方网站提供的基准测试程序\footnote{基准测试程序可在~http://mobiz.vives.be/inrc2/?page\_id=245~下载.}求得, 其给定的运行时间与护士数量成正比.
算法中的重要参数如表格~\ref{tabpara}~所示.


\subsection{第二届国际护士排班竞赛结果对比}

\begin{table}[!t]
	\footnotesize
	\cnentablecaption{小规模算例计算结果}{Computational result on small scale instances}
	\label{tab1}
	\tabcolsep 10pt %space between two columns. 用于调整列间距
	\begin{tabular*}{\textwidth}{c|ccc|cc}
		\toprule
		Instance & Known best & Our best & Winner's best & Our Average & Winner's Average \\\hline
		n035w4\_2\_8-8-7-5         & 1255 & 1335 & 1255 & 1370.5 & 1367.5 \\
		n035w4\_0\_1-7-1-8         & 1630 & 1685 & 1630 & 1756.5 & 1630 \\
		n035w4\_0\_4-2-1-6         & 1800 & 1970 & 1810 & 2021.5 & 1831.5 \\
		n035w4\_0\_5-9-5-6         & 1755 & 1760 & 1755 & 1834.5 & 1755 \\
		n035w4\_0\_9-8-7-7         & 1540 & 1660 & 1545 & 1723.5 & 1586 \\
		n035w4\_1\_0-6-9-2         & 1500 & 1650 & 1525 & 1737 & 1545 \\
		n035w4\_2\_8-6-7-1         & 1490 & 1600 & 1510 & 1644.5 & 1510 \\
		n035w4\_2\_9-2-2-6         & 1705 & 1895 & 1705 & 1947.5 & 1708 \\
		n035w4\_2\_9-7-2-2         & 1650 & 1940 & 1650 & 1970.5 & 1695 \\
		n035w4\_2\_9-9-2-1         & 1620 & 1880 & 1620 & 1927.5 & 1652 \\
		n035w8\_0\_6-2-9-8-7-7-9-8 & 3020 & 3505 & 99999 & 3628 & 99999 \\
		n035w8\_1\_0-8-1-6-1-7-2-0 & 2770 & 3405 & 2900 & 3653.5 & 12669.4 \\
		n035w8\_1\_0-8-4-0-9-1-3-2 & 2775 & 3190 & 2870 & 3378.5 & 80576.7 \\
		n035w8\_1\_1-4-4-9-3-5-3-2 & 2805 & 3180 & 2810 & 3325 & 2849.5 \\
		n035w8\_1\_7-0-6-2-1-1-1-6 & 2840 & 3440 & 2840 & 3548.5 & 2842 \\
		n035w8\_2\_2-1-7-1-8-7-4-2 & 2910 & 3445 & 3050 & 3672 & 90304.1 \\
		n035w8\_2\_7-1-4-9-2-2-6-7 & 2960 & 3540 & 2960 & 3632.5 & 3028.5 \\
		n035w8\_2\_8-8-7-5-0-0-6-9 & 2815 & 3385 & 2815 & 3603 & 2863 \\
		n035w8\_2\_9-5-6-3-9-9-2-1 & 3045 & 3350 & 3045 & 3533.5 & 3083.5 \\
		n035w8\_2\_9-7-2-2-5-7-4-3 & 2715 & 3295 & 2865 & 3488 & 2928 \\
		\bottomrule
	\end{tabular*}
\end{table}

\begin{table}[!t]
	\footnotesize
	\cnentablecaption{中等规模算例计算结果}{Computational result on medium scale instances}
	\label{tab2}
	\tabcolsep 10pt %space between two columns. 用于调整列间距
	\begin{tabular*}{\textwidth}{c|ccc|cc}
		\toprule
		Instance & Known best & Our best & Winner's best & Our Average & Winner's Average \\\hline
		n070w4\_0\_3-6-5-1         & 2700 & 3090 & 2705 & 3151 & 2723 \\
		n070w4\_0\_4-9-6-7         & 2430 & 2790 & 2430 & 2889 & 2446 \\
		n070w4\_0\_4-9-7-6         & 2475 & 2865 & 2475 & 2948 & 2557.5 \\
		n070w4\_0\_8-6-0-8         & 2435 & 2855 & 2435 & 3016 & 2477 \\
		n070w4\_0\_9-1-7-5         & 2320 & 2725 & 2320 & 2864 & 2323 \\
		n070w4\_1\_1-3-8-8         & 2700 & 3035 & 2700 & 3134.5 & 2728 \\
		n070w4\_2\_0-5-6-8         & 2520 & 2880 & 2520 & 3012 & 2533 \\
		n070w4\_2\_3-5-8-2         & 2615 & 3050 & 2615 & 3141.5 & 2635 \\
		n070w4\_2\_5-8-2-5         & 2540 & 2875 & 2540 & 3005.5 & 2544.5 \\
		n070w4\_2\_9-5-6-5         & 2615 & 2975 & 2615 & 3046 & 2652 \\
		n070w8\_0\_3-3-9-2-3-7-5-2 & 5115 & 6000 & 5115 & 6222 & 5164 \\
		n070w8\_0\_9-3-0-7-2-1-1-0 & 5390 & 6420 & 5390 & 6602 & 5478.5 \\
		n070w8\_1\_5-6-8-5-7-8-5-6 & 5475 & 6095 & 5475 & 6236.5 & 5549 \\
		n070w8\_1\_9-8-9-9-2-8-1-4 & 5100 & 5700 & 5100 & 6018.5 & 5167 \\
		n070w8\_2\_4-9-2-0-2-7-0-6 & 5410 & 5990 & 5410 & 6259 & 5581.5 \\
		n070w8\_2\_5-1-3-0-8-0-5-8 & 5280 & 5975 & 5280 & 6315 & 5359.5 \\
		n070w8\_2\_5-7-4-8-7-2-9-9 & 5505 & 6210 & 5505 & 6317.5 & 5531.5 \\
		n070w8\_2\_6-3-0-1-8-1-5-9 & 5120 & 5960 & 5120 & 6255 & 5240 \\
		n070w8\_2\_8-6-0-1-6-4-7-8 & 5350 & 6205 & 5350 & 6492.5 & 7138.5 \\
		n070w8\_2\_9-3-5-2-2-9-2-0 & 5320 & 5895 & 5320 & 6044.5 & 5374 \\
		\bottomrule
	\end{tabular*}
\end{table}

\begin{table}[!t]
	\footnotesize
	\cnentablecaption{大规模算例计算结果}{Computational result on large scale instances}
	\label{tab3}
	\tabcolsep 10pt %space between two columns. 用于调整列间距
	\begin{tabular*}{\textwidth}{c|ccc|cc}
		\toprule
		Instance & Known best & Our best & Winner's best & Our Average & Winner's Average \\\hline
		n110w4\_0\_1-4-2-8         & 2710 & 3395 & 2720 & 3539 & 2725 \\
		n110w4\_0\_1-9-3-5         & 2920 & 3475 & 2970 & 3663 & 3065 \\
		n110w4\_1\_0-1-6-4         & 2850 & 3685 & 2920 & 3769 & 12690.4 \\
		n110w4\_1\_0-5-8-8         & 2820 & 3440 & 2895 & 3569.5 & 3210 \\
		n110w4\_1\_2-9-2-0         & 3345 & 3995 & 3380 & 4092 & 3425 \\
		n110w4\_1\_4-8-7-2         & 2805 & 3515 & 2805 & 3661 & 2855.5 \\
		n110w4\_2\_0-2-7-0         & 3005 & 3795 & 3175 & 3903.5 & 51625.5 \\
		n110w4\_2\_5-1-3-0         & 2925 & 3520 & 3025 & 3637.5 & 3095 \\
		n110w4\_2\_8-9-9-2         & 3415 & 3895 & 3470 & 4025 & 3502.5 \\
		n110w4\_2\_9-8-4-9         & 3135 & 3640 & 3335 & 3769 & 3540 \\
		n110w8\_0\_2-1-1-7-2-6-4-7 & 5155 & 6420 & 5165 & 6596 & 5243 \\
		n110w8\_0\_3-2-4-9-4-1-3-7 & 4805 & 6015 & 4830 & 6172.5 & 4982.5 \\
		n110w8\_0\_5-5-2-2-5-3-4-7 & 4750 & 6065 & 4870 & 6227 & 4939 \\
		n110w8\_0\_7-8-7-5-9-7-8-1 & 4855 & 6105 & 5005 & 6251.5 & 5234 \\
		n110w8\_0\_8-8-0-2-3-4-6-3 & 4465 & 5920 & 4955 & 6146.5 & 5021.5 \\
		n110w8\_0\_8-8-2-2-3-2-0-8 & 4865 & 6310 & 5435 & 6469 & 5510.5 \\
		n110w8\_1\_0-6-1-0-3-2-9-1 & 5090 & 6330 & 5175 & 6514 & 5259.5 \\
		n110w8\_1\_4-1-3-6-8-8-1-3 & 4315 & 5925 & 4785 & 6115.5 & 4842.5 \\
		n110w8\_2\_2-9-5-5-1-8-4-0 & 4770 & 5840 & 5200 & 6222.5 & 5274 \\
		n110w8\_2\_8-5-7-3-9-8-8-5 & 4360 & 5540 & 4765 & 5809 & 5292 \\
		\bottomrule
	\end{tabular*}
\end{table}

决赛中一共使用了三种规模的数据集共~60~个算例, \textcolor{red}{包括~35~个护士~4~周、35~个护士~8~周、70~个护士~4~周、70~个护士~8~周、110~个护士~4~周、110~个护士~8~周各~10~个算例,} 对每个算例独立运行~10~次. 本算法在决赛中取得了第四名的成绩. 相比于其它进入决赛的队伍, 前两名在大多数算例上保持了一定的优势, 但是都存在无法于给定时间内求得合法解的情况, 其中第一名的算法在组委会提供的环境下进行的~$600$~次运行中, 有~$34$~次产生了非法解, 而本算法均能产生合法解, 表明本算法在稳定性上与前两名相比有一定的优势.%由于本次竞赛的排名方案并未对产生非法解的情况施加严格的惩罚机制, 前两名凭借在大多数算例上积累的巨大优势保持了其领先地位.

决赛中小规模、中等规模和大规模算例的计算结果分别如表~\ref{tab1}、表~\ref{tab2}~和表~\ref{tab3}~所示, \textcolor{red}{表~\ref{tab1}~给出了~35~个护士~4~周和~8~周共~20~个算例的结果, 表~\ref{tab2}~给出了~70~个护士~4~周和~8~周共~20~个算例的结果, 表~\ref{tab3}~给出了~110~个护士~4~周和~8~周的结果.} 表格的内容为目标函数值, \textcolor{red}{其中~Known best~表示所有参赛者中的最优结果, Our best~表示本算法~10~次测试中的最优结果, Winner's best~表示决赛第一名获得者~10~次测试中的最优结果, Our Average~表示本算法~10~次测试的平均值, Winner's Average~表示决赛第一名获得者~10~次测试的平均值}. 对于求出非法解的情况, 竞赛组委会将其目标函数值设为一个大于所有参赛者所求目标函数值的数值, 在本次竞赛中为~$99999$. 从结果对比可以看出, 本算法的最优解质量离第一名有一定差距, 存在改进空间, 但是对不同算例均能提供合法解. 而第一名的算法在算例~n035w8\_0\_6-2-9-8-7-7-9-8~上~$10$~次运行均没有求出合法解, 同时在多个算例上产生了非法解\textcolor{red}{（n035w8\_1\_0-8-1-6-1-7-2-0, n035w8\_1\_0-8-4-0-9-1-3-2, n035w8\_2\_2-1-7-1-8-7-4-2, n110w4\_1\_0-1-6-4, n110w4\_2\_0-2-7-0）}, 导致其在这些算例上的平均求解质量不如本算法.


\section{分析与讨论}

第~\ref{sec:implement}~章中描述了算法的关键模块和策略, 本\textcolor{red}{章}将对本算法使用的策略与其它可能的策略进行对比分析, 以阐明选择这些方案的原因. 本\textcolor{red}{章}中使用的算例均从决赛算例中挑选, 对于每个算例, 独立重复运行了~$32$~次.

\subsection{邻域结构对比分析}

\begin{figure}[!t]
	\centering
	\begin{minipage}[c]{0.48\textwidth}
		\centering
		\begin{tikzpicture}
		\begin{axis}[
		title={},
		xlabel={Iteration (~$\log_ai$~times)},
		ylabel={Best objective value found so far}, y label style={at={(0.05,0.5)}},
		xmin=0, xmax=125,
		ymin=0, ymax=25000,
		xtick={0,25,50,75,100,125},
		ytick={0,5000,10000,15000,20000,25000},
		legend pos=north east,
		ymajorgrids=true,
		grid style=dashed,
		width = \textwidth,% height = 3in,
		]
		
		\addplot[
		color=blue,
		style=solid,
		%mark=square, % triangle, diamond, o, *, x, +, asterisk
		]
		coordinates {
			(0,7285.75) (1,7184.19) (2,7099.34) (3,6979.97) (4,6864.81)
			(5,6767.94) (6,6676.22) (7,6579.97) (8,6473.47) (9,6345.66)
			(10,6250.34) (11,6133) (12,6049) (13,5963.22) (14,5858.69)
			(15,5776.81) (16,5697.28) (17,5592.03) (18,5517.22) (19,5428.03)
			(20,5355.31) (21,5294.63) (22,5224.47) (23,5147.78) (24,5086.38)
			(25,5032.69) (26,4964.09) (27,4893.31) (28,4821.44) (29,4764.72)
			(30,4710.03) (31,4642.06) (32,4577.28) (33,4514.94) (34,4470.56)
			(35,4417.28) (36,4351.66) (37,4299.94) (38,4253.53) (39,4198.34)
			(40,4150.44) (41,4112.38) (42,4073.84) (43,4046.97) (44,4012.56)
			(45,3977.72) (46,3936.78) (47,3880.84) (48,3833.75) (49,3795)
			(50,3754.47) (51,3717.28) (52,3598.66) (53,3405.53) (54,3262.47)
			(55,3115.06) (56,2952.09) (57,2800.22) (58,2640.53) (59,2470.38)
			(60,2245.41) (61,2095.56) (62,1963.69) (63,1819.97) (64,1684.88)
			(65,1577.56) (66,1511.38) (67,1457.41) (68,1394.13) (69,1360.63)
			(70,1330.94) (71,1298.06) (72,1268.69) (73,1252.16) (74,1230.31)
			(75,1217.97) (76,1197.16) (77,1175.44) (78,1164.66) (79,1152.88)
			(80,1132.78) (81,1124.59) (82,1116.69) (83,1100.91) (84,1090.13)
			(85,1075.38) (86,1063.19) (87,1054.38) (88,1041.31) (89,1026.16)
			(90,1017.88) (91,1001.63) (92,989.031) (93,970.219) (94,956.781)
			(95,945.906) (96,931.75) (97,920.938) (98,909.969) (99,901)
			(100,892.094) (101,879.188) (102,872.469) (103,868.188) (104,861.406)
			(105,857.5) (106,845.688) (107,840.688) (108,835.594) (109,830.594)
			(110,820.219) (111,811.625) (112,798.031) (113,782.625) (114,776.531)
			(115,770.125) (116,758.844) (117,747) (118,732.938) (119,721.531)
			(120,713.094) (121,703.719) (122,701.938) (123,698.125) (124,693.531)
		};
		\addplot[
		color=black,
		style=solid,
		%mark=triangle,
		]
		coordinates {
			(0,16523.8) (1,16402) (2,16258.2) (3,16113.1) (4,15977.4)
			(5,15781) (6,15587.9) (7,15413.2) (8,15252.4) (9,15158.1)
			(10,15031) (11,14916.4) (12,14773.8) (13,14642.1) (14,14502.1)
			(15,14378.2) (16,14246.9) (17,14127.5) (18,14011.9) (19,13907.3)
			(20,13780.4) (21,13675.9) (22,13578.8) (23,13487.8) (24,13414.2)
			(25,13320.8) (26,13226.2) (27,13129.6) (28,13046.6) (29,12966.9)
			(30,12888.5) (31,12813.8) (32,12725.6) (33,12647.2) (34,12572.3)
			(35,12502.5) (36,12419.2) (37,12332.1) (38,12267.3) (39,12194.5)
			(40,12140.6) (41,12061.4) (42,11999.5) (43,11923) (44,11853.3)
			(45,11788.8) (46,11724.6) (47,11670.3) (48,11598.7) (49,11525.9)
			(50,11466.3) (51,11401.5) (52,11219.9) (53,10947.2) (54,10696.6)
			(55,10408.3) (56,10107.5) (57,9812.75) (58,9467.47) (59,9128.09)
			(60,8781.25) (61,8449.38) (62,8104.19) (63,7729.5) (64,7404.19)
			(65,7018.88) (66,6565.5) (67,6136.47) (68,5705) (69,5238.31)
			(70,4792.63) (71,4377.06) (72,4033.44) (73,3674.22) (74,3376.41)
			(75,3171.19) (76,3025.16) (77,2923.72) (78,2843.56) (79,2793.44)
			(80,2737.56) (81,2680.84) (82,2640.53) (83,2610.03) (84,2578.22)
			(85,2542.88) (86,2521.41) (87,2494.25) (88,2464.41) (89,2437.59)
			(90,2406.31) (91,2385.75) (92,2369.19) (93,2340.38) (94,2315.47)
			(95,2295.94) (96,2279.63) (97,2263.72) (98,2245.06) (99,2227.03)
			(100,2219.69) (101,2203.28) (102,2181.78) (103,2171.06) (104,2159.44)
			(105,2138.56) (106,2124.09) (107,2104.34) (108,2093) (109,2077.16)
			(110,2068.56) (111,2059.41) (112,2035) (113,2022.88) (114,2012.19)
			(115,1999.72) (116,1984.16) (117,1971.66) (118,1956.25) (119,1947.16)
			(120,1928.97) (121,1917.13) (122,1894.47) (123,1872.75) (124,1861.41)
		};
		\addplot[
		color=red,
		style=solid,
		%mark=triangle,
		]
		coordinates {
			(0,24220.7) (1,24106.3) (2,23968) (3,23864.7) (4,23734.6)
			(5,23564.9) (6,23428.8) (7,23304.7) (8,23159.4) (9,22996.9)
			(10,22828.8) (11,22651.6) (12,22491.3) (13,22318.6) (14,22157.8)
			(15,22046.6) (16,21907.3) (17,21792) (18,21675.7) (19,21527.5)
			(20,21393.6) (21,21256.1) (22,21149.6) (23,21039.5) (24,20918.7)
			(25,20786.8) (26,20657.9) (27,20543.3) (28,20429.7) (29,20315.3)
			(30,20193.7) (31,20088.4) (32,20011.1) (33,19899.4) (34,19788.6)
			(35,19675.6) (36,19576.9) (37,19490.3) (38,19395.6) (39,19317.9)
			(40,19239.9) (41,19137.7) (42,19058) (43,18958.1) (44,18866.7)
			(45,18760.3) (46,18675.7) (47,18597.1) (48,18509.3) (49,18418.5)
			(50,18315.3) (51,18226.2) (52,18010.2) (53,17640.3) (54,17353.8)
			(55,17017) (56,16621.8) (57,16237.3) (58,15869.9) (59,15459.5)
			(60,14961.9) (61,14565) (62,14107.9) (63,13632.7) (64,13154.5)
			(65,12648.9) (66,12154.1) (67,11565.1) (68,10944.9) (69,10265.6)
			(70,9655.25) (71,9044.38) (72,8372.78) (73,7658.25) (74,6958.56)
			(75,6241) (76,5643.75) (77,5051.34) (78,4483.91) (79,3928.69)
			(80,3522.34) (81,3196.59) (82,3035.59) (83,2934.28) (84,2863.41)
			(85,2799.59) (86,2741.97) (87,2704.19) (88,2666.41) (89,2626.81)
			(90,2609.97) (91,2571.59) (92,2543.13) (93,2522.56) (94,2498.53)
			(95,2473.63) (96,2459.38) (97,2442.13) (98,2431.5) (99,2418.09)
			(100,2405.69) (101,2399.34) (102,2387.22) (103,2373.88) (104,2359.88)
			(105,2341.44) (106,2330.38) (107,2318.97) (108,2311.56) (109,2303.13)
			(110,2289.66) (111,2286.38) (112,2274.22) (113,2256.47) (114,2249.44)
			(115,2234.97) (116,2224.06) (117,2206.66) (118,2195.56) (119,2189.44)
			(120,2175.22) (121,2163.44) (122,2150.41) (123,2135.63) (124,2127.84)
		};
		\addplot[
		color=blue,
		style=dashed,
		%mark=square, % triangle, diamond, o, *, x, +, asterisk
		]
		coordinates {
			(0,7122.88) (1,6973.25) (2,6795.75) (3,6629.28) (4,6498.66)
			(5,6321.63) (6,6149.09) (7,5970.31) (8,5816.06) (9,5658.41)
			(10,5509.28) (11,5388.09) (12,5246.97) (13,5111.19) (14,4987.16)
			(15,4857.53) (16,4745.88) (17,4631.72) (18,4513.47) (19,4415.91)
			(20,4313.06) (21,4226.03) (22,4115.78) (23,4012.41) (24,3912.91)
			(25,3841.78) (26,3776.63) (27,3690.28) (28,3613.81) (29,3536)
			(30,3473.75) (31,3411.44) (32,3341.91) (33,3272.13) (34,3202.38)
			(35,3151.59) (36,3086.81) (37,3032.38) (38,2977.5) (39,2920.31)
			(40,2866) (41,2807.91) (42,2755.41) (43,2704.19) (44,2650.91)
			(45,2598.28) (46,2547.5) (47,2505.19) (48,2462.94) (49,2419.75)
			(50,2377.25) (51,2331.78) (52,2209.03) (53,2005.88) (54,1861.53)
			(55,1713.84) (56,1552.56) (57,1401.66) (58,1282.75) (59,1151.25)
			(60,1030.06) (61,921.094) (62,839.219) (63,768.844) (64,728.281)
			(65,698.125) (66,676.594) (67,652.344) (68,639.438) (69,626.156)
			(70,614.063) (71,601.875) (72,592.156) (73,573.625) (74,560.313)
			(75,553.969) (76,545.719) (77,538.594) (78,534.063) (79,524.594)
			(80,517.781) (81,511.906) (82,502.938) (83,499.656) (84,492.375)
			(85,487.969) (86,482.188) (87,479.813) (88,477) (89,471.75)
			(90,469.188) (91,466.281) (92,463.625) (93,460.5) (94,458.094)
			(95,456.438) (96,453.219) (97,449.688) (98,447.188) (99,445.938)
			(100,444.844) (101,443.781) (102,441.75) (103,439.25) (104,437.938)
			(105,437.625) (106,436.531) (107,435.125) (108,434.656) (109,433.094)
			(110,431.844) (111,430.688) (112,430.219) (113,429.906) (114,429.031)
			(115,427.938) (116,427.156) (117,426.688) (118,426.219) (119,426.219)
			(120,425.438) (121,425.281) (122,425.125) (123,424.156) (124,423.063)
		};
		\addplot[
		color=black,
		style=dashed,
		%mark=triangle,
		]
		coordinates {
			(0,16574) (1,16303.3) (2,16053.3) (3,15891.7) (4,15644.1)
			(5,15466.4) (6,15218.9) (7,14969.3) (8,14705.3) (9,14467.7)
			(10,14208.8) (11,13952.1) (12,13746.6) (13,13537.6) (14,13325.2)
			(15,13125.8) (16,12944.3) (17,12735.8) (18,12567) (19,12412.2)
			(20,12229.7) (21,12074.7) (22,11899.8) (23,11692) (24,11539.5)
			(25,11394) (26,11267.1) (27,11108.2) (28,10974.9) (29,10836.1)
			(30,10722.5) (31,10559.6) (32,10409.2) (33,10276.4) (34,10142)
			(35,10026.7) (36,9893.13) (37,9768.91) (38,9647.91) (39,9498.69)
			(40,9393.72) (41,9280.94) (42,9177.91) (43,9073) (44,8993.84)
			(45,8904.44) (46,8793.66) (47,8704.75) (48,8618.44) (49,8529.03)
			(50,8437.06) (51,8333.41) (52,8077.81) (53,7647.03) (54,7332.59)
			(55,6983.56) (56,6555.63) (57,6206.28) (58,5893.34) (59,5530.75)
			(60,5173.06) (61,4822.31) (62,4484.06) (63,4180.69) (64,3847.22)
			(65,3531.66) (66,3241.31) (67,2966.47) (68,2737.16) (69,2503.5)
			(70,2308.78) (71,2080.78) (72,1889.69) (73,1699.72) (74,1590.31)
			(75,1524.84) (76,1480.25) (77,1460.84) (78,1445.06) (79,1432.31)
			(80,1415.16) (81,1408.75) (82,1398.78) (83,1390.22) (84,1380.06)
			(85,1374.22) (86,1367.97) (87,1360.75) (88,1356) (89,1348.72)
			(90,1344.19) (91,1338.84) (92,1333.44) (93,1323.44) (94,1318.41)
			(95,1316.38) (96,1313.72) (97,1308.72) (98,1302.69) (99,1300.09)
			(100,1297.28) (101,1292.72) (102,1292) (103,1289.66) (104,1286.94)
			(105,1281.63) (106,1276.31) (107,1272.28) (108,1267.66) (109,1262.66)
			(110,1258.16) (111,1254.22) (112,1249.41) (113,1246.28) (114,1244.25)
			(115,1242.91) (116,1241.59) (117,1238.16) (118,1237.47) (119,1234.59)
			(120,1230.75) (121,1227.19) (122,1223.38) (123,1221.97) (124,1219.72)
		};
		\addplot[
		color=red,
		style=dashed,
		%mark=triangle,
		]
		coordinates {
			(0,24208.9) (1,23981.2) (2,23801.8) (3,23628.8) (4,23388.3)
			(5,23181) (6,22974.9) (7,22721.8) (8,22520.3) (9,22286)
			(10,22036.3) (11,21835) (12,21655.3) (13,21457.4) (14,21256)
			(15,21008.6) (16,20804.8) (17,20606.2) (18,20414.5) (19,20203.3)
			(20,20025.2) (21,19821.5) (22,19622.1) (23,19449.1) (24,19286.8)
			(25,19111.3) (26,18919.2) (27,18727.6) (28,18546.3) (29,18391.5)
			(30,18251) (31,18117.6) (32,17948.1) (33,17788.4) (34,17600.5)
			(35,17443.3) (36,17284.3) (37,17122.3) (38,16996.1) (39,16859.9)
			(40,16702.9) (41,16574.3) (42,16440.8) (43,16313.9) (44,16203.8)
			(45,16077.2) (46,15956.2) (47,15834.1) (48,15722.9) (49,15605.1)
			(50,15450.3) (51,15334.7) (52,15021) (53,14495.8) (54,14126.3)
			(55,13645.6) (56,13113.9) (57,12610.6) (58,12112.4) (59,11554.4)
			(60,10997.8) (61,10441.1) (62,9836.59) (63,9303.31) (64,8771.88)
			(65,8191.22) (66,7608.59) (67,7032.72) (68,6492.84) (69,6000.13)
			(70,5444.31) (71,4944.22) (72,4476.34) (73,3952.25) (74,3508.47)
			(75,3079.53) (76,2663.16) (77,2287.19) (78,1997.84) (79,1880.5)
			(80,1836.06) (81,1815.66) (82,1795.47) (83,1779.69) (84,1766.31)
			(85,1736.53) (86,1716.34) (87,1702.09) (88,1676.66) (89,1657.78)
			(90,1639.81) (91,1611.5) (92,1593.53) (93,1564.63) (94,1535.66)
			(95,1513.09) (96,1496.75) (97,1481.47) (98,1469.22) (99,1454.75)
			(100,1440.75) (101,1430.97) (102,1419.63) (103,1406.03) (104,1393.22)
			(105,1384.75) (106,1374.72) (107,1368.75) (108,1363.38) (109,1357)
			(110,1352) (111,1347.84) (112,1343.88) (113,1339.28) (114,1333.13)
			(115,1329.19) (116,1326.97) (117,1325.06) (118,1321.69) (119,1319.03)
			(120,1317.28) (121,1314.75) (122,1311.13) (123,1305.66) (124,1303.09)
		};
		\legend{S$-M_4$, M$-M_4$, L$-M_4$, S$+M_4$, M$+M_4$, L$+M_4$}
		
		\end{axis}
		\end{tikzpicture}
	\end{minipage}
	%\hspace{0.04\textwidth}
	\begin{minipage}[c]{0.48\textwidth}
		\centering
		\begin{tikzpicture}
		\begin{axis}[
		title={},
		xlabel={Time (~$\log_at$~seconds)},
		ylabel={Best objective value found so far}, y label style={at={(0.05,0.5)}},
		xmin=0, xmax=125,
		ymin=0, ymax=25000,
		xtick={0,25,50,75,100,125},
		ytick={0,5000,10000,15000,20000,25000},
		legend pos=north east,
		ymajorgrids=true,
		grid style=dashed,
		width = \textwidth,% height = 3in,
		]
		
		\addplot[
		color=blue,
		style=solid,
		%mark=square, % triangle, diamond, o, *, x, +, asterisk
		]
		coordinates {
			(0,7285.75) (1,7184.19) (2,7099.34) (3,6979.97) (4,6864.81)
			(5,6767.94) (6,6676.22) (7,6579.97) (8,6473.47) (9,6345.66)
			(10,6250.34) (11,6133) (12,6049) (13,5963.22) (14,5858.69)
			(15,5776.81) (16,5697.28) (17,5592.03) (18,5517.22) (19,5428.03)
			(20,5355.31) (21,5294.63) (22,5224.47) (23,5147.78) (24,5086.38)
			(25,5032.69) (26,4964.09) (27,4893.31) (28,4821.44) (29,4764.72)
			(30,4710.03) (31,4642.06) (32,4577.28) (33,4514.94) (34,4470.56)
			(35,4417.28) (36,4351.66) (37,4283.38) (38,4081.97) (39,3758.53)
			(40,3474.28) (41,3233.78) (42,2979.81) (43,2534.59) (44,2098.16)
			(45,1831.63) (46,1638.69) (47,1523.97) (48,1415.78) (49,1307.53)
			(50,1240.13) (51,1188.19) (52,1162.25) (53,1125.63) (54,1103.66)
			(55,1077.13) (56,1056.25) (57,1041.47) (58,1026) (59,1004.34)
			(60,987.625) (61,969.813) (62,952.906) (63,939.594) (64,931.938)
			(65,917.469) (66,905.125) (67,896.469) (68,886.813) (69,878.531)
			(70,864.844) (71,859.844) (72,854.75) (73,841.156) (74,829.656)
			(75,824.5) (76,808.406) (77,804.25) (78,796.25) (79,781.969)
			(80,771.281) (81,754.75) (82,739.188) (83,725.813) (84,716.594)
			(85,711) (86,708.75) (87,699.094) (88,691.969) (89,684.844)
			(90,681.875) (91,676.5) (92,670.031) (93,663.375) (94,659)
			(95,656.188) (96,653.375) (97,650.875) (98,646.656) (99,644.344)
			(100,638) (101,632.813) (102,627) (103,621.063) (104,614.625)
			(105,611.25) (106,606.781) (107,600.594) (108,594.969) (109,588.813)
			(110,583.031) (111,578.906) (112,575.25) (113,570.344) (114,565.406)
			(115,562.25) (116,560.375) (117,553.719) (118,548.563) (119,544.75)
			(120,540.844) (121,535.844) (122,533.813) (123,530.063) (124,525.75)
		};
		\addplot[
		color=black,
		style=solid,
		%mark=triangle,
		]
		coordinates {
			(0,16523.8) (1,16402) (2,16258.2) (3,16113.1) (4,15977.4)
			(5,15781) (6,15587.9) (7,15413.2) (8,15252.4) (9,15158.1)
			(10,15031) (11,14916.4) (12,14773.8) (13,14642.1) (14,14502.1)
			(15,14378.2) (16,14246.9) (17,14127.5) (18,14011.9) (19,13907.3)
			(20,13780.4) (21,13675.9) (22,13578.8) (23,13487.8) (24,13414.2)
			(25,13320.8) (26,13226.2) (27,13129.6) (28,13046.6) (29,12966.9)
			(30,12888.5) (31,12813.8) (32,12725.6) (33,12647.2) (34,12572.3)
			(35,12502.5) (36,12419.2) (37,12332.1) (38,12267.3) (39,12194.5)
			(40,12079.2) (41,11864.5) (42,11508.2) (43,10739) (44,10019.3)
			(45,9286.47) (46,8663.28) (47,8075.22) (48,7555.16) (49,6779.81)
			(50,6081) (51,5422.16) (52,4663.63) (53,4059.47) (54,3588.28)
			(55,3193.44) (56,2968.5) (57,2842.66) (58,2757.38) (59,2667.84)
			(60,2603.78) (61,2558.22) (62,2513.06) (63,2472.44) (64,2429.28)
			(65,2397.25) (66,2366.38) (67,2333.66) (68,2311.88) (69,2289.25)
			(70,2268.81) (71,2248.91) (72,2226.19) (73,2210.84) (74,2192.56)
			(75,2174.69) (76,2158.88) (77,2135.75) (78,2120.25) (79,2099.5)
			(80,2083.09) (81,2072) (82,2064.16) (83,2037.66) (84,2025.22)
			(85,2013.97) (86,2001.75) (87,1982.75) (88,1970.97) (89,1954.91)
			(90,1941.84) (91,1925.22) (92,1911.91) (93,1887.91) (94,1874.41)
			(95,1856.41) (96,1838.16) (97,1831.38) (98,1824.94) (99,1816.5)
			(100,1800.38) (101,1787.56) (102,1763.56) (103,1739.25) (104,1715.06)
			(105,1702.41) (106,1686.41) (107,1665.38) (108,1648.81) (109,1639.66)
			(110,1632.09) (111,1624.06) (112,1599.75) (113,1580.41) (114,1567.31)
			(115,1558.84) (116,1541.75) (117,1537.22) (118,1533.97) (119,1520.38)
			(120,1505.5) (121,1502.47) (122,1494.97) (123,1492.06) (124,1485.16)
		};
		\addplot[
		color=red,
		style=solid,
		%mark=triangle,
		]
		coordinates {
			(0,24220.7) (1,24106.3) (2,23968) (3,23864.7) (4,23734.6)
			(5,23564.9) (6,23428.8) (7,23304.7) (8,23159.4) (9,22996.9)
			(10,22828.8) (11,22651.6) (12,22491.3) (13,22318.6) (14,22157.8)
			(15,22046.6) (16,21907.3) (17,21792) (18,21675.7) (19,21527.5)
			(20,21393.6) (21,21256.1) (22,21149.6) (23,21039.5) (24,20918.7)
			(25,20786.8) (26,20657.9) (27,20543.3) (28,20429.7) (29,20315.3)
			(30,20193.7) (31,20088.4) (32,20011.1) (33,19899.4) (34,19788.6)
			(35,19675.6) (36,19576.9) (37,19490.3) (38,19395.6) (39,19317.9)
			(40,19239.9) (41,19137.7) (42,19052.4) (43,18872.5) (44,18417.1)
			(45,17771.6) (46,17133.2) (47,16479) (48,15907.9) (49,15079.6)
			(50,14309) (51,13606.6) (52,12734.9) (53,11938.7) (54,11145.4)
			(55,10164.6) (56,9305.69) (57,8496.38) (58,7625.63) (59,6836.5)
			(60,6005.81) (61,5244.63) (62,4623.59) (63,3967.34) (64,3454.59)
			(65,3161.47) (66,3035.63) (67,2897.81) (68,2788.47) (69,2710.63)
			(70,2650) (71,2621.66) (72,2586) (73,2538.5) (74,2501.25)
			(75,2486.5) (76,2465.41) (77,2444.41) (78,2420.28) (79,2407.28)
			(80,2398.25) (81,2384.28) (82,2368.59) (83,2344.09) (84,2333.31)
			(85,2320.13) (86,2311.78) (87,2306.94) (88,2291.59) (89,2284.81)
			(90,2267.19) (91,2255.78) (92,2243.97) (93,2229.16) (94,2208.16)
			(95,2198.06) (96,2190.91) (97,2178.91) (98,2164.69) (99,2153.91)
			(100,2139.91) (101,2129.66) (102,2113.66) (103,2098.44) (104,2082)
			(105,2073.91) (106,2062.5) (107,2055.41) (108,2042.91) (109,2032.69)
			(110,2026.19) (111,2014.66) (112,2000.13) (113,1991.06) (114,1972.44)
			(115,1961.59) (116,1948.5) (117,1932.88) (118,1922.41) (119,1909.81)
			(120,1898.22) (121,1887.84) (122,1880.25) (123,1871.28) (124,1859.69)
		};
		\addplot[
		color=blue,
		style=dashed,
		%mark=square, % triangle, diamond, o, *, x, +, asterisk
		]
		coordinates {
			(0,7122.88) (1,6973.25) (2,6795.75) (3,6629.28) (4,6498.66)
			(5,6321.63) (6,6149.09) (7,5970.31) (8,5816.06) (9,5658.41)
			(10,5509.28) (11,5388.09) (12,5246.97) (13,5111.19) (14,4987.16)
			(15,4857.53) (16,4745.88) (17,4631.72) (18,4513.47) (19,4415.91)
			(20,4313.06) (21,4226.03) (22,4115.78) (23,4012.41) (24,3912.91)
			(25,3841.78) (26,3776.63) (27,3690.28) (28,3613.81) (29,3536)
			(30,3473.75) (31,3411.44) (32,3341.91) (33,3272.13) (34,3202.38)
			(35,3151.59) (36,3086.81) (37,3032.38) (38,2965) (39,2900.63)
			(40,2845.53) (41,2783.22) (42,2710.94) (43,2561.22) (44,2278.72)
			(45,2042.88) (46,1841.84) (47,1691.44) (48,1537.66) (49,1307.66)
			(50,1134.16) (51,1015.38) (52,921.594) (53,856) (54,790.125)
			(55,732.594) (56,674.156) (57,624.25) (58,598.469) (59,584.313)
			(60,559.906) (61,543.844) (62,529.406) (63,516.969) (64,506.75)
			(65,500.188) (66,489.469) (67,484.781) (68,481.344) (69,475.469)
			(70,472.406) (71,468.656) (72,464.75) (73,460.438) (74,457.063)
			(75,452.438) (76,450.25) (77,448) (78,446.625) (79,442.781)
			(80,441.844) (81,441.063) (82,438.531) (83,437.594) (84,436.813)
			(85,435.25) (86,433.531) (87,432) (88,430.938) (89,430.063)
			(90,429.75) (91,429.75) (92,429.125) (93,428.188) (94,428.031)
			(95,427.625) (96,426.531) (97,425.75) (98,425.344) (99,425.031)
			(100,424.25) (101,423.531) (102,423.125) (103,422.813) (104,422.031)
			(105,421.094) (106,420.313) (107,419.281) (108,418.344) (109,417.563)
			(110,417.094) (111,417.094) (112,415.531) (113,414.75) (114,413.969)
			(115,413.344) (116,413.188) (117,412.313) (118,411.531) (119,410.75)
			(120,410.125) (121,409.813) (122,409.813) (123,409.344) (124,408.563)
		};
		\addplot[
		color=black,
		style=dashed,
		%mark=triangle,
		]
		coordinates {
			(0,16574) (1,16303.3) (2,16053.3) (3,15891.7) (4,15644.1)
			(5,15466.4) (6,15218.9) (7,14969.3) (8,14705.3) (9,14467.7)
			(10,14208.8) (11,13952.1) (12,13746.6) (13,13537.6) (14,13325.2)
			(15,13125.8) (16,12944.3) (17,12735.8) (18,12567) (19,12412.2)
			(20,12229.7) (21,12074.7) (22,11899.8) (23,11692) (24,11539.5)
			(25,11394) (26,11267.1) (27,11108.2) (28,10974.9) (29,10836.1)
			(30,10722.5) (31,10559.6) (32,10409.2) (33,10276.4) (34,10142)
			(35,10026.7) (36,9893.13) (37,9768.91) (38,9647.91) (39,9498.69)
			(40,9393.72) (41,9280.94) (42,9177.91) (43,9073) (44,8993.84)
			(45,8904.44) (46,8793.66) (47,8694.66) (48,8596) (49,8353.31)
			(50,7804.5) (51,7242.88) (52,6525.94) (53,5910.41) (54,5389.44)
			(55,4819.44) (56,4330.5) (57,3899.91) (58,3414.69) (59,3060.88)
			(60,2720.94) (61,2410.5) (62,2117.78) (63,1827.63) (64,1634.88)
			(65,1533.28) (66,1474.88) (67,1445.34) (68,1427.34) (69,1413.59)
			(70,1397.66) (71,1385.31) (72,1375.69) (73,1372.41) (74,1361.63)
			(75,1355.84) (76,1346.38) (77,1341.56) (78,1334.38) (79,1324.53)
			(80,1317.94) (81,1314.34) (82,1311.22) (83,1305.91) (84,1301.25)
			(85,1298.22) (86,1293.81) (87,1292.47) (88,1290.28) (89,1286.94)
			(90,1281.25) (91,1274.03) (92,1269.78) (93,1264.69) (94,1261.25)
			(95,1257.44) (96,1252.22) (97,1247.44) (98,1245.81) (99,1243.63)
			(100,1241.97) (101,1239.5) (102,1236.84) (103,1233.97) (104,1231.22)
			(105,1228.59) (106,1223.69) (107,1221.97) (108,1220.81) (109,1219.09)
			(110,1216.13) (111,1215.84) (112,1214.44) (113,1213.34) (114,1210.47)
			(115,1209.06) (116,1206.56) (117,1205.47) (118,1204.69) (119,1204.22)
			(120,1204.06) (121,1203.28) (122,1202.03) (123,1201.41) (124,1200.78)
		};
		\addplot[
		color=red,
		style=dashed,
		%mark=triangle,
		]
		coordinates {
			(0,24208.9) (1,23981.2) (2,23801.8) (3,23628.8) (4,23388.3)
			(5,23181) (6,22974.9) (7,22721.8) (8,22520.3) (9,22286)
			(10,22036.3) (11,21835) (12,21655.3) (13,21457.4) (14,21256)
			(15,21008.6) (16,20804.8) (17,20606.2) (18,20414.5) (19,20203.3)
			(20,20025.2) (21,19821.5) (22,19622.1) (23,19449.1) (24,19286.8)
			(25,19111.3) (26,18919.2) (27,18727.6) (28,18546.3) (29,18391.5)
			(30,18251) (31,18117.6) (32,17948.1) (33,17788.4) (34,17600.5)
			(35,17443.3) (36,17284.3) (37,17122.3) (38,16996.1) (39,16859.9)
			(40,16702.9) (41,16574.3) (42,16440.8) (43,16313.9) (44,16203.8)
			(45,16077.2) (46,15956.2) (47,15834.1) (48,15722.9) (49,15605.1)
			(50,15450.3) (51,15334.7) (52,15128.9) (53,14592.5) (54,13764.9)
			(55,12749.2) (56,11880.8) (57,11035.3) (58,10084.6) (59,9243.09)
			(60,8411.5) (61,7532.94) (62,6819.56) (63,6154.44) (64,5479.88)
			(65,4824.47) (66,4259.09) (67,3703.72) (68,3184.47) (69,2706.09)
			(70,2265.28) (71,2023.41) (72,1923.06) (73,1853.97) (74,1813.81)
			(75,1793.19) (76,1758.69) (77,1718.22) (78,1694.94) (79,1669.34)
			(80,1641.47) (81,1615.94) (82,1587.41) (83,1555.13) (84,1525.75)
			(85,1509.13) (86,1491.53) (87,1477.5) (88,1462.19) (89,1444.38)
			(90,1434.34) (91,1419.53) (92,1406.09) (93,1394.16) (94,1384.13)
			(95,1374.28) (96,1368.13) (97,1363.41) (98,1356.78) (99,1350.69)
			(100,1345.53) (101,1341.69) (102,1335.69) (103,1330.66) (104,1328.5)
			(105,1325.56) (106,1322.22) (107,1319.69) (108,1317.91) (109,1315.78)
			(110,1311.59) (111,1306.44) (112,1302.94) (113,1299.66) (114,1298.5)
			(115,1297.72) (116,1295.03) (117,1293.72) (118,1292.31) (119,1292)
			(120,1290.72) (121,1289.94) (122,1287.84) (123,1286.88) (124,1284.94)
		};
		\legend{S$-M_4$, M$-M_4$, L$-M_4$, S$+M_4$, M$+M_4$, L$+M_4$}
		
		\end{axis}
		\end{tikzpicture}
	\end{minipage}
	\cnenfigcaption{块交换邻域的重要性}{Significance of block swap neighborhood. (a) measursed by iteration; (b) measured by time}
	\label{fig1}
\end{figure}

虽然块交换动作~$M_4$~理论上可以由多个~$M_1$~至~$M_3$~组合而成, 但是其在本算法中仍起到了至关重要的作用. \textcolor{red}{为了分析排班交换动作对算法的影响, 分别在有无交换排班动作的条件下对算法进行了测试.} 图~\ref{fig1}~分别从迭代次数和运行时间两个角度展示了有无~$M_4$~时算法在单个阶段中的收敛情况, 所用数据来自于随机挑选的一个小规模算例（n035w4\_2\_8-8-7-5）一个中等规模算例（n070w4\_0\_3-6-5-1）和一个大规模算例（n110w4\_0\_1-4-2-8）的~$32$~次独立运行中对应
\textcolor{red}{迭代步数和}时间刻度位置取样所得的平均值. 三种规模的算例在图例中从小到大分别用~S、M~和~L~表示, 而是否使用~$M_4$~邻域用~$+$~和~$-$~表示. \textcolor{red}{例如, S$-M_4$~表示没有~$M_4$~的条件下算例~n035w4\_2\_8-8-7-5~的测试结果, S$+M_4$~表示有~$M_4$~的条件下算例~n035w4\_2\_8-8-7-5~的测试结果.} \textcolor{red}{图~\ref{fig1}~中左图的横坐标为搜索迭代步数, 纵坐标表示截止当前迭代步算法所求得的单个阶段的最优目标函数值; 右图的横坐标为算法执行时间, 纵坐标表示截止当前时间点算法所求得的单个阶段的最优目标函数值.} %其横坐标为时间刻度, 纵坐标表示截止当前时间点算法所求得的单个阶段的最优目标函数值.
%这是由于每次运行分为多个阶段, 整个排班周期的目标函数值还与全局约束~$\mathbf{S_7}$~与~$\mathbf{S_8}$~密切相关, 因此只选择单个阶段进行观察. 另外,
因为算法初期收敛速度非常快, 而后期目标函数值变化幅度较小, 导致等间隔取样的结果不便于观察比较. 故图中横坐标为对\textcolor{red}{迭代步数和}时间刻度取对数的结果, \textcolor{red}{分别为~$x= \log_ai$（左图）, }~$x= \log_at$\textcolor{red}{（右图）}, 其中~$a=1.08$, \textcolor{red}{$i$~为取样的迭代步数点,} $t$~为取样的时间点.

从图~\ref{fig1}~中可以看出, 以迭代次数为取样间隔时, 块交换对收敛速度的加速效果尤为明显, \textcolor{red}{即在相同的迭代步数下, 使用了交换排班动作的算法所得结果更优}. 但是由于其时间开销较高, 故以秒为时间单位时加速效果没有那么显著, 即在时间相同的情况下, 增加了块交换之后搜索执行的步数更少. 但在搜索初期的快速改进阶段和后期的深度搜索阶段仍有较大优势, 且收敛的极限优于没有块交换的情况. 由此可见, 块交换邻域无论从短期的收敛速度来考虑, 还是从长期的目标函数值下限来考虑, 都发挥了重要的作用.

\subsection{疏散性搜索策略对比分析}

\begin{table}[!t]
	\footnotesize
	\cnentablecaption{疏散性策略的计算结果对比}{Comparison of computational results between diversification strategies}
	\label{tab4}
	\tabcolsep 3.4pt %space between two columns. 用于调整列间距
	\begin{tabular*}{\textwidth}{c|ccc|ccc}
		\toprule
		\multirow{2}{*}{Instance} & \multicolumn{3}{c|}{Best} & \multicolumn{3}{c}{Average} \\\cline{2-7}
		 & Random walk & Partial rebuild & Adjust weight & Random walk & Partial rebuild & Adjust weight \\\hline
		n035w4\_0\_1-7-1-8         & 1675 & 1705 & 1685 & 1788.91 & 1778.28 & 1747.19 \\
		n035w4\_1\_0-6-9-2         & 1675 & 1650 & 1655 & 1791.56 & 1774.38 & 1747.03 \\
		n035w4\_2\_8-6-7-1         & 1520 & 1575 & 1555 & 1628.28 & 1656.25 & 1635.47 \\
		n035w8\_0\_6-2-9-8-7-7-9-8 & 3410 & 3315 & 3420 & 3665.00 & 3597.03 & 3578.28 \\
		n035w8\_1\_0-8-1-6-1-7-2-0 & 3400 & 3350 & 3370 & 3602.03 & 3616.88 & 3601.88 \\
		n035w8\_2\_2-1-7-1-8-7-4-2 & 3495 & 3420 & 3460 & 3769.84 & 3703.13 & 3682.50 \\
		n070w4\_0\_3-6-5-1         & 3115 & 3025 & 3010 & 3243.44 & 3170.78 & 3154.38 \\
		n070w4\_1\_1-3-8-8         & 3050 & 3040 & 3020 & 3118.75 & 3136.25 & 3128.44 \\
		n070w4\_2\_0-5-6-8         & 2895 & 2815 & 2890 & 3034.69 & 3021.41 & 3015.78 \\
		n070w8\_0\_3-3-9-2-3-7-5-2 & 6140 & 6035 & 5945 & 6415.94 & 6289.53 & 6230.16 \\
		n070w8\_1\_5-6-8-5-7-8-5-6 & 6105 & 5910 & 5940 & 6325.63 & 6219.22 & 6214.22 \\
		n070w8\_2\_4-9-2-0-2-7-0-6 & 6050 & 5865 & 5880 & 6373.44 & 6280.63 & 6210.94 \\
		n110w4\_0\_1-4-2-8         & 3340 & 3400 & 3355 & 3516.72 & 3565.94 & 3527.81 \\
		n110w4\_1\_0-1-6-4         & 3630 & 3615 & 3670 & 3765.31 & 3768.44 & 3794.38 \\
		n110w4\_2\_0-2-7-0         & 3745 & 3720 & 3760 & 3893.13 & 3907.66 & 3925.00 \\
		n110w8\_0\_2-1-1-7-2-6-4-7 & 6255 & 6300 & 6235 & 6595.16 & 6578.59 & 6532.97 \\
		n110w8\_1\_0-6-1-0-3-2-9-1 & 6310 & 6280 & 6270 & 6608.13 & 6512.66 & 6469.69 \\
		n110w8\_2\_2-9-5-5-1-8-4-0 & 5855 & 6115 & 6045 & 6257.34 & 6316.25 & 6300.94 \\
		\bottomrule
	\end{tabular*}
\end{table}

观察目标函数值的组成可以发现, 不同护士的惩罚有一定的差异. 然而由于众多约束相互制约, 局部搜索后期一旦落入局部最优就很难再进行结构性的调整, 而~\ref{subsec:weight}~节所述权重调整策略（Adjust weight）可以打破既定的排班格局, 为算法提供一个有导向而非盲目的疏散性搜索过程. 为了验证其有效性, 设计了另外两种扰动策略进行对比. 其一是随机游走（Random walk）, 即执行一定步数的合法邻域动作, 每个动作从~4~种邻域中等概率选择的一个邻域中随机挑选而得. 其二是部分重建（Partial rebuild）, 即随机保留解向量的部分元素, 然后对不满足人数下限的时间槽随机添加护士直至重新产生合法解. 对随机游走、部分重建和权重调整三种扰动方式进行了对比测试. 测试从决赛使用的算例中随机挑选了~$18$~个算例分别进行了~$32$~次独立的重复计算, 并统计了多次计算得到的目标函数值中的最优值和平均值. \textcolor{red}{表~\ref{tab4}~给出了对比结果, 其中~Random walk~表示使用随机游走作为扰动策略, Partial rebuild~表示使用部分重建作为扰动策略, Adjust weight~表示使用权重调整作为扰动策略, Best~表示~$32$~测试中的最优结果, Average~表示~$32$~测试的平均结果.}

从表~\ref{tab4}~可以看出, 比较~$32$~次计算求得的最优值, 不同疏散性搜索策略没有显著差异, \textcolor{red}{不存在一种策略在大部分算例上优于另外两种策略的情况}. 而对比平均值却可以发现使用了权重调整策略之后有比较明显的提升, 在~$75\%$~的算例上平均求解质量超过了另外两种扰动策略, 离算法所能求到的下限更加接近. 这说明本算法使用的权重调整策略是一种有效的疏散性搜索策略, 其有导向的扰动增加了算法的稳定性.

\subsection{全局约束近似评估策略对比分析}

\begin{table}[!t]
	\footnotesize
	\cnentablecaption{全局近似评估策略的计算结果对比}{Comparison of computational results between approximate global constraints evaluation strategies}
	\label{tab5}
	\tabcolsep 4.9pt %space between two columns. 用于调整列间距
	\begin{tabular*}{\textwidth}{c|ccc|ccc}
		\toprule
		\multirow{2}{*}{Instance} & \multicolumn{3}{c|}{Best} & \multicolumn{3}{c}{Average} \\\cline{2-7}
		& Ignore & Even allocation & EA on remainder & Ignore & Even allocation & EA on remainder \\\hline
		n035w4\_2\_8-6-7-1         & 2300 & 1610 & 1540 & 2505.31 & 1705.47 & 1642.81 \\
		n035w8\_0\_6-2-9-8-7-7-9-8 & 4700 & 3485 & 3410 & 5059.84 & 3695.47 & 3574.22 \\
		n070w8\_2\_8-6-0-1-6-4-7-8 & 8305 & 6390 & 6155 & 8725.31 & 6801.72 & 6502.03 \\
		n110w4\_1\_0-1-6-4         & 4930 & 3655 & 3630 & 5532.03 & 3837.50 & 3789.06 \\
		n110w4\_2\_0-2-7-0         & 5175 & 3685 & 3695 & 5693.59 & 3915.31 & 3931.88 \\
		n110w8\_2\_8-5-7-3-9-8-8-5 & 8810 & 5725 & 5565 & 9380.00 & 6047.34 & 5776.56 \\
		\bottomrule
	\end{tabular*}
\end{table}

为了分析全局约束\textcolor{red}{~$\mathbf{S_7}$~和~$\mathbf{S_8}$~}的近似评估策略对算法的影响, 设计对照实验比较了忽略全局约束（Ignore）、采用均分各阶段排班数的策略（Even allocation）和~\ref{subsec:global}~节所述的均匀分配剩余排班数的策略（EA on remainder）的求解质量. 实验随机挑选了~6~个算例分别进行了~$32$~次独立的测试.
\textcolor{red}{表~\ref{tab5}~给出了分别使用这三种策略多次测试所得最优结果（Best）和平均结果（Average）的对比情况.}

从表~\ref{tab5}~可以看出, 完全忽略全局约束效果较差, 无论是从求得的最优解来看还是从多次运行的平均值来看都不如另外两种方案. 而采用均匀分配剩余排班数, 使先前阶段排班的紧凑程度能影响到后续阶段的排班之后, 计算结果相比于均匀分配各阶段排班数有~$3\%$~左右的改进. 由此可见本算法使用的全局约束的近似评估策略的有效性.


\section{总结}

本文提出了一种用于求解多阶段护士排班问题的启发式算法. 在对第二届国际护士排班竞赛所提出的问题进行了简要的介绍之后, 本文详细描述了带权禁忌搜索算法. 算法以禁忌搜索为核心, 通过调整护士的惩罚权重来实现搜索过程中集中性与疏散性的平衡. 算法设计了增加排班、减少排班、变更排班和交换排班四种邻域结构, 并使用了一种根据其适应性动态调整各邻域被选中的概率的策略. 为了解决全局约束无法在单个阶段计算的问题, 算法使用了一种近似评估方案来衡量各阶段的排班对全局约束产生的影响.
此外, 本文通过对比实验展示了不同邻域结构对收敛速度产生的影响, 得出了权重调整策略对提升求解质量具有重要意义的结论, 表明了全局约束的近似评估策略的合理性.

第二届护士排班竞赛的计算结果表明了算法的有效性. 在决赛的~$60$~个算例上, 算法在保证结果合法性的同时, 求解质量也接近目前已知的最优解, 最终在第二届国际护士排班竞赛中获得了全球第四名的成绩.
但是, 由于算法使用的邻域变化模式比较简单, 对于约束众多的问题, 容易陷入局部最优, 或者难以跨过非法解以探索更广阔的解空间. 因此可以考虑增加更大的邻域, 对解空间进行更充分的探索. 与此同时, 对全局约束的近似评估策略也可以有更细致的考量, 让算法对多阶段问题的求解更接近掌握了整个排班周期的完整信息的理想状态.

值得注意的是, 带权禁忌搜索的思想并不局限于护士排班问题的求解, 其对解向量产生有潜力的结构性改变的能力, 可以在很多组合优化问题中得到应用, 为算法提供有导向的疏散性搜索. 而算法对多阶段问题的求解能力, 更接近大多数问题的现实情况. 对不确定因素和易变因素进行考虑, 将使理论问题的研究更具有实际意义和应用价值.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% 致谢, 非必选
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\Acknowledgements{}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% 补充材料说明, 非必选
%%% 有补充材料时请添加补充材料说明, 例如图S1~S5
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\Supplements{图S1$\sim$S5.}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% 参考文献, {}为引用的标签, 数字/字母均可
%%% 文中上标引用: \upcite{1,2}
%%% 文中正常引用: \cite{1,2}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\bibliography{bib}{}
%\bibliographystyle{plain}
\begin{thebibliography}{99}
	\bibitem{cheang2003nurse}
	Cheang B, Li H B, Lim A, et al.
	 Nurse rostering problems----a bibliographic survey.
	 European Journal of Operational Research, 2003, 151: 447--460
	
	\bibitem{burke2004state}
	Burke E K, De Causmaecker P, Berghe G V, et al.
	 The state of the art of nurse rostering.
	 Journal of scheduling, 2004, 7: 441--499
	
	\bibitem{de2011categorisation}
	De Causmaecker P, Berghe G V.
	 A categorisation of nurse rostering problems.
	 Journal of Scheduling, 2011, 14: 3--16
	
	\bibitem{isken2004implicit}
	Isken M W.
	 An implicit tour scheduling model with applications in healthcare.
	 Annals of Operations Research, 2004, 128: 91--109
	
	\bibitem{glass2010nurse}
	Glass C A, Knight R A.
	 The nurse rostering problem: A critical appraisal of the problem
	structure.
	 European Journal of Operational Research, 2010, 202: 379--389
	
	\bibitem{belien2008branch}
	Beli{\"e}n J, Demeulemeester E.
	 A branch-and-price approach for integrating nurse and surgery
	scheduling.
	 European journal of operational research,
	 2008, 189: 652--668
	
	\bibitem{he2012constraint}
	He F, Qu R.
	 A constraint programming based column generation approach to nurse
	rostering problems.
	 Computers \& Operations Research, 2012, 39: 3331--3343
	
	\bibitem{burke1999hybrid}
	Burke E, De Causmaecker P, Berghe G V.
	 A hybrid tabu search algorithm for the nurse rostering problem.
	 In: Proceedings of Simulated evolution and learning. Berlin: Springer, 1999. 187--194
	
	\bibitem{burke2001memetic}
	Burke E, Cowling P, De Causmaecker P, et al.
	 A memetic approach to the nurse rostering problem.
	 Applied intelligence, 2001, 15: 199--214
	
	\bibitem{burke2004variable}
	Burke E, De Causmaecker P, Petrovic S, et al.
	 Variable neighborhood search for nurse rostering problems.
	 In: Proceedings of Metaheuristics: computer decision-making.
	 Berlin: Springer, 2004. 153--172
	
	\bibitem{burke2008hybrid}
	Burke E K, Curtois T, Post G, et al.
	 A hybrid heuristic ordering and variable neighbourhood search for the	nurse rostering problem.
	 European Journal of Operational Research,
	 2008, 188: 330--341
	
	\bibitem{burke2010scatter}
	Burke E K, Curtois T, Qu R, et al.
	 A scatter search methodology for the nurse rostering problem.
	 Journal of the Operational Research Society,
	 2010, 61: 1667--1679
	
	\bibitem{burke2013time}
	Burke E K, Curtois T, Qu R, et al.
	 A time predefined variable depth search for nurse rostering.
	 INFORMS Journal on Computing, 2013, 25: 411--419
	
	\bibitem{bai2010hybrid}
	Bai R, Burke E K, Kendall G, Li J P, et al.
	 A hybrid evolutionary approach to the nurse rostering problem.
	 Evolutionary Computation, IEEE Transactions on,
	 2010, 14: 580--590
	
	% FORMAT
	\bibitem{anwar2014hyper}
	Anwar K, Awadallah M, Khader A T, et al.
	Hyper-heuristic approach for solving nurse rostering problem.
	 In: Proceedings of Computational Intelligence in Ensemble Learning (CIEL), 2014 IEEE Symposium on, Orlando, 2014. 1--6
	
	\bibitem{huang2014evolutionary}
	Huang H, Lin W J, Lin Z Y, et al.
	 An evolutionary algorithm based on constraint set partitioning for
	nurse rostering problems.
	 Neural Computing and Applications, 2014, 25: 703--715
	
	\bibitem{haspeslagh2014first}
	Haspeslagh S, De Causmaecker P, Schaerf A, et al.
	 The first international nurse rostering competition 2010.
	 Annals of Operations Research, 2014, 218: 221--236
	
	% FORMAT
	\bibitem{ceschia2015second}
	Ceschia S, Dang N T T, De Causmaecker P, et al.
	 Second International Nurse Rostering Competition(INRC-II)---Problem  Description and Rules---[J].
	 arXiv preprint arXiv:1501.04177, 2015
	
	\bibitem{valouxis2012systematic}
	Valouxis C, Gogos C, Goulas G, et al.
	 A systematic two phase approach for the nurse rostering problem.
	 European Journal of Operational Research, 2012, 219: 425--433
	
	\bibitem{burke2014new}
	Burke E K, Curtois T.
	 New approaches to nurse rostering benchmark instances.
	 European Journal of Operational Research, 2014, 237: 71--81
	
	\bibitem{lu2012adaptive}
	L{\"u} Z P, Hao J K.
	 Adaptive neighborhood search for nurse rostering.
	 European Journal of Operational Research, 2012, 218: 865--876
	
%
%% 专著
%% 作者名. 书名. 版次(第一版不用列出). 出版社所在城市名: 出版社名, 出版年份. 起止页码
%\bibitem{1}Gaydon A G, Wolfhard H G. Flames. 2nd ed. London: Chapman and Hall Ltd, 1960. 30--35
%
%% 期刊
%% 作者名. 文章题目(用小写字母). 期刊名, 年份, 卷号: 起止页码
%\bibitem{2}Xu Y B, Shen L S, Susan R M. Extension of the rice DH population genetic map with microsatellite markers. Chin Sci Bull, 1998, 43:149--153
%\bibitem{3}Hutton B. Product of fuzzy topological space. Topology Appl, 1980, 11: 59--61
%\bibitem{4}Wang K J, Zhang J Y, Li D, et al. Adaptive affinity propagation clustering. Act Autom Sin, 2007, 33: 1242--1246 [王开军, 张军英, 李丹, 等. 自适应仿射传播聚类. 自动化学报, 2007, 33: 1242--1246]
%
%% 论文集
%% 作者名. 文章题目. In: 编者名, eds. 论文集名称. 出版社所在城市名: 出版社名, 出版年份. 起止页码
%\bibitem{5}Polito V S. Calmodulin and calmodulin inhibitors: effect on pollen germination and tube growth. In: Mulvshy D L, Ottaviaro E, eds. Pollen: Biology and Implication for Plant Breeding. New York: Elsevier, 1983. 53--60
%
%% 会议论文集 (必须是正式出版的, 否则只能作为脚注)
%% 作者名. 文章题目. In: Proceedings of 会议名称. 出版社所在城市名: 出版社名, 出版年份. 起止页码
%% 作者名. 文章题目. In: Proceedings of 会议名称, 会议地点, 会议年份. 起止页码
%\bibitem{6}Dmtriev V. Complete tables of the second rank constitutive tensors for linear homogeneous bianisotropic media described by point magnetic groups of symmetry and some general properties of the media. In: Proceedings of IEEE MTT-S IMOC' 99. Berlin: Springer, 2000. 435--439
%
%% 学位论文
%% 作者名. 文题. 学位. 学校所在城市名: 学校名, 年份
%\bibitem{7}Wang X M. Study on Data Visualization Methods and Related Techniques for Clustering. Dissertation for Ph.D. Degree. Beijing: Tsinghua University, 2006 [王晓明. 面向聚类的数据可视化方法及相关技术研究. 博士学位论文. 北京: 清华大学, 2006]
%
%% 技术报告
%% 作者名. 报告名. 报告编号. 年份
%\bibitem{8}Phillips N A. The Nested Grid Model. NOAA Technical Report NWS22. 1979
%
%% 专利文献
%% 作者名. 专利国籍, 专利号
%\bibitem{9}Plank C J, Posinski E J. US Patent, 4 081 490, 1978-02-15
%
%% 使用手册
%% 作者名. 手册名及版本号, 年份
%\bibitem{10}Wang D L, Zhu J, Li Z K, et al. User Manual for QTKMapper Version 1.6, 1999
%
\end{thebibliography}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% 附录章节, 非必选
%%% 自动从A编号, 以\section开始一节
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\begin{appendix}
%\section{appendix1}

%\end{appendix}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% 自动生成英文标题部分
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\makeentitle

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% 主要作者英文简介, 数量不超过4个
%%% \authorcv[照片文件名]{姓名}{英文介绍}
%%% [照片文件名]请提供清晰的一寸浅色背景照片, 宽高比为 25:35
%%% {姓名}与英文标题处一致
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\authorcv[]{}{}

\authorcv[]{}{}

%\vspace*{6mm} % 调整照片行间距

\authorcv[]{}{}

\authorcv[]{}{}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% 补充材料, 以补充材料形式作网络在线, 不出现在印刷版中
%%% 自动从I编号, 以\section开始一节
%%% 可以没有\section
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\begin{supplement}
%\section{supplement1}

%\end{supplement}

\end{document}
